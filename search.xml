<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP 的流量控制机制</title>
      <link href="/2022/01/06/tcp-de-liu-liang-kong-zhi-ji-zhi/"/>
      <url>/2022/01/06/tcp-de-liu-liang-kong-zhi-ji-zhi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 的运输连接管理</title>
      <link href="/2022/01/06/tcp-de-yun-shu-lian-jie-guan-li/"/>
      <url>/2022/01/06/tcp-de-yun-shu-lian-jie-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-运输连接的三个阶段"><a href="#TCP-运输连接的三个阶段" class="headerlink" title="TCP 运输连接的三个阶段"></a>TCP 运输连接的三个阶段</h2><p>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的，共有三个阶段，即：</p><ul><li>连接建立（“三报文握手”）</li><li>数据传送</li><li>连接释放（“四报文挥手”）</li></ul><p>TCP 连接的建立采用客户–服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>，被动等待连接建立的应用进程叫做<strong>服务器</strong>。</p><blockquote><p>下文将<strong>客户</strong>简写为 A ，将<strong>服务器</strong>简写为 B 。</p></blockquote><h2 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h2><p>TCP 建立连接的过程叫做<strong>握手</strong>，握手需要在 A 和 B 之间交换三个 TCP 报文段。</p><p>首先，来认识一下握手挥手中用到的一些标识位和缩写的含义：</p><ul><li>SYN（Synchronize Sequence Numbers)：同步序列编号，表示建立链接</li><li>FIN：标识位，表示关闭链接</li><li>ACK（Acknowledgement）：标识位，表示响应</li><li>ack（Acknowledgement Number）：确认号码，是期望收到对方下一个报文的第一个数据字节的序号</li><li>seq（Sequence Number）：顺序号码（TCP连接中传送的字节流中的每个字节都按顺序编号）</li></ul><p>接下来先看下 TCP 三次握手的流程图：<br><img src="https://s4.ax1x.com/2022/01/05/TXqBZ9.png" alt="TCP 三次握手流程图"></p><ul><li>最初两端的 TCP 进程都处于 <code>CLOSED</code> （关闭）状态。</li><li>一开始，B 的 TCP 服务器进程先创建 <strong>传输控制块 TCB</strong> 【用于存储 TCP 连接中的一些重要信息，如 TCP 连接表、指向发送和接收缓存的指针、当前的发送和接收序号】，准备接受 A 的连接请求。然后服务器进程就处于 <code>LISTEN</code>（收听）状态，等待客户的链接请求。</li><li>A 的 TCP 客户进程也是首先创建 <strong>传输控制块 TCB</strong>。然后，在打算建立 TCP 连接时，向 B 发送 TCP 连接请求报文段，并进入 <code>SYN-SENT</code> （同步已发送）状态。<br>TCP 连接请求报文段首部中的同步位 <code>SYN = 1</code>（表明这是一个 TCP 连接请求报文段）；序号字段 <code>seq = x</code> （作为 TCP 客户进程所选择的初始序号）。【注意：TCP 规定 <code>SYN = 1</code> 的报文段不能携带数据，但要<strong>消耗掉一个序号</strong>。】</li><li>B 收到 TCP 连接请求报文段后，如果同意建立连接，则向 A 发送 TCP 连接请求确认报文段，并进入 <code>SYN-RCVD</code> （同步已接受）状态。<br>该报文段首部中的同步位 <code>SYN</code> 和确认位 <code>ACK</code> 都设置为 1 （表明这是一个 TCP 连接请求确认报文段）；序号字段 <code>seq = y</code>（作为 TCP 服务器进程所选择的初始序号），确认号字段 <code>ack = x + 1</code> （这是对 TCP 客户进程所选择的初始序号的确认）。【注意：这个报文段也不能携带数据，因为它是 <code>SYN</code> 被设置为 1 的报文段，但同样要消耗掉一个序号】。</li><li>A 收到 B 的确认后，还要向 B 发送一个普通的 TCP 确认报文段，并进入 <code>ESTABLISHED</code> （连接已建立）状态。<br>该报文段首部中的确认位 <code>ACK = 1</code> (表明这是一个普通的 TCP 确认报文段）；序号字段 <code>seq = x + 1</code> （这是因为 TCP 客户进程发送的第一个 TCP 报文段的序号为 x ，并且不携带数据，因此第二个报文段的序号为 x + 1）。【注意： TCP 规定普通的 TCP 确认报文段可以携带数据，但如果不携带数据，则不消耗序号】。在这种情况下，所发送的下一个数据报文段的序号仍是 <code>seq = x + 1</code>；确认号字段 <code>ack</code> 被设置为 y + 1 （这是对 TCP 服务器进程所选择的初始序号的确认）。</li><li>TCP 服务器进程收到该确认报文段后也进入 <code>ESTABLISHED</code> （连接已建立）状态。现在，TCP 双方都进入了连接已建立状态，他们可以基于已建立好的 TCP 连接进行可靠的数据传输了。</li></ul><p>现在有一个问题：为什么 A 最后还要发送一次确认呢？<br>答案是：防止已经失效的连接请求报文突然又传送到服务器，从而导致不必要的错误和资源的浪费。<br>所谓“已失效的连接请求报文段”是这样产生的：  </p><ul><li>先考虑一种正常情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 重新发送一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。这时 A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B ，没有“已失效的连接请求报文段”。  </li><li>现假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B 。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误以为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 B 发出确认新的连接就建立了。<br>而由于现在 A 不并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。这样的话， B 的许多资源就这样白白浪费了。</li></ul><blockquote><p>至此，三次握手就到此结束啦~</p></blockquote><h2 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h2><p>先看下四次挥手的流程图，心里有数好一点：<br><img src="https://s4.ax1x.com/2022/01/06/TvT11O.png" alt="TCP 四次挥手流程图"></p><ul><li>当TCP 的运输连接管理的第二个阶段-数据传输结束后，通信的双方都可释放连接。</li><li>现在 A 和 B 都处于 <code>ESTABLISHED</code> （连接已建立）状态。假设 A 的应用进程通知其主动关闭 TCP 连接，就发送 TCP 连接释放报文段，停止发送数据，并进入 <code>FIN-WAIT-1</code> （终止等待1）状态。<br>TCP 连接释放报文段首部中的终止位 <code>FIN</code> 和确认为 <code>ACK</code> 的值都被设置为 1 （表明这是一个 TCP 连接释放报文段，同时也对之前收到的报文段进行确认）；序号 <code>seq = u</code> （它等于 TCP 客户进程之前已传送过的数据的最后一个字节的序号加 1 ）【注意：TCP 规定终止位 FIN 等于 1 的报文段即使不携带数据，也要消耗掉一个序号。】；确认号 <code>ack = v</code> （它等于 TCP 客户进程之前已收到的数据的最后一个字节的序号加 1 ）。</li><li>B 收到 TCP 连接释放报文段后，会发送一个普通的 TCP 确认报文段并进入 <code>CLOSE-WAIT</code>（关闭等待） 状态。<br>TCP 确认报文段首部中的确认位 <code>ACK = 1</code> （表明这是一个普通的 TCP 确认报文段）；序号 <code>seq = v</code> （它等于 TCP 服务器进程之前已传送过的数据的最后一个字节的序号加 1 ，这也与之前收到的 TCP 连接释放报文段中的确认号匹配）；确认号 <code>ack = u + 1</code> （这是对 TCP 连接释放报文段的确认）。<br>收到 A 发来的连接释放报文段后，B 应用进程这时应通知高层应用进程：TCP 客户进程要断开与自己的 TCP 连接。于是，从 A –&gt; B 这个方向的连接就释放了。这时的 TCP 连接属于 <code>half-close</code> （半关闭）状态，也就是 A 已经没有数据要发送了。但如果 B 还有数据要发送，A 仍要接收。也就是说，从 B –&gt; A 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li><li>A 收到来自 B 的确认后，就进入 <code>FIN-WAIT-2</code> （终止等待2）状态，等待 B 发出的连接释放报文段。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 <code>FIN = 1</code> 。现假定 B 的序号为 w （在半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 <code>ack = u + 1</code> 。这时 B 就进入 <code>LAST-ACK</code> （最后确认）状态，等待 A 的确认。</li><li>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 <code>ACK = 1</code> ，确认号 <code>ack = w + 1</code> ，而自己的序号是 <code>seq = u + 1</code> （根据 TCP 标准，前面发送过的 FIN 报文段要消耗掉一个序号），然后进入到 <code>TIME-WAIT</code> （时间等待）状态。【<strong>注意：现在 TCP 连接还没有释放掉，必须经过时间等待计时器设置的时间 <code>2 MSL</code>（最长报文段寿命，RFC 793 建议设为 2 分钟，现如今 2 分钟可能已经太长了，可以自己修改合适的时间） 后，A 才能进入到 <code>CLOSED</code> 状态</strong>，然后才能开始建立下一个新的连接】。当 A 撤销相应的传输控制块 TCB 后，就算结束了这次的 TCP 连接。</li><li>B 只要收到了 A 发出的确认，立即进入 <code>CLOSED</code> 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。</li><li>可以看到，B 结束 TCP 连接的时间要比 B 早一些。</li></ul><p>那么问题又来了：为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？<br>答案是：①保证客户端发送的最后一个 ACK 报文段能够达到服务器；②防止已经失效的关闭连接报文段出现在本连接中。为什么这么说呢，可以来看看：  </p><ul><li>①由于这个 ACK 报文段有可能丢失，因而使处在 <code>LAST-ACK</code> 状态的 B 收不到对己发送的 FIN + ACK 报文段的确认。<br>B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。<br>接着 A 重传一次确认，重新启动 <code>2MSL</code> 计时器。最后，A 和 B 都正常进入到 <code>CLOSED</code> 状态。<br>如果 A 在 TIME-WAIT 状态不等待一段时间，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 <code>CLOSED</code> 状态。</li><li>② A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL ，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ul><blockquote><p>至此，四报文握手就到此结束啦~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 运输层 </tag>
            
            <tag> TCP </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文</title>
      <link href="/2022/01/05/zhi-xing-shang-xia-wen/"/>
      <url>/2022/01/05/zhi-xing-shang-xia-wen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hcyety.github.io/2021/12/27/var-let-const-de-qu-bie-shi-yong/">var let const 的区别使用</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们首先来看一个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照代码书写顺序，应该先输出 111，再输出 666 才对，但是很遗憾，两次输出均为 666。<br>如果我们将上述代码中的函数声明改为函数表达式，结果又不太一样：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//111</span><span class="token keyword">var</span> <span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是很意外，这其中的奥秘其实就在于JS的执行上下文里，看完下面的内容，你就会理解为什么了。</p><h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p><strong>JS 代码在执行之前，JS 引擎会先做一下“准备工作”，也就是创建对应的执行上下文。</strong><br>执行上下文有且只有三类：<strong>全局执行上下文</strong>，<strong>函数上下文</strong>，与eval上下文。由于eval一般不会使用，就不深入探究了。  </p><blockquote><p>插一句，在 JavaScript 中，运行环境主要包含了全局环境和函数环境。<br>而 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。<br>全局环境和函数环境所对应的执行上下文我们分别称为全局（执行）上下文和函数（执行）上下文。<br>下面进入正题：</p></blockquote><ol><li>全局执行上下文  </li></ol><ul><li>全局执行上下文只有一个，在客户端中一般由浏览器创建，也就是我们熟知的 window 对象，我们能通过 this 直接访问到它。<br><code>console.log(this);</code></li><li>全局对象 window 上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，如：<br><code>console.log(this.Math.random())</code>等</li><li>window 对象是 var 声明的全局变量的载体。我们通过 var 创建的全局对象，都可以通过 window 直接访问。  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  window<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ol start="2"><li>函数执行上下文<br>每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。（即使是调用同一个函数）<br>每次调用函数时，都会为该函数创建一个新的执行上下文。<br>于是我们很容易得知函数执行上下文可存在无数个。</li></ol><p>综上，执行上下文可以理解为代码在被解析以前或者在执行时候所处的环境。之所以这么理解，是因为全局上下文是在代码被解析前就已经由浏览器创建好了的，函数上下文是在函数调用时创建的。</p><blockquote><p>Q：接下来问题来了，我们写的函数多了去了，如何管理创建的那么多函数上下文呢？<br>A1：所以 JavaScript 引擎创建了执行上下文栈<code>（Execution context stack，ECStack）</code>【是一种拥有 LIFO（后进先出）数据结构的栈】来管理执行上下文。<br>A2：当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出  </p></blockquote><blockquote><p>既如此，当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 <code>globalContext</code> 表示它，并且只有当整个应用程序结束的时候（比如关闭网页或退出浏览器），ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 <code>globalContext</code> 。</p></blockquote><h2 id="执行上下文的三个重要属性"><a href="#执行上下文的三个重要属性" class="headerlink" title="执行上下文的三个重要属性"></a>执行上下文的三个重要属性</h2><h3 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h3><p>是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。   </p><blockquote><p>因为不同执行上下文下的变量对象稍有不同，所以来理一下全局上下文中的变量对象和函数上下文中的变量对象。</p><ul><li><strong>全局上下文中的变量对象就是全局对象！</strong><ul><li>全局对象是由 Object 构造函数实例化的一个对象。<br><code>console.log(this instanceof Object);</code></li></ul></li><li><strong>在函数上下文中，用活动对象来表示变量对象。</strong>      <ul><li>活动对象(activation object, AO)和变量对象其实是同一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</li><li>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</li></ul></li></ul></blockquote><blockquote><p>再看下执行过程：<strong>执行上下文的代码会分成两个阶段进行处理：创建（代码预编译）阶段 和 执行（代码执行）阶段</strong></p></blockquote><ul><li>1.预编译阶段（进入执行上下文，这时候还没有执行代码）<br>先进行语法分析，没有问题以后，在预编译阶段对JavaScript代码中<strong>变量的内存空间</strong>进行分配（变量提升就是在这个阶段完成的）。<ul><li>变量对象会包括：<ul><li>1）函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 <code>undefined</code></li></ul></li><li>2）函数声明【由名称和对应值（函数对象）组成一个变量对象的属性被创建】</li><li>3）变量声明【由名称和对应值（<code>undefined</code>）组成一个变量对象的属性被创建】</li></ul></li></ul>  举个栗子：  <pre class="line-numbers language-js" data-language="js"><code class="language-js">    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在进入执行上下文后，这时候的AO是：</span>    <span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>            <span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>            length<span class="token operator">:</span><span class="token number">1</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 函数调用时创建的函数上下文，所以为 1</span>        b<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>        c<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        d<span class="token operator">:</span><span class="token keyword">undefined</span>    <span class="token punctuation">&#125;</span>    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">               > [执行上下文创建阶段的另一种参考解释1](https://www.cnblogs.com/echolun/p/11438363.html)      [执行上下文创建阶段的另一种参考解释2](https://blog.csdn.net/qq_33718648/article/details/90754331)      [执行上下文创建阶段的另一种参考解释3](https://juejin.cn/post/6844903682283143181#heading-4)- 2.代码执行阶段（执行代码逻辑，修改变量对象的值）    </span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>js                    <span class="token comment">// 还是上面的栗子，当代码执行完之后，这时候的AO是：</span>    <span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>            <span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>            length<span class="token operator">:</span><span class="token number">1</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>        b<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>        c<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        d<span class="token operator">:</span>reference to FunctionExpression <span class="token string">"d"</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>总结上述所说：</li><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值，同时执行上下文在这个阶段会全部创建完成<h3 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h3>作用域链是指由当前上下文和上层上下文的一系列变量对象组成的层级链。</li></ul><p>我们已经知道，<strong>执行上下文分为创建和执行两个阶段</strong>，在执行上下文的执行阶段，当需要查找某个变量或函数时，会先在当前上下文的变量对象（活动对象）中进行查找，<strong>若是没有找到，则会依靠当前上下文中的作用域链，沿着上层上下文的变量对象进行查找，直到全局上下文中的变量对象（全局对象）</strong>。</p><blockquote><p>Q：既然如此，那作用域链又是怎么创建的？<br>A：我们都知道，JavaScript 中主要包含了全局作用域和函数作用域，而<strong>函数作用域是在函数被声明的时候确定的</strong>。<br>每一个函数都会包含一个 [[scope]] 内部属性，<strong>在函数被声明的时候，该函数的 [[scope]] 属性会保存其上层上下文的变量对象</strong>，形成包含上层上下文变量对象的层级链。**[[scope]] 属性的值是在函数被声明的时候确定的**。<br>当函数被调用的时候，其执行上下文会被创建并入栈。在创建阶段生成其变量对象后，会将该变量对象添加到作用域链的顶端并将 [[scope]] 添加进该作用域链中。而在执行阶段，变量对象会变为活动对象，其相应属性会被赋值。<br>所以，作用域链是由当前上下文变量对象及上层上下文变量对象组成的：<br><code>SC = AO + [[scope]]</code></p></blockquote><p>看个栗子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分析如下：</span><span class="token comment">// 在 fn1 函数上下文中，fn2 函数被声明，所以</span>fn2<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>fn1_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> globalObj<span class="token punctuation">]</span><span class="token comment">// 当 fn2 被调用的时候，其执行上下文被创建并入栈，此时会将生成的变量对象添加进作用域链的顶端，并且将 [[scope]] 添加进作用域链</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">SC</span><span class="token operator">=</span><span class="token punctuation">[</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token parameter">fn2<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">=></span>fn2_EC<span class="token punctuation">.</span><span class="token constant">SC</span><span class="token operator">=</span><span class="token punctuation">[</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> fn1_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> globalObj<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面用个例子总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> scope2 <span class="token operator">=</span> <span class="token string">'local scope'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> scope2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>①由于先处理函数声明。于是checkscope 函数被创建，保存作用域链到内部属性[[scope]]（[[scope]] 属性会保存其上层上下文的变量对象（也就是全局对象））</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>②执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>③checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  Scope<span class="token operator">:</span>checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>读到这里可能会有以下疑问：</p><blockquote><p>Q1：checkscope函数被创建时保存到[[scope]]的作用域链，和 checkscope执行前的准备工作中复制函数[[scope]]属性创建的作用域链有什么不同？<br>A1：checkscope函数创建的时候，保存的是根据词法所生成的作用域链。checkscope执行的时候，会复制这个作用域链，作为自己作用域链的初始化，然后根据环境生成变量对象，然后将这个变量对象，添加到这个复制的作用域链，这才完整的构建了自己的作用域链。  </p></blockquote></li></ul><blockquote><p>Q2：为什么会有两个作用域链？<br>A2：因为在函数创建的时候并不能确定最终的作用域的样子。而为什么会采用复制的方式而不是直接修改呢？应该是因为函数会被调用很多次吧。</p></blockquote><ul><li>④第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>    length<span class="token operator">:</span><span class="token number">0</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  scope2<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>⑤第三步：将活动对象压入checkscope 作用域顶端<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    scope2<span class="token operator">:</span><span class="token keyword">undefined</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>⑥准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    scope2<span class="token operator">:</span><span class="token string">'local scope'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>⑦查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>至此，作用域链的知识点over :）<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3>首先需要清楚，<code>this</code> 是执行上下文的一个属性，而不是某个变量对象的属性。<code>this</code> 的指向也不是如常识一般指向某某，而是依据调用栈和执行位置决定的（即取决于函数在哪里被调用）。【 <code>this</code> <strong>是在运行时绑定的，并不是在编写时绑定</strong>】<blockquote><p>this 绑定有五种场景：默认绑定、隐式绑定、显式绑定、new绑定、箭头函数绑定</p></blockquote></li></ul><ul><li><p>默认绑定<br>即函数调用时无任何调用前缀。默认绑定时，不管函数在何处调用， <code>this</code> 指向全局对象 <code>window</code>（非严格模式）；在严格模式下，默认绑定的 <code>this</code> 指向 <code>undefined</code>。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 666</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// --> 默认绑定</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught TypeError: Cannot read property 'num' of undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>温馨提示：在严格模式下调用不在严格模式中的函数，并不会影响this指向，如下：</p>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'yfz'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yfz</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>隐式绑定<br>如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">,</span>  func<span class="token operator">:</span> fn<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 666</span><span class="token comment">// 上面代码中，this 指向 obj，obj 有 num 属性，所以输出 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果函数调用前存在多个对象，this 指向距离调用自己最近的对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">,</span>  func<span class="token operator">:</span> fn<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">111</span><span class="token punctuation">,</span>  o<span class="token operator">:</span> obj<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里稍微拓展一下，如果将 obj 对象的 name 属性注释掉，却会输出 undefined</p>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  func<span class="token operator">:</span> fn<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'yfz'</span><span class="token punctuation">,</span>  o<span class="token operator">:</span> obj<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  obj 对象虽然是 obj1 的属性，但它们两个的原型链并不相同，并不是父子关系，由于 obj 未提供 name 属性，所以是 undefined 。注意不要将作用域链和原型链弄混淆了，如果有小伙伴不能弄清楚，也可以看看我的另一篇博客：<a href="https://hcyety.github.io/2022/01/07/yuan-xing-lian/">原型链</a>。</p></blockquote><blockquote><p>既然说到这里了，索性再理清一下作用域链与原型链的区别：<br>  –&gt; 当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象 window ，如果 window 都没有这个变量则报错。<br>  –&gt; 当在对象上访问某属性时，首先会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是 null ，如果全程都没找到则返一个 undefined ，而不是报错。</p></blockquote></li><li><p>显式绑定<br>指通过call、apply、bind以及js API中的部分方法改变this指向</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// call、apply、bind</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">111</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">999</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 111</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 666</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 999</span><span class="token comment">// API</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 3 次 666</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，如果在使用 call 之类的方法改变this指向时，指向参数提供的是 null 或者 undefined ，那么 this 将指向全局对象。</p></blockquote></li><li><p>new绑定</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> echo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>echo<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token comment">// 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上方代码中，构造调用创建了一个新对象 echo ，而在函数体内，this 将指向新对象 echo 上</p></li></ul><blockquote><p>如果一个函数调用存在多种绑定方法，this最终指向谁呢？<br>这里给出前面四种绑定方法的优先级：<br>显式绑定 &gt; 隐式绑定 &gt; 默认绑定<br>new绑定 &gt; 隐式绑定 &gt; 默认绑定  </p><p>为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错。</p></blockquote><ul><li>箭头函数this指向:<br>箭头函数中没有自己的 this ，箭头函数的 this 指向取决于外层作用域中的 this ：外层作用域或函数的 this 指向谁，箭头函数中的 this 便指向谁；最终保障是指向 window 。</li></ul><blockquote><p>参考学习资料：<a href="https://www.cnblogs.com/echolun/p/11962610.html">this的指向问题</a><br>另外可学习冴羽大神之不同的角度看this：<a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a></p></blockquote><p>说到这里，执行上下文的三个属性终于说完了，以上。</p><h2 id="执行上下文栈和执行上下文的具体变化过程"><a href="#执行上下文栈和执行上下文的具体变化过程" class="headerlink" title="执行上下文栈和执行上下文的具体变化过程"></a>执行上下文栈和执行上下文的具体变化过程</h2><p>还是那个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> scope<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>全局上下文初始化<pre class="line-numbers language-js" data-language="js"><code class="language-js">globalContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">VO</span><span class="token operator">:</span><span class="token punctuation">[</span>global<span class="token punctuation">]</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span>globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token operator">:</span>globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><ol start="3"><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>checkscope 函数执行上下文初始化：</li></ol><ul><li>1）复制函数 [[scope]] 属性创建作用域链，</li><li>2）用 arguments 创建活动对象，</li><li>3）初始化活动对象，即加入形参、函数声明、变量声明，</li><li>4）将活动对象压入 checkscope 作用域链顶端。</li><li>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    scope<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>    f<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="5"><li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  fContext<span class="token punctuation">,</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>f 函数执行上下文初始化, 以下跟第 4 步相同：</li></ol><ul><li>1）复制函数 [[scope]] 属性创建作用域链</li><li>2）用 arguments 创建活动对象</li><li>3）初始化活动对象，即加入形参、函数声明、变量声明</li><li>4）将活动对象压入 f 作用域链顶端<pre class="line-numbers language-js" data-language="js"><code class="language-js">fContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  arguments<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> checkscopeContext<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="7"><li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  globalContext<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>以上就是执行上下文的全部知识点，以及其底层实现过程，希望对大家有所帮助。</p></blockquote><h2 id="最后注明"><a href="#最后注明" class="headerlink" title="最后注明"></a>最后注明</h2><p>学习资料参考冴羽大神的博客：</p><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript深入之执行上下文栈</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript深入之变量对象</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript深入之作用域链</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/8">JavaScript深入之执行上下文</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var let const 的区别使用</title>
      <link href="/2021/12/27/var-let-const-de-qu-bie-shi-yong/"/>
      <url>/2021/12/27/var-let-const-de-qu-bie-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><strong>用于声明变量，变量声明的同时，可以赋值也可不赋值（不赋值的情况下，变量会保存一个特殊值 <code>undefined</code> ），后续可以更改变量的值。</strong></p><ul><li>注意1：<ul><li>变量名可以包含字母，数字，下划线和美元符号，但要以字母开头【也可以以$和_开头（但一般不这么用）】。</li><li>变量名是大小写敏感的（y和Y是不同的变量）</li><li>保留字（如JavaScript关键字）不能作为变量名使用</li></ul></li><li>注意2：var会发生“变量提升”现象。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> age<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这就是所谓的“变量提升”，也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用 var 声明同一个变量也没有问题：<pre class="line-numbers language-js" data-language="js"><code class="language-js">  <span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>### <span class="token keyword">var</span> 声明作用域使用 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">var</span><span class="token template-punctuation string">`</span></span> 操作符定义的变量会成为 包含它的函数的局部变量。比如，使用 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">var</span><span class="token template-punctuation string">`</span></span> 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>`js<span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">'hi'</span><span class="token punctuation">;</span>  <span class="token comment">// 局部变量</span><span class="token punctuation">&#125;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 出错！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这里，<code>message</code> 变量是在函数内部使用 <code>var</code> 定义的。函数为 <code>test()</code> ，调用它就会创建这个变量并给该变量赋值；调用之后变量随即被销毁，因此实例中的最后一行会导致错误。<br>不过，在函数内定义变量时省略 var 操作符，可以创建一个全部变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  message <span class="token operator">=</span> <span class="token string">'hi'</span><span class="token punctuation">;</span>  <span class="token comment">// 全局变量</span><span class="token punctuation">&#125;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "hi"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>去掉之前的 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test() ，就会定义这个变量，并且可以在函数外部访问到。<blockquote><p>注意：虽然可以省略 var 操作符定义全局变量，但不推荐这么做。因为在局部作用域中定义的全局变量很难维护，也会造成困扰。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 <code>ReferenceError</code> 。</p></blockquote></li></ul><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><strong>它的用法类似于var，但是所声明的变量，只在 let 命令所在的代码块内有效。</strong> 看下面例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'hg'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hg</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hg</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError：age 没有定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，age 变量之所以不能再 if 块外部被引用，是因为它的作用域仅限于该块内部。<br>由于块作用域是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let 。</p><ul><li>注意1：let不允许在相同作用域内，重复声明同一个变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js">  <span class="token comment">// 报错</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 报错</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 报错</span>  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> arg<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>  <span class="token comment">// 不报错</span>  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> arg<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">     - 注意2：let不像var那样会发生“变量提升”现象。## const**声明一个只读的常量。一旦声明，常量的值就不能改变；且声明变量时，就必须立即初始化，不能留到以后赋值。**- 注意1：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 的作用域与 </span><span class="token template-punctuation string">`</span></span><span class="token keyword">let</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 命令相同：只在声明所在的块级作用域内有效。- 注意2：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 命令声明的常量也是不提升，只能在声明的位置后面使用。- 注意3：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 声明的常量，也与 </span><span class="token template-punctuation string">`</span></span><span class="token keyword">let</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 一样不可重复声明。- 注意4：对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 声明的限制只适用于它指向的变量的引用。**const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，也就是说，如果 const 变量引用的是一个对象，那么修改整个对象内部的属性并不违反 const 限制。**       栗子1：    </span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>js    <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>    foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// TypeError："foo" is read-only</span>    <span class="token comment">// 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  栗子2：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可执行</span>a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 可执行</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Dave'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 报错</span><span class="token comment">// 上面代码中，常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a ，就会报错。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>关于变量提升，还有一些东西可以探讨一下。首先，变量提升是指把变量声明提升到当前执行环境的最顶端。</p><p>看一个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错ReferenceError</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 以上代码可看作：</span><span class="token keyword">var</span> foo<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错ReferenceError</span>foo <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，由于 <code>var</code> 发生了“变量提升”现象，将 <code>foo</code> 的声明提升到了 <code>console.log(foo)</code> 前面，即脚本开始运行时，变量 <code>foo</code> 已经存在了，但是没有值，所以会输出 <code>undefined</code>。<br>变量 <code>bar</code> 用 let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol><li><code>var</code> 和 <code>function</code> 的变量提升是有优先级的，且 <code>function</code> 的高于 <code>var</code> 的。（另外，如果函数名字相同，后面函数会覆盖前面的函数。）<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// ƒ a() &#123;&#125;</span><span class="token comment">// 可以隐式地理解为：</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> a<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ƒ a() &#123;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>当遇到函数和变量同名且都会被提升的情况，由于函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：function a()&#123; alert('我是函数') &#125;</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出：'我是变量'</span><span class="token comment">// 上面代码可以隐式的理解为：</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">var</span> a<span class="token punctuation">;</span>    <span class="token comment">// undefined</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//输出：function a()&#123; alert('我是函数') &#125;</span>a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span><span class="token comment">//赋值</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出：'我是变量'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>var 和 function 的变量提升优先级显而易见，但如果是函数声明 <code>function foo()&#123;&#125;</code> 和函数表达式 <code>var foo = function()&#123;&#125;</code> 呢？<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token comment">// function f1()&#123;&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token comment">// undefined</span><span class="token keyword">var</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 函数表达式</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 函数声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>上面的代码并不是说函数声明的提升优先级高于函数表达式，而是因为当遇到函数表达式的时候，首先会将<strong>关键字+变量名</strong>提升到当前执行环境的最顶端，也就是<code>var f2</code> 先被提升，然而此时 <code>f2</code> 的值为 <code>undefined</code>，所以 <code>f2</code> 打印值为 <code>undefined</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 之数据类型</title>
      <link href="/2021/12/06/js-zhi-shu-ju-lei-xing/"/>
      <url>/2021/12/06/js-zhi-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="7-种"><a href="#7-种" class="headerlink" title="7 种"></a>7 种</h3><p>ECMAScript 有 <code>6</code> 种<strong>简单数据类型</strong>（也称为<strong>原始类型</strong>）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>；还有一种复杂数据类型：<code>Object</code>。</p><p>除过上面的 6 种基本数据类型外，剩下的就是引用数据类型了，统称为 <code>Object</code> 类型。细分的话，有：<code>Object</code>类型、<code>Array</code> 类型、<code>Date</code> 类型、<code>RegExp</code>类型、<code>Function</code> 类型 等。</p><p>下面记录三个需要注意的数据类型：</p><h3 id="一、Undefined-类型"><a href="#一、Undefined-类型" class="headerlink" title="一、Undefined 类型"></a>一、Undefined 类型</h3><p><code>Undefined</code> 类型只有一个值，就是 <code>undefined</code>。当使用 <code>var</code> 或 <code>let</code> 声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code> 值，因此：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ECMA-262 第3版之前，字面量 <code>undefined</code> 是不存在的，增加这个值是为了正式明确空对象指针（null）和未初始化变量的区别。</p><p>需要注意的是，未声明的变量和声明了但未赋值的变量是不同的，请看下面例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "undefined"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前面说过，声明变量时没有进行初始化就相当于给变量赋予 <code>undefined</code> 值，于是可以打印出 <code>&quot;undefined&quot;</code> ；但未声明的变量进行打印等操作就会报错，这点不难理解。难以理解的是下面这一点，对于未声明的变量，只能执行一个有效的操作，那就是对它调用 <code>typeof</code> （对未声明的变量调用 <code>delete</code> 也不会报错，只是没什么用，实际上在严格模式下会抛出错误），问题来了：在对未初始化的变量调用 <code>typeof</code> 时，返回的结果是 <code>&quot;undefined&quot;</code> ，但对为声明的变量调用它时，也返回了 <code>&quot;undefined&quot;</code> ，这就有点不是很好。比如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "undefined"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// "undefined"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>无论变量是否声明，<code>typeof</code> 返回的都是 <code>&quot;undefined&quot;</code> 。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><blockquote><p>！注意：建议声明变量的同时进行初始化。这样，当 <code>typeof</code> 返回 <code>&quot;undefined&quot;</code> 时，开发者就能知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p></blockquote><h3 id="二、Null"><a href="#二、Null" class="headerlink" title="二、Null"></a>二、Null</h3><p><code>Null</code> 类型只有一个值，即特殊值 <code>null</code> 。**<code>null</code> 值表示一个空对象指针**，这就是 <code>typeof null</code> 会返回 <code>&quot;object&quot;</code> 的原因：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "object"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>!建议：在定义将来要保存对象值的变量时，建议使用 null 来初始化，而不是使用其他值。这样，只要检查整改变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>message <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// message 是一个对象的引用</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>这里还有一个小点： <code>undefined</code> 值是由 <code>null</code> 值派生来的，因此 ECMA-262 将它们定义为表面上相等，如 <code>console.log(null == undefined); // true</code> </p><h3 id="三、Symbol"><a href="#三、Symbol" class="headerlink" title="三、Symbol"></a>三、Symbol</h3><p>具体的参考阮一峰老师的 <a href="https://es6.ruanyifeng.com/#docs/symbol">ECMAScript 6 入门之 Symbol</a></p><h3 id="基本数据类型的特性"><a href="#基本数据类型的特性" class="headerlink" title="基本数据类型的特性"></a>基本数据类型的特性</h3><ol><li>基本数据类型的值是不可变的，任何方法都无法改变一个基本类型的值，比如一个字符串：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>name<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hang</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HELLO</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>通过这两个例子，我们会发现原先定义的变量name的值始终没有发生改变。</li><li>而调用 <code>substr()</code> 和 <code>toUpperCase()</code> 方法后返回的是一个新的字符串，跟原先定义的变量 name 并没有关系。</li></ul><p>或许有人会有以下的疑问：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>name <span class="token operator">=</span> <span class="token string">"change1"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>这样看起来 name 的值“改变了”，其实 var name = “change”，这里的基础类型是 string ，也就是“change”,这里的“change”是不可以改变的，name只是指向“change”的一个指针，指针的指向可以改变，所以你可以name = “change1”，代表此时name指向了“change1”。同理，这里的“change1”同样不可以改变。</li><li>也就是说这里你认为的改变只是“指针的指向改变”，这里的基础类型指的是“change”，而不是name，需区分清楚。</li></ul><ol start="2"><li>基本数据类型不可以添加属性和方法<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function-variable function">method</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>通过上面的代码，我们知道不能给基本类型添加属性和方法，也再次说明基本类型是不可变的。</li><li>基本数据类型的赋值是简单赋值</li></ol><p>如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>a<span class="token operator">++</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中， a 中保存的值是10。当使用 a 的值来初始化 b 时， b 中也保存了值 10 。但 b 中的 10 和 a 中的 10 是完全独立的。 b 中的值只是 a 中值的一个副本。所以这两个变量可以参与任何操作而不会相互影响。<br>4. 基本数据类型的比较是值的比较</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面 a 和 b 的数据类型不同，但是也可以进行值的比较，这是因为在比较之前，自动进行了数据类型的 隐式转换。<br>5. 基本数据类型是存放在栈区的</p><p>假如有以下几个基本类型的变量：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"jozo"</span><span class="token punctuation">;</span><span class="token keyword">var</span> city <span class="token operator">=</span> <span class="token string">"guangzhou"</span><span class="token punctuation">;</span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么它的存储结构如下所示：<br>|栈区A|栈区A|<br>|:–:|:–:|<br>|name|jozo|<br>|city|guangzhou|<br>|age|22|</p><p>同一个栈区里包括了变量的标识符和变量的值</p><h3 id="引用数据类型的特性"><a href="#引用数据类型的特性" class="headerlink" title="引用数据类型的特性"></a>引用数据类型的特性</h3><ol><li>引用类型的值是可以改变的</li><li>引用类型可以添加属性和方法</li><li>引用类型是同时保存在栈区和堆区中的</li></ol><p>引用类型的存储需要在内存的栈区和堆区共同完成，栈区保存变量标识符和指向堆内存的地址</p><p>假如有以下两个对象：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> man <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> woman <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>man <span class="token operator">===</span> woman<span class="token punctuation">)</span> <span class="token comment">// 输出：false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则这两个对象在内存中保存的情况如下图：<br><img src="https://s4.ax1x.com/2021/12/06/osS36O.png" alt="变量在内存中的保存情况"><br>4. 引用类型的赋值是对象引用</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change</span>b<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 a 向 b 赋值引用类型的值时，同样也会将储存在 a 中的对象的值复制一份，并放到为 b 分配的空间中。此时引用类型保存在 b 中的是对象在堆内存中的地址。所以，与基本数据类型的简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。那么赋值操作后，两个变量都保存了同一个对象地址，而这两个地址指向了同一个对象。因此，改变其中任何一个变量，都会互相影响。 他们的关系如下图：<br><img src="https://s4.ax1x.com/2021/12/06/osSDc8.png" alt="变量赋值后在内存中的保存情况"><br>5. 引用类型的比较是引用的比较</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token operator">==</span> person2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Q：为什么两个对象看起来一摸一样，但是却不相等呢？</li><li>A：因为引用类型的比较是引用的比较，换句话说，就是比较两个对象保存在栈区的指向堆内存的地址是否相同，此时，虽然 p1 和 p2 看起来都是一个”{}”，但是他们保存在栈区中的指向堆内存的地址却是不同的，所以两个对象不相等<h2 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h2><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3>用于确定任意变量的数据类型，对一个值使用 <code>typeof</code> 操作符会返回下列字符串之一：</li><li>“undefined” 表示值未定义；</li><li>“boolean” 表示值为布尔值；</li><li>“string” 表示值为字符串；</li><li>“number” 表示值为数值；</li><li>“object” 表示值为对象（而不是函数）或 null；</li><li>“function” 表示值为函数；</li><li>“symbol” 表示值为符号；</li></ul><p>使用 typeof 操作符的示例：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// es5</span><span class="token keyword">typeof</span> <span class="token string">''</span>           <span class="token comment">// string</span><span class="token keyword">typeof</span> <span class="token number">1</span>            <span class="token comment">// number</span><span class="token keyword">typeof</span> <span class="token boolean">true</span>         <span class="token comment">// boolean</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span>    <span class="token comment">// undefined</span><span class="token keyword">typeof</span> Array        <span class="token comment">// function</span><span class="token keyword">typeof</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>           <span class="token comment">// object</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>           <span class="token comment">// object</span><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// symbol</span><span class="token keyword">typeof</span> console      <span class="token comment">// object</span><span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log  <span class="token comment">// function</span><span class="token keyword">typeof</span> <span class="token keyword">null</span>         <span class="token comment">// object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是：<code>null</code> 会返回  <code>&quot;object&quot;</code> 是因为特殊值 <code>null</code> 被认为是一个对空对象的引用（这只是 <code>JavaScript</code> 存在的一个悠久 Bug，不代表 <code>null</code> 就是引用数据类型，并且 <code>null</code> 本身也不是对象）。那为什么会被这么认为呢？这就需要了解变量是如何被存储的。在 <code>Javascript</code> 底层存储变量的时候，会在变量的机器码低位 1-3 位表示类型信息：</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li><li>null：所有码都是0</li><li>undefined：用 -2^30 表示</li></ul><p>而 <code>null</code> 的低位 1-3 解析到的为 000，刚好与 <code>object</code> 一样，因此就被当做了对象来看待。</p></blockquote><p><code>typeof</code> 的实现大致如下，在 JS 诞生之初就只有六种类型判断：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_VOID</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断是否为 undefined</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_VOID</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_OBJECT</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 object</span>  obj <span class="token operator">=</span> <span class="token constant">JSVAL_TO_OBJECT</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ops <span class="token operator">=</span> obj<span class="token operator">-</span><span class="token operator">></span>map<span class="token operator">-</span><span class="token operator">></span>ops<span class="token punctuation">,</span> ops <span class="token operator">==</span> <span class="token operator">&amp;</span>js_ObjectOps<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token punctuation">(</span>clasp <span class="token operator">=</span> <span class="token constant">OBJ_GET_CLASS</span><span class="token punctuation">(</span>cx<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">,</span> clasp<span class="token operator">-</span><span class="token operator">></span>call <span class="token operator">||</span> clasp <span class="token operator">==</span> <span class="token operator">&amp;</span>js_FunctionClass<span class="token punctuation">)</span>    <span class="token operator">:</span> ops<span class="token operator">-</span><span class="token operator">></span>call <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    type <span class="token operator">=</span> <span class="token constant">JSTYPE_FUNCTION</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    type <span class="token operator">=</span> <span class="token constant">JSTYPE_OBJECT</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_NUMBER</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 number</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_NUMBER</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_STRING</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 string</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_STRING</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_BOOLEAN</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 boolean</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_BOOLEAN</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p>使用方法：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 判断一个实例是否属于某种类型：</span><span class="token keyword">let</span> <span class="token function-variable function">person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> nicole <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nicole <span class="token keyword">instanceof</span> <span class="token class-name">person</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token comment">// 判断一个实例是否是其父类型或者祖先类型的实例</span><span class="token keyword">let</span> <span class="token function-variable function">person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token function-variable function">programmer</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>programmer<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> nicole <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">programmer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nicole <span class="token keyword">instanceof</span> <span class="token class-name">person</span> <span class="token comment">// true</span>nicole <span class="token keyword">instanceof</span> <span class="token class-name">programmer</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法挺简单的，那么其底层实现原理是什么呢？根据 ECMAScript 语言规范，大概的思路如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">new_instance_of</span><span class="token punctuation">(</span><span class="token parameter">leftVaule<span class="token punctuation">,</span> rightVaule</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">let</span> rightProto <span class="token operator">=</span> rightVaule<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 取右表达式的 prototype 值</span>  leftVaule <span class="token operator">=</span> leftVaule<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// 取左表达式的__proto__值</span>  <span class="token comment">// 循环体一直循环，直到在 leftVaule 的原型链上找到 rightVaule；或者走到 leftVaule 原型链的尽头也还是找不到 rightVaule ，则退出循环</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVaule <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVaule <span class="token operator">===</span> rightProto<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 不用执行 rightVaule = rightVaule.__proto__ ，因为 rightVaule 就是要查找的对象</span>    leftVaule <span class="token operator">=</span> leftVaule<span class="token punctuation">.</span>__proto__ <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总而言之，<code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，要想理解 <code>instanceof</code> 的原理，就还必须熟悉 JavaScript 的原型继承原理，可参考我的另一篇文章：<a href=""></a>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的各种增删查改</title>
      <link href="/2021/11/22/shu-zu-de-ge-chong-zeng-shan-cha-gai/"/>
      <url>/2021/11/22/shu-zu-de-ge-chong-zeng-shan-cha-gai/</url>
      
        <content type="html"><![CDATA[<h2 id="一、增"><a href="#一、增" class="headerlink" title="一、增"></a>一、增</h2><h3 id="1-push-【改变原数组】"><a href="#1-push-【改变原数组】" class="headerlink" title="1. push 【改变原数组】"></a>1. push 【改变原数组】</h3><p><strong>定义：</strong><code>push()</code> 方法（在数组结尾处）向数组添加一个或多个新元素，返回值为新数组的长度</p><p><strong>语法：</strong><code>arr.push(ele,ele2,ele3…);</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> m <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'arr:'</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">'m'</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// arr:[1, 2, 3, 4, 5] m:5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-unshift-【改变原数组】"><a href="#2-unshift-【改变原数组】" class="headerlink" title="2. unshift 【改变原数组】"></a>2. unshift 【改变原数组】</h3><p><strong>定义：</strong><code>unshift()</code>方法（在开头）向数组添加一个或多个新元素，并“反向位移”旧元素，返回值为新数组的长度</p><p><strong>语法：</strong><code>arr.unshift(ele,ele2,ele…);</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> m <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"原数组："</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">"返回值:"</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原数组： ["a", "b", 1, 2] 返回值:4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-concat-【合成一个新数组，不改变原数组】"><a href="#3-concat-【合成一个新数组，不改变原数组】" class="headerlink" title="3. concat 【合成一个新数组，不改变原数组】"></a>3. concat 【合成一个新数组，不改变原数组】</h3><p><strong>定义：</strong><code>concat()</code> 方法通过合并（连接）一个或多个数组来创建一个新数组</p><p><strong>语法：</strong><code>arr.concat(arr1,arr2…);</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 合并两个数组</span><span class="token keyword">var</span> myGirls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Cecilie"</span><span class="token punctuation">,</span> <span class="token string">"Lone"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myBoys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Emil"</span><span class="token punctuation">,</span> <span class="token string">"Tobias"</span><span class="token punctuation">,</span> <span class="token string">"Linus"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myChildren <span class="token operator">=</span> myGirls<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>myBoys<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 连接 myGirls 和 myBoys</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myChildren<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Emma","Isabella","Jacob","Michael","Ethan"]</span><span class="token comment">// 合并三个数组</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Cecilie"</span><span class="token punctuation">,</span> <span class="token string">"Lone"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Emil"</span><span class="token punctuation">,</span> <span class="token string">"Tobias"</span><span class="token punctuation">,</span> <span class="token string">"Linus"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Robin"</span><span class="token punctuation">,</span> <span class="token string">"Morgan"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myChildren <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span> arr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ["Cecilie","Lone","Emil", "Tobias", "Linus","Robin", "Morgan"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-length-属性"><a href="#4-length-属性" class="headerlink" title="4. length 属性"></a>4. length 属性</h3><p>使用数组的 <code>length</code> 属性向数组添加新元素</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">[</span>fruits<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Lemon"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana","Orange","Apple","Mango","Lemon"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong><br>添加最高索引的元素可在数组中创建未定义的“洞”：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Lemon"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana","Orange","Apple","Mango","undefined","undefined","Lemon"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="splice-【改变原数组】"><a href="#splice-【改变原数组】" class="headerlink" title="splice 【改变原数组】"></a>splice 【改变原数组】</h3><p><strong>定义：</strong><code>splice()</code> 方法在数组中添加/删除/查看/修改项目，并返回删除的项目。</p><p><strong>语法：</strong><code>array.splice(index, howmany, item1, ....., itemX)</code>  </p><p><strong>参数：</strong></p><ul><li>index：必需。整数，指定在什么位置添加/删除项目，使用负值指定从数组末尾开始的位置。</li><li>howmany：可选。要删除的项目数。如果设置为 0，则不会删除任何项目。</li><li>item1, …, itemX：可选。要添加到数组中的新项目。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 第二个参数为 0 且有第三个或三个以上的参数即说明是增加元素，增加的元素数量为第二个参数之后的参数数量</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"Lemon"</span><span class="token punctuation">,</span> <span class="token string">"Kiwi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana","Orange","Lemon","Kiwi","Apple","Mango"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、删"><a href="#二、删" class="headerlink" title="二、删"></a>二、删</h2><h3 id="delete-【改变原数组】"><a href="#delete-【改变原数组】" class="headerlink" title="delete 【改变原数组】"></a>delete 【改变原数组】</h3><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">delete</span> fruits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ["undefined", "Orange", "Apple", "Mango"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="shift-【改变原数组】"><a href="#shift-【改变原数组】" class="headerlink" title="shift 【改变原数组】"></a>shift 【改变原数组】</h3><p><strong>定义：</strong><code>shift()</code> 方法删除数组的第一个元素，并返回删除的这个元素</p><p><strong>语法：</strong><code>array.shift();</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"原数组："</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">"返回值:"</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原数组： [2] 返回值:1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pop-【改变原数组】"><a href="#pop-【改变原数组】" class="headerlink" title="pop 【改变原数组】"></a>pop 【改变原数组】</h3><p><strong>定义：</strong><code>pop()</code> 方法删除数组的最后一个元素，并返回删除的这个元素</p><p><strong>语法：</strong><code>array.pop();</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"原数组："</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">"返回值:"</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原数组： [1] 返回值:2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>第二个参数不为 0 且无第三个参数则说明是从 以第一个参数为下标值 开始删除数组元素，删除的数组元素个数为第二个参数的值</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 在位置 2，添加新项目，并删除 1 个项目：</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana", "Orange", "Lemon"]</span><span class="token comment">// 在位置 2，删除 2 个项目：</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">,</span> <span class="token string">"Kiwi"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana", "Orange", "Kiwi"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、查"><a href="#三、查" class="headerlink" title="三、查"></a>三、查</h2><h3 id="slice-【不改变原数组】"><a href="#slice-【不改变原数组】" class="headerlink" title="slice 【不改变原数组】"></a>slice 【不改变原数组】</h3><p><strong>定义：</strong><code>slice()</code> 方法将原来的数组的元素替换，返回新的数组。</p><p><strong>语法：</strong><code>array.slice(start, end);</code></p><p><strong>参数：</strong></p><ul><li>start：可选。整数，指定从哪里开始选择（第一个元素的索引为 0）；若使用负数则从数组的末尾进行选择；如果省略，则类似于 “0”。</li><li>end：可选。整数，指定结束选择的位置；如果省略，将选择从开始位置到数组末尾的所有元素；若使用负数则从数组末尾进行选择。</li></ul><p><strong>注意：选定参数后，区间范围为【左闭右开】。即操作数组时，只截取从 start 到 end - 1 位置的数组元素</strong></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 两个参数都不写，就是复制完整数组；否则就是复制指定元素的数组</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"aaaa"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> newArr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [4, 5, 6, 3, 7, 8, 8]  ["aaaa", 5, 6, 3, 7, 8, 8]</span><span class="token comment">// 使用正值选择元素：</span><span class="token keyword">const</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Lemon"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> citrus <span class="token operator">=</span> fruits<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>citrus<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Orange","Lemon"]</span><span class="token comment">// 使用负值选择元素：</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Lemon"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myBest <span class="token operator">=</span> fruits<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myBest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Lemon","Apple"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p><strong>定义：</strong><code>includes()</code> 方法返回一个布尔值，表示某个数组是否包含给定的值</p><p><strong>语法：</strong><code>Array.includes(para, start);</code></p><p><strong>参数：</strong></p><ul><li>para：必需。表示要查找的值。</li><li>start：可选。表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       <span class="token comment">// true</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>       <span class="token comment">// false</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span>   <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p><strong>定义：</strong><code>indexOf</code> 法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1</p><p><strong>语法：</strong><code>Array.indexOf(para, index);</code></p><p><strong>参数：</strong></p><ul><li>para：必需。要查找的元素。</li><li>index：可选。开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1；如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找……。 注意：如果参数中提供的索引值是一个负值，并<strong>不改变其查找顺序</strong>，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 0</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// -1</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="find-【不改变原数组】"><a href="#find-【不改变原数组】" class="headerlink" title="find 【不改变原数组】"></a>find 【不改变原数组】</h3><p><strong>定义：</strong><code>find()</code> 方法返回通过测试（函数内判断）的数组的第一个元素的值。</p><p><strong>语法：</strong><code>Array.find(function(currentValue, index, arr),thisValue)</code></p><p><strong>参数：</strong></p><ul><li>function：必需。数组每个元素需要执行的函数。<ul><li>currentValue：必需。当前元素。</li><li>index：可选。当前元素的索引值。</li><li>arr：可选。当前元素所属的数组对象。</li></ul></li><li>thisValue：可选。传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值</li></ul><p><strong>说明：</strong><br>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</li><li>如果没有符合条件的元素返回 undefined</li></ul><p><strong>注意：</strong><br>find() 对于空数组，函数是不会执行的。</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> inventory <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'apples'</span><span class="token punctuation">,</span> quantity<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'bananas'</span><span class="token punctuation">,</span> quantity<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'cherries'</span><span class="token punctuation">,</span> quantity<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">findCherries</span><span class="token punctuation">(</span><span class="token parameter">fruit</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> fruit<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'cherries'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inventory<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>findCherries<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123; name: 'cherries', quantity: 5 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、改"><a href="#四、改" class="headerlink" title="四、改"></a>四、改</h2><h3 id="splice-1"><a href="#splice-1" class="headerlink" title="splice"></a>splice</h3><p>第二个参数不为 0 且有第三个或三个以上的参数则说明是从 以第一个参数为下标值 开始修改数组元素，修改的数组元素个数为第二个参数之后的参数数量</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> newArr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [4, 5, "a", "b", 3, 7, 8, 8] [6]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="reverse-【改变原数组】"><a href="#reverse-【改变原数组】" class="headerlink" title="reverse 【改变原数组】"></a>reverse 【改变原数组】</h3><p><strong>定义：</strong><code>reverse()</code> 方法可以反转数组中的所有元素</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'arr:'</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">'newArr:'</span> <span class="token operator">+</span> newArr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// arr:[5,4,3,2,1] newArr:[5,4,3,2,1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><strong>定义：</strong><code>reduce()</code> 方法对数组中的每个元素执行一个由您提供的函数(升序执行)，将其结果汇总为单个返回值。</p><p><strong>语法：</strong><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></p><p><strong>参数：</strong></p><ul><li>function(total,currentValue, index,arr)：必需。用于执行每个数组元素的函数。<ul><li>total：必需。初始值, 或者累计器累计回调的返回值。</li><li>currentValue：必需。当前元素。</li><li>currentIndex：可选。当前元素的索引。如果提供了<code>initialValue</code>，则起始索引号为0，否则从索引1起始。</li><li>arr：可选。调用reduce()的数组。</li></ul></li><li>initialValue：可选。传递给函数的初始值。如果没有提供初始值，则将使用数组中的第一个元素。</li></ul><p><strong>注意：</strong><br><code>reduce()</code> 对于空数组是不会执行回调函数的。</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> num</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> total <span class="token operator">+</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> ans <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>getSum<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 125</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对数组的各种操作就整理到这，如果读者没有找到自己想要的内容，可以尝试找找阮一峰的 <a href="https://es6.ruanyifeng.com/#docs/array">ECMAScript 6 入门 之数组的扩展</a>，或许能有所收获！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout() 与 setInterval() 的区别</title>
      <link href="/2021/11/15/settimeout-yu-setinterval-de-qu-bie/"/>
      <url>/2021/11/15/settimeout-yu-setinterval-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先要对 setTimeout() 和 setInterval() 有一个概念，学习了 JavaScript 我们知道：<strong>setTimeout() 是延时器，setInterval() 是定时器</strong>。setTimeout() 在于载入后延迟指定的时间后才会执行<strong>一次</strong>表达式，执行过后便会停止；setInterval() 在载入后每隔指定时间就会执行一次表达式，直到定时器或者窗口关闭。</p><p>对这两者有了初步印象后，我们开始逐个分析</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>setTimeout() 方法在指定的毫秒数后调用一次函数或计算表达式。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>var timeoutID = setTimeout(code/function, millisec)</code></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>code/funciton：必需。要调用的函数后要执行的 JavaScript 代码串或者函数。</li><li>millisec：必需。在执行代码前需等待的毫秒数。<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4>返回值 timeoutID 是一个正整数，表示定时器的编号。这个值可以传递给clearTimeout()来取消该定时器。<h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3>setTimeout() <strong>只执行 code 一次</strong>。如果要<strong>多次调用</strong>，请<strong>使用 setInterval() 或者让 code 自身再次调用 setTimeout()</strong><h3 id="清除-setTimeout"><a href="#清除-setTimeout" class="headerlink" title="清除 setTimeout()"></a>清除 setTimeout()</h3><code>clearTimeout(timeoutID)</code><br>timeoutID 为调用 setTimeout() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout() 所设定的定时执行操作。<h3 id="统一示例"><a href="#统一示例" class="headerlink" title="统一示例"></a>统一示例</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">eg</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你好'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//使用方法名字执行方法</span><span class="token keyword">let</span> t1 <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>eg<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用字符串执行方法</span><span class="token keyword">let</span> t2 <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"eg()"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除定时器</span>window<span class="token punctuation">.</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3></li><li>用于延迟执行某方法或功能</li></ul><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>setInterval() 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>语法与 setTimeout() 相同：</p><p><code>var intervalID = setInterval(code/function, delay)</code></p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>code/funciton：必需。要调用的函数后要执行的 JavaScript 代码串或者函数。</li><li>millisec：必需。在执行代码前需等待的毫秒数。<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4>此返回值 intervalID 是一个非零数值，用来标识通过setInterval()创建的计时器，这个值可以用来作为clearInterval()的参数来清除对应的计时器 。<h3 id="提醒-1"><a href="#提醒-1" class="headerlink" title="提醒"></a>提醒</h3>setInterval() 会<strong>重复执行多次</strong>。如果想<strong>只执行一次</strong>，请<strong>使用 setTimeout()</strong><h3 id="清除-setInterval"><a href="#清除-setInterval" class="headerlink" title="清除 setInterval()"></a>清除 setInterval()</h3><code>clearInterval(intervalID)</code><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3></li><li>用于刷新表单，对于一些表单的实时指定时间刷新同步</li></ul><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>在项目中使用这两者的时候会发现，调用函数的时候时间间隔虽然几乎相同，但并不精确，这时候如果项目中用这两者做动态效果，可能会发现：当程序中同时出现其他各种事件处理程序时，动画会变得不够平滑。那为什么会出现这种情况？</p><p>这是由于 JavaScript 其实是运行在单线程环境中的，这就意味着定时器仅仅是计划代码在未来的某个时间执行，而具体执行时机是不能保证的。<br>打个比方：我设置了一个定时器，这时候这个定时器事件就会被添加到待执行事项中，如果在这个定时器事件之前没有其他事件排队等待执行的话，就可以立即执行定时器事件；但如果前面有很多且耗时很久的事件等待执行，那这个定时器事件就不得不推迟时间执行了，这样一来，就不能如时按照指定的时间运行代码了。<br>因为这样，才会导致 setTimeout 和 setInterval 执行的时间间隔不能精确。那么有读者可能会问，影响这个时间间隔的因素是什么？答案是运行这两个方法的宿主环境，不同的浏览器、不同系统、不同版本的测试环境都会对其造成影响，事实上 GitHub 上早已有人 issue 该问题，然而至今仍然处于 open 状态：<a href="https://link.zhihu.com/?target=https://github.com/nodejs/node-v0.x-archive/issues/8066">setInterval doesn’t comply with DOM-version</a>、<a href="https://link.zhihu.com/?target=https://github.com/nodejs/node/issues/7346">setInterval interval includes duration of callback</a>、<a href="https://link.zhihu.com/?target=https://github.com/nodejs/node/issues/7554">setInterval/setTimeout interval should not include duration of callback</a></p><p>后面这个问题如果解决了，笔者会再来更新的~</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>知道 setTimeout() 和 setInterval() 是怎么一回事之后，在项目中合理采用就好了，一般问题不大，可能面试的时候会问到更加深入的东西？笔者也不知道呢，毕竟暂无面试经历，但准备面试过程中应该也少不了这方面的知识点拓展，有备无患 Orz。</p><p>这篇文章有相关的使用案例，可供读者参考：</p><blockquote><p><a href="https://www.cnblogs.com/lynnmn/p/6222753.html">setTimeout和setInterval的区别以及如何写出效率高的倒计时</a></p></blockquote><p>如果有说得不对的地方，还烦请大佬们指正，笔者愿与大家一起探讨 (<em>^▽^</em>)~~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tell it to myself</title>
      <link href="/2021/11/08/tell-it-to-myself/"/>
      <url>/2021/11/08/tell-it-to-myself/</url>
      
        <content type="html"><![CDATA[<h2 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h2><p>实习项目从开始做到现在已经过去 10 个星期了，前 9 个星期一直在努力实现各种模块各种功能点，直到上个星期才开始准备记笔记（也就因此搭建了个人博客），搭了一两天后博客已经运行起来，然后开始写博客的期间又断断续续更新了一部分主题配置，一个星期也就过去 2/3 了，这个时候我其实有点沉不住气了，因为想着快点弄完这些鸡毛蒜皮的事才好去接着开发项目的其他功能，于是耐着性子修复了项目一小部分的 bug 后（此时就已经发现的 bug 还有挺多的，但我没有心情全部修复），终于在周末的时候向 @Dangosky 交任务了，在这次聊天中我认识到了一个基本但极为重要的事情……</p><h2 id="重点敲黑板"><a href="#重点敲黑板" class="headerlink" title="重点敲黑板"></a>重点敲黑板</h2><p>Dangosky 跟我说，<strong>做项目追求速度而不注重质量，这样的项目做出来是没有什么用处的</strong>。</p><p>这样说是有道理的，他说：</p><ul><li>初学者做项目最忌讳冒进，贪多嚼不烂</li><li>首先要明确一点，做项目第一目标是从中学习东西，第二目标是有个项目经历之后才好些简历</li><li>同一个项目，即使你一个月搞出来了，但很多 bug ，很多设计问题、很多 bad case 没考虑到，面试官一问，什么都没想到、很多都答不出来，这样的项目做得再快也没用的</li><li>相反，你一个项目即使做上半年，但你做得很有质量，很多方面都考虑到了，甚至还思考到了项目可以拓展的地方（比如实现国际化语言等等），面试官一问你这个项目有什么亮点或不足，你能够头头是道，让你讲个二十分钟你都讲不完，这两种情况是完全不一样的</li></ul><p>我就属于注重速度那一类，没有沉住气来着重项目质量，以及完全吸收从项目中学习到的东西，反而总是想着要搞快点搞快点，抓紧时间把项目给搞出来，以至于忽略了做这个项目的初心。但现在我明白了，做这个项目最重要的应该是从中学习到新知识、新技术等，把自己的项目经历丰富起来，不应该倾向于开发速度。</p><p>同时，在做项目的过程中，bug 是必不可少的，<strong>解决 bug 也是一种提升实力的方式</strong>。<br>Dangosky 说：</p><ul><li>初学阶段，卡 bug 本身就是一种学习了</li><li>只是这种学习方式很难受，因为一直卡在那个地方解决不了，难免心态不好自我怀疑，比不上你敲代码实现一个新功能来的有成就感</li><li>但卡 bug 是每个人学习的必经之路，是躲不掉的。在工作之后，一个团队中也会有几个人一直是在修 bug ，摆正心态、明确目标就好了</li></ul><p>就我亲身经历而言，一开始做项目的时候，我会卡在一个地方不知道怎么办，那种感觉就像无头苍蝇一样，面对代码无从下手，要么是不知道从哪里排查问题，要么排查的方向有误，导致浪费了很多的时间。但渐渐的，我掌握一些技巧和方法了，知道一个报错该去什么地方解决，之后很多问题根据差不多的思路也可以很快找到对应的解决方法。这些都是在解决 bug 之后积累出来的经验，所以对于 <strong>卡 bug 本身就是一种学习</strong> 这句话，我是举双手双脚赞成的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>知道了自己“右倾”、心态不对劲之后，接下来我要做的便是摆正好心态、明确自己的目标了，心中有量尺，之后做的事就会有分寸。</p><blockquote><p>以此篇记录我在做项目过程中遇到的思想误区，告诫自己以后莫要再犯同样的错误了！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目之登录/注册模块</title>
      <link href="/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/"/>
      <url>/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客：<a href="https://hcyety.github.io/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/">React-Ts 项目：在线编程笔试平台</a> 有说到，这个项目是前后端分离项目，也就是说，其实该项目相当于两个项目，分别专注前端和后端，如果要上传到 <code>github</code> ，那么就需要创建两个仓库来分别放置。博主已经将源码 push ，读者可以跳转查阅：<a href="https://github.com/HCYETY/Online-programming-platform">前端项目仓库</a> — <a href="https://github.com/HCYETY/Online-programming-platform_service">后端项目仓库</a></p><p>前端项目采用的技术栈是 <code>React</code> 。UI 的设计是上下布局，即头部导航栏、下面主体内容，其中使用了 antd4 的 <code>Card</code> 和 <code>Form</code> 组件，效果如图所示：<img src="https://z3.ax1x.com/2021/11/02/IkyIBQ.png" alt="登录"><img src="https://z3.ax1x.com/2021/11/02/Ik63gf.png" alt="注册"></p><blockquote><p>本来想实现的效果是翻转卡片，即点击“登录”或“注册”就能将卡片翻转，同时“登录”面带有标签，可以切换登录方式：邮箱登录和账号登录，但奈何一直找不到合适的解决方法，就使用了 antd 的 <strong>带标签页的卡片</strong>，如果读者知道如何解决这一问题，还望不吝赐教 ^_^</p></blockquote><p>后端项目采用的技术栈是 <code>NodeJs</code> ，使用的数据库是 <code>MYSQL</code> 。项目中运用了 <code>Koa</code> 和 <code>TypeORM</code> 框架来搭建 <code>Node</code> 服务和操作  <code>MYSQL</code> 数据库。</p><blockquote><p>项目所使用的技术栈读者已经清楚，我们继续往下看吧~~</p></blockquote><h2 id="注册模块（支持邮箱注册）"><a href="#注册模块（支持邮箱注册）" class="headerlink" title="注册模块（支持邮箱注册）"></a>注册模块（支持邮箱注册）</h2><h3 id="code-前思考"><a href="#code-前思考" class="headerlink" title="code 前思考"></a>code 前思考</h3><p>首先我们需要理清注册的逻辑，联想我们在一个网站上注册时，操作流程是怎么样的。我们可以很快知道，通常有两种方式，一种是手机号注册，一种是邮箱注册。</p><ol><li><p>手机号注册<br><img src="https://z3.ax1x.com/2021/11/03/IAj9Rx.jpg" alt="常见手机注册"></p></li><li><p>邮箱注册<br><img src="https://z3.ax1x.com/2021/11/03/IAXWqg.jpg" alt="常见邮箱注册"></p></li></ol><blockquote><p>注册的方式有很多种，除了手机邮箱注册，还有用户名/xx号注册、第三方注册等，具体想选择哪种方式实现注册，读者可以自行选择，下面我们还需要来看看如何实现前后端的连接，以跑通整个项目。</p></blockquote><blockquote><p>情况说明：博主选择的方式是邮箱注册。</p></blockquote><h3 id="逻辑思考"><a href="#逻辑思考" class="headerlink" title="逻辑思考"></a>逻辑思考</h3><ol><li>用户在前端界面填写表单信息，点击“获取验证码”按钮后，会【发送请求】给后端</li><li>后端【接收前端传来的请求】后，会随机生成一个包含大小写字母和数字的 6 位数验证码，并将该验证码存储在数据库中，同时【响应数据】（这里指验证码）给前端。</li><li>前端【接收后端响应体】（这里指后端传过来的验证码）后，必须填入表单中才能提交（表单组件可以在 rule 里设定 required ）。</li><li>点击“提交”后，这时前端发送的请求体中包含了表单中的所有数据，同样将其发送给后端。后端获取请求体中的所有信息，根据邮箱账号从数据库中查询是否已经存储了该用户，若查找不到则说明无人使用该邮箱注册过，可以允许注册，将邮箱和密码等相关信息一并存进数据库中；否则直接响应数据，告知前端该用户已经注册。前端根据后端响应的信息进行对应的操作，如注册成功，可以跳转到登录页面进行登录，否则弹出警告，告知用户注册信息填写有误。</li></ol><blockquote><p>说到这里，读者应该懂得了将前后端项目串联起来的一系列逻辑，概括起来便是前端调用后端接口【发送请求】，后端设定接口给前端调用【接收请求】，这样一来前后端便可以互连跑通服务了。</p></blockquote><blockquote><p>但问题来了，“你说了这么多，我还是不知道该怎么在前端调用后端接口，后端又如何接收到前端传来的请求”？别急，博主只是先抛砖引玉，先给大家捋顺跑通前后端服务的逻辑，心里好有个底。下面我们继续往下</p></blockquote><ol start="5"><li>前端发送请求的方式有多种，如 fetch、axios 等，这里使用的是 axios ，下面自定义封装的 axios 函数，仅供大家参考：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录下/src/api/index.ts</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span><span class="token comment">// 注意这个路径，http://localhost:8080 是后端服务的地址，/api 是请求的固定格式，后面调用该函数的时候还会再传入一个参数 /xxx ，因此后端要想接收前端请求，就必须配置接口路径成 前端服务的地址/api/xxx ，这样前后端项目才能跑通【不理解的话后面代码还会有注释】</span><span class="token keyword">const</span> <span class="token constant">REQUESTIP</span><span class="token operator">:</span> string <span class="token operator">=</span> <span class="token string">"http://localhost:8080/api"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span>method<span class="token operator">:</span> <span class="token string">'get'</span> <span class="token operator">|</span> <span class="token string">'post'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">url<span class="token operator">:</span> string<span class="token punctuation">,</span> params<span class="token operator">?</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> data <span class="token operator">=</span> method <span class="token operator">===</span> <span class="token string">'get'</span> <span class="token operator">?</span> <span class="token punctuation">&#123;</span>      params    <span class="token punctuation">&#125;</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      data<span class="token operator">:</span> params    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 调用函数时会传入 url （相当于上面说的xxx），在这里进行拼接，就成了前端调用后端接口的完整 url 了：后端服务地址/api/xxx</span>    url <span class="token operator">=</span> <span class="token constant">REQUESTIP</span> <span class="token operator">+</span> url<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        url<span class="token punctuation">,</span>        method<span class="token punctuation">,</span>        <span class="token operator">...</span>data<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">const</span> get <span class="token operator">=</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> post <span class="token operator">=</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span><span class="token string">'post'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>调用 axios 封装函数的时候：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录/src/api/modules/interface.ts</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> post <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'根目录/src/api/index'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testRegister</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token operator">:</span> <span class="token punctuation">&#123;</span> email<span class="token operator">:</span> string<span class="token punctuation">;</span> cypher<span class="token operator">:</span> string<span class="token punctuation">;</span> captcha<span class="token operator">:</span> string<span class="token punctuation">;</span> identity<span class="token operator">:</span> number<span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 此时前端请求的整个路径为 http://localhost:8080/api/register，那么假设前端项目地址为 http://localhost:3000 ，后端就需要定义接口路径为 http://localhost:3000/api/register</span>  <span class="token keyword">return</span> <span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/register'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 文件结构：根目录/src/pages/login/index.tsx</span><span class="token comment">// 这里结构其实不是很好，因为注册和登录是写在一块的，没有分开来。读者清楚是在注册事件下发送 axios 请求的就好</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> testRegister <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'根目录/src/api/modules/interface'</span><span class="token punctuation">;</span>  <span class="token comment">// 点击“注册”按钮触发的函数：</span><span class="token function-variable function">submitRegister</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">values<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 表单的值</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> account<span class="token punctuation">,</span> password<span class="token punctuation">,</span> identity<span class="token punctuation">,</span> email<span class="token punctuation">,</span> cypher<span class="token punctuation">,</span> captcha <span class="token punctuation">&#125;</span> <span class="token operator">=</span> values<span class="token punctuation">;</span>  <span class="token comment">// 请求参数</span>  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> email<span class="token punctuation">,</span> cypher<span class="token punctuation">,</span> captcha<span class="token punctuation">,</span> identity <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// ！发送请求并获取返回值</span>  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">testRegister</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注册成功</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在当前页跳转至登录界面</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> noTitleKey<span class="token operator">:</span> <span class="token string">'login'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    message<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>然后是在后端定义接口。博主的后端项目使用了 <code>Koa</code> 框架，因此可以调用它的 API :</li></ol><blockquote><p>注意：如果是本地项目要解决跨域，Koa 可以使用 koa2-cors 直接解决；但如果是线上项目的话，还需要另外的配置，网上有多种处理跨域的解决方法，博主采用的方法是配置 nginx 反向代理，具体操作可以跳转到另一篇博客：<a href="https://hcyety.github.io/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/">前后端分离项目线上部署</a>，里面有配置 nginx 的具体步骤，在这里不加叙述。</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 下面 code 仅供参考，大致是这么一个模式</span><span class="token keyword">import</span> Koa <span class="token keyword">from</span> <span class="token string">'koa'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'koa-router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> bodyParser <span class="token keyword">from</span> <span class="token string">'koa-bodyparser'</span><span class="token punctuation">;</span>        <span class="token comment">// 处理 post 请求，有了这个插件才能获取 post 参数【通常前端的请求方式是 post 】</span><span class="token keyword">import</span> cors <span class="token keyword">from</span> <span class="token string">'koa2-cors'</span><span class="token punctuation">;</span> <span class="token comment">// 处理跨域问题</span><span class="token keyword">import</span> register <span class="token keyword">from</span> <span class="token string">'./middleware/register'</span><span class="token punctuation">;</span>   <span class="token comment">// 导入注册的 .ts 文件，用于处理注册事件【通常不放在入口文件里，而是单独抽出来】</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cors</span><span class="token punctuation">(</span>corsOptions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 处理 post 请求的参数。</span><span class="token comment">// 注意这个插件的位置，必须要放在匹配接口之前！！！</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">bodyParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 匹配接口，这里的路径和前端请求路径中端口号后面那部分是保持一致的</span>router<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/api/register'</span><span class="token punctuation">,</span> register<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 组装匹配好的路由，返回一个合并好的中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里启动的后端服务是 8080 端口</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'网站服务器启动成功，请访问 http://localhost:8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>说一句：定义好了后端接口，可以查阅 <a href="https://cloud.tencent.com/developer/article/1876810">postman 使用教程</a>，在 <a href="https://www.postman.com/downloads/">postman 官网</a> 下载 <code>postman</code> ，方便测试接口是否被成功调用，推荐使用！</p></blockquote><h2 id="登录模块（支持邮箱登录）"><a href="#登录模块（支持邮箱登录）" class="headerlink" title="登录模块（支持邮箱登录）"></a>登录模块（支持邮箱登录）</h2><ol><li>跑通前后端服务的逻辑同注册一致，也是【前端发送请求】–【后端接收请求】–【后端响应请求】 –【前端接收响应】 </li></ol><blockquote><p>然而这样简单地实现登录功能，用户是可能通过控制台篡改后端的响应数据的，进而实现登录跳转，这里采用后端 session 身份验证进行防范。同时前端需实现登录拦截，防止用户未经登录便通过 url 跳过登录验证。</p></blockquote><ol start="2"><li>所谓 session 身份验证，打个比方就是“你第一次来的时候我发给你一张身份证，但只是一张写着身份证号码的纸片。以后你每次来办事，我根据这张身份证去后台查一下你的 id 是不是有效”。  </li></ol><p>对应到登录功能，就是每次用户登录的时候，后端获取到用户邮箱，根据这个邮箱查找数据库中存储的该用户的信息，若查找不到说明该用户未注册；若查找得到则说明该用户已注册成功，可以往下匹配密码，若密码错误，则不能登录，也就不用“发放身份证”了；若密码正确，则“可以发放带有身份证号码的身份证”–生成 session 并存进 cookie 中响应给前端。这样用户就算篡改后端响应数据，要登录的时候 session 还是会发生更改，不会与用户篡改后的数据相匹配；同时如果用户在未登录的状态下更改 url ，也会触发登录拦截，后端会验证登录状态。</p><blockquote><p>这个 session 是一个长度为 20 左右的包含数字和大小写字母的 session 随机数，将这个随机数①存进该用户的信息中，以便在维护登录状态时可以根据用户账号获取；②生成一个 cookie ，将 session 存进该 cookie 中。  </p><p>那么问题又来了，session 可以通过 JS 函数 return 一个值得到，但这个 cookie 该如何生成？ session 又如何存进 cookie 中？</p></blockquote><p>在 Koa 中，这两个问题可以一并解决：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录/src/middleware/login.ts</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token operator">:</span>Context</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// generateMixed() 是封装的 JS 函数，用于生成随机数</span>  <span class="token keyword">const</span> session <span class="token operator">=</span> <span class="token function">generateMixed</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置 cookie </span>  ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>    <span class="token string">'session'</span><span class="token punctuation">,</span> session<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> httpOnly<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> maxAge<span class="token operator">:</span> <span class="token number">3600000</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在前端封装 axios 函数的地方加上配置 <code>axios.defaults.withCredentials = true;</code> 之后，就会在前端每次向后端请求数据时，请求头中自动带上 cookie ，后端便可以获取到这个 cookie 对用户身份进行验证：如果与数据库中该用户的 session 一致，则说明用户处于登录状态，否则用户未登录。可以设一个字段标识登录状态，返回给前端，以便前端判断用户是否登录成功。</p><ol start="3"><li>前端在路由页面发送登录请求（参数为 cookie ），如果后端接收到了 cookie ，并在数据库中找到 session 为 cookie 的用户信息，说明用户处于登录状态，否则处于未登录状态。对于未登录的用户，重定向到登录页面即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
            <tag> 注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Ts 项目：在线编程笔试平台</title>
      <link href="/2021/11/02/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/"/>
      <url>/2021/11/02/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客说到线上部署项目到服务器，博主说的就是这个 React-Ts 项目啦，它是博主为将来找实习准备的，用到的技术点有好一些是边学边做的，如果有不同见解的地方还请读者不吝赐教。</p><blockquote><p>需要事先说明的是，关于这个项目的博客，博主并不打算讲解代码实现，每个人的项目用到的技术栈不尽相同，但有一点可以确定，就是项目功能点的实现逻辑是大致相同的，故博主会更多地讲解各模块/功能点的逻辑实现 ^_^</p></blockquote><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>该项目是一个在线编程笔试平台。<br>主要功能是面试官①编辑（可新增、修改、删除）试卷和试题【一张试卷有多道试题】；②查看候选人编程结果并给予评分和备注等信息。候选人①在线完成代码编写并提交；②根据面试官设定的查看权限，决定能否查看已提交或已结束的试题。<br>该项目包含了前端和后端两种技术栈，前端采用的是 React ，后端采用的是 NodeJs ，整个项目为前后端分离项目。</p><h2 id="项目任务拆解"><a href="#项目任务拆解" class="headerlink" title="项目任务拆解"></a>项目任务拆解</h2><ol><li>登录/注册模块</li></ol><ul><li>支持邮箱登录和注册</li><li>支持退出登录</li></ul><ol start="2"><li>面试题模块</li></ol><ul><li>面试官可填写试卷和面试题</li><li>支持新建、修改、删除试卷和面试题目</li><li>支持邀请多个候选人编程</li><li>面试题目支持富文本格式</li></ul><ol start="3"><li>在线编程模块</li></ol><ul><li>候选人可在线编写代码</li><li>代码支持多种语言高亮</li><li>候选人侧可提交最终编程代码</li><li>面试官侧刷新能看到最终代码</li></ul><ol start="4"><li>在线留言模块</li></ol><ul><li>候选人可以通过文字给面试官留言</li><li>面试官可以回复</li><li>留言内容长期保存</li><li>留言模块自动刷新</li></ul><ol start="5"><li>在线编程模块支持自动刷新</li></ol><ul><li>候选人侧代码支持自动保存</li><li>面试官侧代码自动刷新</li></ul><ol start="6"><li>在线留言模块改成实时文字聊天</li></ol><ul><li>候选人和面试官可实时文字聊天</li><li>其他获得链接的人都可参与文字聊天</li></ul><ol start="7"><li>在线语音聊天模块</li></ol><ul><li>候选人和面试官可实时语音聊天</li></ul><ol start="8"><li>在线编程模块支持运行JS代码</li></ol><ul><li>候选人和面试官可在线运行 JS 代码并查看输出</li></ul><ol start="9"><li> 在线编程模块支持协同编辑</li></ol><ul><li>候选人和面试官可实时协作编程<h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2></li><li><input checked="" disabled="" type="checkbox"> 2021/09/04：实现登录/注册的静态页面</li><li><input checked="" disabled="" type="checkbox"> 2021/09/19：实现登录/注册逻辑（包括账号密码登录、登录拦截，session 身份验证）</li><li><input checked="" disabled="" type="checkbox"> 2021/09/29：初步部署前后端项目到阿里云服务器</li><li><input checked="" disabled="" type="checkbox"> 2021/10/04：购买域名并实现自动化部署项目</li><li><input checked="" disabled="" type="checkbox"> 2021/10/05：支持使用邮箱 登录和注册（删除了账号密码登录、注册的方式）</li><li><input checked="" disabled="" type="checkbox"> 2021/10/09：支持新建/删除试卷，在“新建试卷”里新建/修改/删除试题，发送邮件至候选人邮箱</li><li><input checked="" disabled="" type="checkbox"> 2021/10/23：初步完成面试题模块（包含“修改试卷”）</li><li><input checked="" disabled="" type="checkbox"> 2021/10/30：初步完成在线编程模块</li><li><input checked="" disabled="" type="checkbox"> 2021/10/31：搭建个人博客</li><li><input checked="" disabled="" type="checkbox"> 2021/11/02：记录项目从开始到现在的一系列笔记</li></ul><h2 id="项目笔记"><a href="#项目笔记" class="headerlink" title="项目笔记"></a>项目笔记</h2><ol><li><a href="https://hcyety.github.io/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/">ERROR 之部署服务器篇</a></li><li><a href="https://hcyety.github.io/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/">前后端分离项目线上部署</a></li><li><a href="https://hcyety.github.io/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/">项目之登录/注册模块</a></li></ol><h2 id="本文还在持续更新中……"><a href="#本文还在持续更新中……" class="headerlink" title="本文还在持续更新中……"></a>本文还在持续更新中……</h2>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Ts </tag>
            
            <tag> NodeJs </tag>
            
            <tag> TypeORM </tag>
            
            <tag> Koa </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离项目线上部署</title>
      <link href="/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/"/>
      <url>/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>将项目部署至线上，使得任何用户在不同条件下也能够访问。那么首先需要一个服务器，网上有很多教程，能够教会大家如何拥有属于自己的服务器，这里不再赘述。本人购买的是阿里云的linux/CentOs7.7服务器（据说 21 年底，CentOs 官方将不再维护 CentOs8了，大家看看要配哪个系统好吧，博主之前不知情，选了 CentOs8 ，后来因为某种特殊原因决定重换系统，于是降低版本为 CentOs7）。 </li><li>当大家拥有自己的服务器后，就需要配置各种环境以支持项目能够顺利运行，这也是为什么开发者会说“这个项目在我的机器上能跑”的原了，因为“我的机器上有相关配置，你的机器上怎晓得有没有”。网上虽然有相关的资料，但杂多繁乱，本人当初因为配置环境浪费了很多时间，这里贴下 @b站up主CodeSheep 的 pdf ，真是一个很好的配置说明，一条龙服务，很快就能配置大部分必备的环境<blockquote><p>链接：<a href="https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ">https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ</a><br>提取码：h464 </p></blockquote></li></ol><p><strong>下面将会使用基础和进阶的方法部署项目，先说比较麻烦的手动部署流程，毕竟事情要一步一步来，从易到难嘛。</strong></p><h2 id="前端的手动化部署"><a href="#前端的手动化部署" class="headerlink" title="前端的手动化部署"></a>前端的手动化部署</h2><p>这里使用了 webpack ，由于本文重点不在于如何使用 webpack 配置项目，因此不详述，默认诸位看官已经学会相关知识点。</p><ol><li>首先要将本地项目打包成 dist 包，这点通过 webpack 配置可以完成。</li><li>打开 Xshell 工具，在 nginx 已经配合好的前提下，修改 nginx 的配置文件：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 找到【 nginx 的安装目录下的 conf】，修改 conf 下的 nginx.conf 。</span><span class="token comment">// 举例：我的安装路径是 /usr/local/nginx ，所以 vim /usr/local/nginx/conf/nginx.conf</span><span class="token comment">// 进到文件里面后，按 i 可以进入编辑模式修改文件，修改好后按 esc 可以退出编辑模式，然后输入 :wq 保存并退出文件</span><span class="token comment">// 修改配置如下：</span><span class="token comment">// 1. 在第一行加上 user root;</span><span class="token comment">// 2. 找到 server&#123; location / &#123;&#125; &#125;，修改如下</span>server <span class="token punctuation">&#123;</span>  listen       <span class="token number">80</span><span class="token punctuation">;</span>  server_name  localhost<span class="token punctuation">;</span>  #charset koi8<span class="token operator">-</span>r<span class="token punctuation">;</span>  #access_log  logs<span class="token operator">/</span>host<span class="token punctuation">.</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span>  <span class="token comment">// 这里修改</span>  location <span class="token operator">/</span> <span class="token punctuation">&#123;</span>    root   <span class="token punctuation">&#123;</span> nginx 的安装目录<span class="token operator">/</span>html<span class="token operator">/</span>xxx<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// eg. root   /usr/local/nginx/html/dist，dist 为打包后的前端项目;</span>    index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 配置好 nginx.conf 后，保存退出，重启 nginx</span><span class="token comment">// 重启命令为 &#123; nginx 的安装路径/sbin/nginx -s reload &#125;，举例：/usr/local/nginx/sbin/nginx -s reload</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>打开 Xftp 工具，找到 { nginx 的安装路径/html/ }，例如 /usr/local/nginx/html/ ，将 dist 包上传至 html 目录下。访问 ip 地址就可以看到前端项目的静态界面了<blockquote><p>前端项目的部署相对来说简单一些，只要将打包后的文件夹上传到服务器即可（配置好 nginx 的前提下）。下面看下后端项目的部署</p></blockquote><h2 id="后端的手动化部署"><a href="#后端的手动化部署" class="headerlink" title="后端的手动化部署"></a>后端的手动化部署</h2></li><li>配置好 Tomcat ，相关教程看 上文3.2 的 pdf   </li><li>在 Tomcat 的安装目录下新建一个文件夹，用来存放后端项目，这里命名为 myApp 。打开 Xftp 工具，选中要上传的后端文件，拖拽实现上传  </li><li>打开 Xshell 工具，用命令行进入 myApp ，安装项目所需的依赖 <code>npm install</code> 。用 pm2 监控项目，先全局安装 pm2 <code>npm install pm2 -g</code> ，然后用 pm2 启动项目入口文件 <code>pm2 start &#123;入口文件&#125; </code> 。到这里，后端项目的部署也完成啦，咕咕咕~<blockquote><p>到这里，其实本应该能成功启动前后端项目，并能够跑通服务，但绝大多数情况下总是事与愿违的，似乎老天爷不会让事情这么顺利，总要让我们经历一番磨练，所谓“天将降大任于斯人也，必先苦其心志，劳其筋骨是也”，于是总会出现各种奇奇怪怪的 bug 。博主也遇到了，一度很伤脑筋，所以后来终于解决了，博主的上一篇博客：<a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a> 记录了博主遇到的一些困难，说不定与读者相同，可以借鉴参考其解决方法，如果能顺利帮助到大家就再好不过了！</p></blockquote></li></ol><blockquote><p>如果读者已经顺利完成了项目的非自动化部署，相信能够感受到诸多的不便之处，下面博主会为大家介绍自动化部署前后端分离项目的流程，最终的效果便是在本地编辑器的终端运行两次命令：<code>npm run deploy 服务器的主机 服务器的密码</code> ，便能够分别实现前后端分离这两个项目从打包到上传服务器再到启动项目的一条龙服务，希望对大家有所帮助。</p></blockquote><h2 id="前端的自动化部署"><a href="#前端的自动化部署" class="headerlink" title="前端的自动化部署"></a>前端的自动化部署</h2><p>首先我们需要搞清楚前端项目的一系列部署流程，那便是 <strong>打包–登录服务器–上传打包文件</strong> ，那么按照这个思路，我们来具体捋清楚实现过程：</p><ol><li>逻辑思考</li></ol><ul><li>①运行脚本命令；</li><li>②然后脚本读取配置文件（包含服务器host、port、web目录及本地目录等信息）；</li><li>③<strong>打包生成 dist 包</strong> – <code>npm run build</code>；</li><li>④<strong>使用 scp2 连接服务器</strong>；</li><li>⑤<strong>将本地打包的 dist 上传</strong>至 <code>/usr/local/nginx/html/</code> ；</li><li>⑥<strong>获取脚本命令的自定义参数</strong>，这里的参数为服务器主机和密码，并赋值给服务器配置文件（第④点的目的是防止将服务器的主机和密码泄露在项目中）。  </li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack --config webpack&#x2F;webpack.prod.js&quot;, &#x2F;&#x2F;博主这里的配置是这样的，可能跟大家有点出入  &quot;deploy&quot;: &quot;npm run build &amp;&amp; node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 看到上面的 deploy 中的路径，我们可以知道需要在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js ，这个文件是为了使用 scp2 连接服务器，因此里面还放有服务器的一些相关配置。现在开始编写 index.js ：&#x2F;&#x2F; 注：scp2 的官网有相关 API 的使用方法，需要提醒的是文件上传的路径需要特别注意，因为不同的工具，写法不同，最终的效果也是有所差别的，例如有些工具上传文件时如果发现服务器该路径下没有对应文件，会自动生成文件夹，但有些工具却不会；同时，上传的文件路径后面带不带 “&#x2F;” ，也是会有不同的效果的，读者需要稍微留意一下。&#x2F;&#x2F; 1.引入 scp2 ，用于连接服务器const client &#x3D; require(&#39;scp2&#39;);&#x2F;&#x2F; 2.服务器的配置选项const server &#x3D; &#123;  host: &#39;&#39;, &#x2F;&#x2F; ip 地址  port: 22, &#x2F;&#x2F; 端口号  username: &#39;root&#39;, &#x2F;&#x2F; 用户名  password: &#39;&#39;, &#x2F;&#x2F; 密码  path: &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;dist&#39;  &#x2F;&#x2F; 存放项目的路径&#125;&#x2F;&#x2F; 4.用解构赋值获取脚本命令后面的两个参数：主机和密码const [ , , host, password] &#x3D; process.argv;server.host &#x3D; host;server.password &#x3D; password;&#x2F;&#x2F; 3.连接服务器并上传 dist 包到服务器的指定目录 pathclient.scp(&#39;dist&#x2F;&#39;, &#123;  port: server.port,  host: server.host,  username: server.username,  password: server.password,  path: server.path&#125;, function(err) &#123;  if (err) &#123;    console.log(&#39;文件上传失败&#39;, err)  &#125; else &#123;    console.log(&#39;文件上传成功&#39;);  &#125;&#125;)&#x2F;&#x2F; 之后执行【 npm run deploy 服务器主机 服务器密码 】便可实现前端项目的自动化部署了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后端的自动化部署"><a href="#后端的自动化部署" class="headerlink" title="后端的自动化部署"></a>后端的自动化部署</h2>与前端项目的自动化部署一样，我们也需要搞清楚后端项目的一系列部署流程，也就是 <strong>用一个文件夹单独存放需要上传的文件–登录服务器–上传文件–启动项目</strong> ，我们同样来看看具体实现：</li><li>逻辑思考</li></ol><ul><li>①<strong>手动将需要上传的文件复制到一个新建文件夹里，这个文件夹博主命名为 oppService</strong>；</li><li>②运行脚本命令；</li><li>③然后脚本读取配置文件–包含服务器host、port 和 oppService 目录以及 deploy.sh 脚本等信息；</li><li>④<strong>调用 node-ssh API 连接服务器</strong>；</li><li>⑤将 oppService <strong>文件夹上传至服务器指定目录</strong>；</li><li>⑥启动项目的方式博主是在服务器上运行自己编写的 .sh 脚本，里面编写的是项目上传之后服务器要做的后续命令 – 进入服务器上的 oppService 文件夹里以<strong>执行 deploy.sh 脚本</strong>；</li><li>⑦<strong>获取 npm scripts 命令的自定义参数</strong></li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 同样在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;deploy&quot;: &quot;node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js 。开始编写 index.js ：&#x2F;&#x2F; 1.引入 node-ssh 模块 ，准备调用内置 API&#x2F;&#x2F; 这里有个小问题，貌似官方有个 bug 没解决，不能直接 const node_ssh &#x3D; require(&#39;node-ssh&#39;); ，而是得改成下面的形式去导入const node_ssh &#x3D; require(&#39;node-ssh&#39;).NodeSSH;const ssh &#x3D; new node_ssh();&#x2F;&#x2F; 6.用解构赋值获取脚本命令后面的两个参数：主机和密码，并存入 config 中const [ , , host, password] &#x3D; process.argv;&#x2F;&#x2F; 2.服务器的配置选项const config &#x3D; &#123;  path: &#123;    localPath: &#39;oppService&#x2F;&#39;,    romotePath: &#39;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.71&#x2F;Online-programming-platform_service&#39;,  &#125;,  romote: &#123;    host: &#39;&#39;,    port: 22,    username: &#39;root&#39;,    password: &#39;&#39;  &#125;&#125;function uploadFile() &#123;  &#x2F;&#x2F; 3.连接服务器  ssh.connect(config.romote)  .then(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 4.上传 dist 包到服务器的指定目录 path    ssh.putDirectory(config.path.localPath, config.path.romotePath)    .then(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 5.执行脚本，完成文件上传后服务器的后备工作      ssh.execCommand(&#39;sh deploy.sh&#39;, &#123; cwd: config.path.romotePath &#125;)      .then((res) &#x3D;&gt; &#123;        if (!res.stderr) &#123;          process.exit(0);        &#125;      &#125;)    &#125;).catch(err &#x3D;&gt; &#123;      console.log(err)    &#125;)  &#125;).catch(err &#x3D;&gt; &#123;    console.log(&#39;服务器连接失败！！&#39;)  &#125;)&#125;uploadFile();&#x2F;&#x2F; 编写 deploy.sh 脚本#!&#x2F;bin&#x2F;bash# ①先关闭之前的服务，安装依赖之后再重启pm2 stop src&#x2F;app.ts# ②查看文件中是否已经包含 node_modules ，如果有则先删除file&#x3D;&#39;node_modules&#39;if [ -e $file ]; then  rm -rf $file  npm cache clean --forcefi# ③重新安装依赖cnpm install# ④查看8080端口是否被占用，有则 kill ，防止项目无法开启port&#x3D;8080pid&#x3D;$(netstat -nlp | grep :$port | awk &#39;&#123;print $7&#125;&#39; | awk -F&quot;&#x2F;&quot; &#39;&#123; print $1 &#125;&#39;)if [ -n &quot;$pid&quot; ]; then  kill -9 $pid;fi# ⑤重新启动 pm2pm2 start .&#x2F;src&#x2F;app.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>到这里，前后端分离项目的自动化部署就已经结束了，如果有遇到什么 bug ，也可以看看我的上一篇博客 <a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a>，或许能够带来一点点帮助。<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2>这样一来，项目部署的效率瞬间就提上来了，一条命令就搞定一切，但博主觉得，其实还有优化空间，例如后端项目需要事先将要上传的文件抽离出来，那我们每次编写完代码之后都得把文件更新一遍，不是很方便。这个问题就等后续再完善吧，毕竟在部署这里耽误的时间也差不多了(=￣ω￣=)。如果读者觉得有什么好的解决方案或者是其他可以优化的地方，也可以在评论区提出来哩，先谢过诸位啦~<blockquote><p>后续等有空了会回头来完善的哈</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2>从对服务器一窍不通，到掌握线上项目的部署，再到命令行的熟练操作，以及对解决问题能力的锻炼，这些都是博主在完成这个前后端分离项目线上部署带来的好处，毫无疑问收获是颇丰的。但实现的过程却并不轻松，有时候一个 bug 一卡就是两三天（终究还是能力不够吧 T^T），浪费了很多时间，但坚持总会有作用的，至少排查问题的能力或多或少能有所提高，真心希望读者能顺利完成项目的部署，直接通关【妖魔鬼怪（bug）快离开，妖魔鬼怪（bug）快离开】。<blockquote><p>以上 ^_^</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
            <tag> 线上部署 </tag>
            
            <tag> scp2 </tag>
            
            <tag> node-ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR 之部署服务器篇</title>
      <link href="/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/"/>
      <url>/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/</url>
      
        <content type="html"><![CDATA[<ol><li>POST <a href="http://localhost:3000/login">http://localhost:3000/login</a> 404 (Not Found)?</li></ol><p>有多种原因：①前端调用后端接口失败，通常是因为接口的路径匹配错误；②后端没有响应数据给前端；前端接收数据的格式与后端返回数据的格式不相符。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_44163269/article/details/105442612">vue项目 前端 POST(GET) http://127.0.0.1xxx 404(Not Found)错误 （多种误区解决）</a></p></blockquote><ol start="2"><li>在服务器运行<code>npm run dev</code>报错：SyntaxError: Cannot use import statement outside a module？  </li></ol><p>这提示一般是node下无法使用import。</p><blockquote><p><a href="https://blog.csdn.net/weixin_43094085/article/details/114832738">解决方法参考这篇文章</a></p></blockquote><ol start="3"><li>在服务器上启动 NodeJs+ts 项目时报错之一：TS错误:⨯无法编译TypeScript(Error: TSError: ⨯ Unable to compile TypeScript)</li></ol><p>解决：从 package.json 中删除 ts-node 和 typescript 。然后：</p><pre class="line-numbers language-none"><code class="language-none">npm install ts-node --save-devnpm install typescript -g npm install typescript --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在服务器上启动 NodeJs + Ts 项目时报错之二：Can’t run my Node.js Typescript project TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension “.ts” for /app/src/App.ts</li></ol><p>情况说明：博主启动项目的命令是 <code>npm start</code> ，项目 <code>package.json</code> 文件中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node src/app.ts</code> 。不幸的是，由于项目中既有 ES6 模块又有 CommonJS 模块，因此不能按照网上的教程只在 <code>package.json</code> 中添加 <code>&quot;type&quot;: &quot;module</code> 或者 只在 <code>tsconfig.json</code> 中添加 <code>&quot;type&quot;: &quot;CommonJS&quot;</code> ，因为如果这样的话，项目运行后还是会报如下的错误：</p><pre class="line-numbers language-none"><code class="language-none">import Koa from &#39;koa&#39;;^^^^^^SyntaxError: Cannot use import statement outside a module<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：修改 <code>package.json</code> 中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node --experimental-modules --loader ts-node/esm &#123; 项目入口文件 &#125;</code> </p><ol start="5"><li>服务器用 pm2 启动项目失败：Error: Cannot find module ‘/Users/wyb/.nvm/versions/io.js/v3.0.0/lib/node_modules/pm2/lib/ProcessContainerFork.js’</li></ol><p>情况说明：笔者的服务器确定是有安装了 pm2 的，使用 <code>pm2 -v</code> 也可以正常查询到版本号。然而此前 NodeJs 因为我误操作卸载重装了，虽然 pm2 也重新安装了一遍，但根目录下残留的文件路径指向的是以前的 pm2 ，因此只要将根目录下的 pm2 删除即可。</p><p>解决：<code>rm -rf ~/.pm2</code>  </p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/36690442/error-cannot-find-module-users-wyb-nvm-versions-io-js-v3-0-0-lib-node-module">overflow 回答</a></p></blockquote><ol start="6"><li>启动 pm2 报错：Process or Namespace ./src/app not found<pre class="line-numbers language-none"><code class="language-none">[PM2][ERROR] Process or Namespace .&#x2F;src&#x2F;app.ts not found[PM2][ERROR] Interpreter &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node is NOT AVAILABLE in PATH. (type &#39;which &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node&#39; to double check.)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>排查流程：正常下，可以先 <code>pm2 -v</code> 查看是否已经安装 pm2 ，如果不能显示版本信息，有两种情况，一种是没有安装，那么运行 <code>npm install pm2 -g</code> ；如果确定安装过了，则可以试试建立软链接：<code>ln -s &#123; 安装 pm2 的绝对路径 &#125; /usr/local/bin/</code> 。如果还不能解决，就再往下看看。</li></ol><p>先看第二个报错，情况①博主的服务器安装了宝塔面板，并在面板里安装了 pm2 管理器，导致与服务器的 pm2 冲突。于是把宝塔面板中的 pm2 管理器卸载，就没有这个报错了。②用 xshell 工具执行这条命令：<code>pm2 start src/app.ts --interpreter ./node_modules/.bin/ts-node</code> 即可。</p><ol start="7"><li><p>将项目中的脚本上传至服务器并执行时报错：npm: command not found？</p><pre class="line-numbers language-none"><code class="language-none">deploy.sh: line 2: npm: command not found&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据网上的解决方法，正解本来应该是 用绝对路径设置软链 ，但博主的情况很特殊，是由于 /usr/bin/env 命令被修改，导致找不到 node ，这也是在我多方尝试无果之后向阿里提交工单，大佬给出的回复。<br>大佬的解决方法便是从版本相同的主机 copy 一份 /usr/bin/env 命令到我本机上，这才恢复正常。</p><blockquote><p>注：在服务器上的操作大家一定要慎重，误删文件可能会导致各种很难解决的 bug ，这已经是我第二次遇到特殊情况了。</p></blockquote></li><li><p>端口被占用？</p></li></ol><ul><li>查看端口使用情况：<code>netstat -ntlp</code></li><li>杀掉进程：<code>kill （对应端口的PID）</code><blockquote><p>参考资料：<a href="http://blog.csdn.net/ljfphp/article/details/78666376">【转】linux下杀死进程（kill）的N种方法</a></p></blockquote></li></ul><ol start="9"><li>无法访问阿里云ip地址？</li></ol><p>解决方法：<a href="https://www.cnblogs.com/ghzjm/p/10677599.html">linux服务器安装nginx及使用</a></p><blockquote><p>排查1：<a href="https://blog.csdn.net/sinat_25957705/article/details/80641077">阿里云服务器 nginx公网IP无法访问浏览器</a><br>排查2：<a href="https://blog.csdn.net/Adime_J/article/details/109155234">linux服务器部署完成之后访问不到—–总结篇</a></p></blockquote><blockquote><ol><li>ping ip成功只能说明主机可以到达，端口还是有可能不可到达的。端口不可到达可能是由于HTTP 服务器未启动或者监听在其他端口入8080上了；还有一个可能是防火墙没开放80端口的访问权限。</li></ol></blockquote><blockquote><p>排查过程中遇到的问题：</p><ol><li>curl: (7) Failed to connect to 120.79.193.126 port 80: Connection refused<br><a href="https://www.cnblogs.com/jukaiit/p/8994448.html">Xshell 链接 Could not connect to ‘192.168.80.129’ (port 22): Connection failed</a><br>在Linux6中查看及设置开机自启信息是使用chkconfig命令，Linux7中此命令已经被替代。虽然Linux7中已经不再使用chkconfig命令来管理服务是否开机自启，但是此命令仍旧可用，但是输出信息提示我们使用chkconfig命令的输出只是呗SysV所管理的服务，不包括systemd管理的服务，所以如果想在CentOS7中查看systemd管理的服务需要使用以下命令：<a href="https://blog.csdn.net/qq_38295166/article/details/79828482">CentOS 7设置ssh服务自动启动</a></li></ol></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_38705903/article/details/101911553">或许有用？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Begin: myfist blog</title>
      <link href="/2021/10/31/begin-myfist-blog/"/>
      <url>/2021/10/31/begin-myfist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做 React-Ts 项目，两个月了，有了这个项目该有的雏形。就在昨天，我实现好了项目 40% 的功能，心里放松了一下，突然觉得有点累了，不是说真的那种累，而是因为 我从这个项目本身学到了很多东西，不仅有知识点的深入理解，还有处理问题的能力、思维逻辑的锻炼等等，得到的好处很多，此前一直投身于项目功能点的实现，还没机会消化，突然松了口气，顿觉身上积攒了很多东西，我觉得是时候该静下心来，沉淀我这两个月来所学到的东西，于是我着手搭建个人博客，准备记录自己的所学所感……</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>大二在读生一枚，我喜欢前端世界，对于前端技术我怀有十分的兴趣，网络上所见到的各种好看、奇特的效果，一想到都是通过代码实现的，我就觉得十分神奇，我之前认为，代码和那些好看的特效是不沾边的东西，没想到那些是用我不知道的方式实现的。对于前端技术的原理，我也感觉十分神奇，让我知道了代码世界里想当然是不对的，如果这样便往往会犯错。当然，后端的世界也不赖，虽然不像前端那样可视化，但有时对数据的处理能够返回预期效果，成就感也十足。这样，我想成为一名前端工程师，努力的话，争取全栈。</p><p>电脑是我日常生活中不能缺少的一件必需品，但生活不能只有电脑，我也喜欢打羽毛球、乒乓球、游泳、聚会（仅限于我在意的人），诗和远方亦是我向往的生活。但我知道心中虽有所往，但那不是想有就有的，诗和远方 都挺贵，目前我所能做的，便是提升我的硬实力，总得拿到长途旅行的门票吧^_^</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>用了一天时间搭建了个人博客，是我喜欢的主题，既然有这么方便好看的工具为我们铺好了红毯，我难道不应该兢兢业业地写好文章、做好博客吗（<em>^▽^</em>）</p><p>我决定先把项目放一边，一个星期，就一个星期，我得总结归纳，好好沉淀一下，学到的 很多很快，如果不及时记录，估计又得还回去了，所谓好记性不如烂笔头，这句话既然能成为谚语，肯定是有它的过人之处的 (￣ェ￣;)。一个星期过后，我再重新扬帆起航吧，再花一个半月左右的时间，应该能把这个项目完全搞定，总计三个半月，应该还可以接受吧（好吧，我觉得有点久了，争取三个月搞定）。那么这一个星期，我就要从头回顾一下我的项目了，这个过程说不定还可以解决掉历史残留问题，总之，要加油了！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上文有说到，搭建个人博客的初衷是沉淀所学所感，因此我对这个博客的定义首先是一个技术博客，我希望它能成为一个有含金量的技术文章存放地；其次是我本人的心灵树洞，我也期望它能成为我倾诉心声的所在，毕竟我是一个有时不太爱说话的人…..</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
