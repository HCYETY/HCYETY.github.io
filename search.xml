<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>tell it to myself</title>
      <link href="/2021/11/08/tell-it-to-myself/"/>
      <url>/2021/11/08/tell-it-to-myself/</url>
      
        <content type="html"><![CDATA[<h2 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h2><p>实习项目从开始做到现在已经过去 10 个星期了，前 9 个星期一直在努力实现各种模块各种功能点，直到上个星期才开始准备记笔记（也就因此搭建了个人博客），搭了一两天后博客已经运行起来，然后开始写博客的期间又断断续续更新了一部分主题配置，一个星期也就过去 2/3 了，这个时候我其实有点沉不住气了，因为想着快点弄完这些鸡毛蒜皮的事才好去接着开发项目的其他功能，于是耐着性子修复了项目一小部分的 bug 后（此时就已经发现的 bug 还有挺多的，但我没有心情全部修复），终于在周末的时候向 @Dangosky 交任务了，在这次聊天中我认识到了一个基本但极为重要的事情……</p><h2 id="重点敲黑板"><a href="#重点敲黑板" class="headerlink" title="重点敲黑板"></a>重点敲黑板</h2><p>Dangosky 跟我说，<strong>做项目追求速度而不注重质量，这样的项目做出来是没有什么用处的</strong>。</p><p>这样说是有道理的，他说：</p><ul><li>初学者做项目最忌讳冒进，贪多嚼不烂</li><li>首先要明确一点，做项目第一目标是从中学习东西，第二目标是有个项目经历之后才好些简历</li><li>同一个项目，即使你一个月搞出来了，但很多 bug ，很多设计问题、很多 bad case 没考虑到，面试官一问，什么都没想到、很多都答不出来，这样的项目做得再快也没用的</li><li>相反，你一个项目即使做上半年，但你做得很有质量，很多方面都考虑到了，甚至还思考到了项目可以拓展的地方（比如实现国际化语言等等），面试官一问你这个项目有什么亮点或不足，你能够头头是道，让你讲个二十分钟你都讲不完，这两种情况是完全不一样的</li></ul><p>我就属于注重速度那一类，没有沉住气来着重项目质量，以及完全吸收从项目中学习到的东西，反而总是想着要搞快点搞快点，抓紧时间把项目给搞出来，以至于忽略了做这个项目的初心。但现在我明白了，做这个项目最重要的应该是从中学习到新知识、新技术等，把自己的项目经历丰富起来，不应该倾向于开发速度。</p><p>同时，在做项目的过程中，bug 是必不可少的，<strong>解决 bug 也是一种提升实力的方式</strong>。<br>Dangosky 说：</p><ul><li>初学阶段，卡 bug 本身就是一种学习了</li><li>只是这种学习方式很难受，因为一直卡在那个地方解决不了，难免心态不好自我怀疑，比不上你敲代码实现一个新功能来的有成就感</li><li>但卡 bug 是每个人学习的必经之路，是躲不掉的。在工作之后，一个团队中也会有几个人一直是在修 bug ，摆正心态、明确目标就好了</li></ul><p>就我亲身经历而言，一开始做项目的时候，我会卡在一个地方不知道怎么办，那种感觉就像无头苍蝇一样，面对代码无从下手，要么是不知道从哪里排查问题，要么排查的方向有误，导致浪费了很多的时间。但渐渐的，我掌握一些技巧和方法了，知道一个报错该去什么地方解决，之后很多问题根据差不多的思路也可以很快找到对应的解决方法。这些都是在解决 bug 之后积累出来的经验，所以对于 <strong>卡 bug 本身就是一种学习</strong> 这句话，我是举双手双脚赞成的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>知道了自己“右倾”、心态不对劲之后，接下来我要做的便是摆正好心态、明确自己的目标了，心中有量尺，之后做的事就会有分寸。</p><blockquote><p>以此篇记录我在做项目过程中遇到的思想误区，告诫自己以后莫要再犯同样的错误了！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目之登录/注册模块</title>
      <link href="/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/"/>
      <url>/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客：<a href="https://hcyety.github.io/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/">React-Ts 项目：在线编程笔试平台</a> 有说到，这个项目是前后端分离项目，也就是说，其实该项目相当于两个项目，分别专注前端和后端，如果要上传到 <code>github</code> ，那么就需要创建两个仓库来分别放置。博主已经将源码 push ，读者可以跳转查阅：<a href="https://github.com/HCYETY/Online-programming-platform">前端项目仓库</a> — <a href="https://github.com/HCYETY/Online-programming-platform_service">后端项目仓库</a></p><p>前端项目采用的技术栈是 <code>React</code> 。UI 的设计是上下布局，即头部导航栏、下面主体内容，其中使用了 antd4 的 <code>Card</code> 和 <code>Form</code> 组件，效果如图所示：<img src="https://z3.ax1x.com/2021/11/02/IkyIBQ.png" alt="登录"><img src="https://z3.ax1x.com/2021/11/02/Ik63gf.png" alt="注册"></p><blockquote><p>本来想实现的效果是翻转卡片，即点击“登录”或“注册”就能将卡片翻转，同时“登录”面带有标签，可以切换登录方式：邮箱登录和账号登录，但奈何一直找不到合适的解决方法，就使用了 antd 的 <strong>带标签页的卡片</strong>，如果读者知道如何解决这一问题，还望不吝赐教 ^_^</p></blockquote><p>后端项目采用的技术栈是 <code>NodeJs</code> ，使用的数据库是 <code>MYSQL</code> 。项目中运用了 <code>Koa</code> 和 <code>TypeORM</code> 框架来搭建 <code>Node</code> 服务和操作  <code>MYSQL</code> 数据库。</p><blockquote><p>项目所使用的技术栈读者已经清楚，我们继续往下看吧~~</p></blockquote><h2 id="注册模块（支持邮箱注册）"><a href="#注册模块（支持邮箱注册）" class="headerlink" title="注册模块（支持邮箱注册）"></a>注册模块（支持邮箱注册）</h2><h3 id="code-前思考"><a href="#code-前思考" class="headerlink" title="code 前思考"></a>code 前思考</h3><p>首先我们需要理清注册的逻辑，联想我们在一个网站上注册时，操作流程是怎么样的。我们可以很快知道，通常有两种方式，一种是手机号注册，一种是邮箱注册。</p><ol><li><p>手机号注册<br><img src="https://z3.ax1x.com/2021/11/03/IAj9Rx.jpg" alt="常见手机注册"></p></li><li><p>邮箱注册<br><img src="https://z3.ax1x.com/2021/11/03/IAXWqg.jpg" alt="常见邮箱注册"></p></li></ol><blockquote><p>注册的方式有很多种，除了手机邮箱注册，还有用户名/xx号注册、第三方注册等，具体想选择哪种方式实现注册，读者可以自行选择，下面我们还需要来看看如何实现前后端的连接，以跑通整个项目。</p></blockquote><blockquote><p>情况说明：博主选择的方式是邮箱注册。</p></blockquote><h3 id="逻辑思考"><a href="#逻辑思考" class="headerlink" title="逻辑思考"></a>逻辑思考</h3><ol><li>用户在前端界面填写表单信息，点击“获取验证码”按钮后，会【发送请求】给后端</li><li>后端【接收前端传来的请求】后，会随机生成一个包含大小写字母和数字的 6 位数验证码，并将该验证码存储在数据库中，同时【响应数据】（这里指验证码）给前端。</li><li>前端【接收后端响应体】（这里指后端传过来的验证码）后，必须填入表单中才能提交（表单组件可以在 rule 里设定 required ）。</li><li>点击“提交”后，这时前端发送的请求体中包含了表单中的所有数据，同样将其发送给后端。后端获取请求体中的所有信息，根据邮箱账号从数据库中查询是否已经存储了该用户，若查找不到则说明无人使用该邮箱注册过，可以允许注册，将邮箱和密码等相关信息一并存进数据库中；否则直接响应数据，告知前端该用户已经注册。前端根据后端响应的信息进行对应的操作，如注册成功，可以跳转到登录页面进行登录，否则弹出警告，告知用户注册信息填写有误。</li></ol><blockquote><p>说到这里，读者应该懂得了将前后端项目串联起来的一系列逻辑，概括起来便是前端调用后端接口【发送请求】，后端设定接口给前端调用【接收请求】，这样一来前后端便可以互连跑通服务了。</p></blockquote><blockquote><p>但问题来了，“你说了这么多，我还是不知道该怎么在前端调用后端接口，后端又如何接收到前端传来的请求”？别急，博主只是先抛砖引玉，先给大家捋顺跑通前后端服务的逻辑，心里好有个底。下面我们继续往下</p></blockquote><ol start="5"><li>前端发送请求的方式有多种，如 fetch、axios 等，这里使用的是 axios ，下面自定义封装的 axios 函数，仅供大家参考：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录下/src/api/index.ts</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span><span class="token comment">// 注意这个路径，http://localhost:8080 是后端服务的地址，/api 是请求的固定格式，后面调用该函数的时候还会再传入一个参数 /xxx ，因此后端要想接收前端请求，就必须配置接口路径成 前端服务的地址/api/xxx ，这样前后端项目才能跑通【不理解的话后面代码还会有注释】</span><span class="token keyword">const</span> <span class="token constant">REQUESTIP</span><span class="token operator">:</span> string <span class="token operator">=</span> <span class="token string">"http://localhost:8080/api"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span>method<span class="token operator">:</span> <span class="token string">'get'</span> <span class="token operator">|</span> <span class="token string">'post'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">url<span class="token operator">:</span> string<span class="token punctuation">,</span> params<span class="token operator">?</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> data <span class="token operator">=</span> method <span class="token operator">===</span> <span class="token string">'get'</span> <span class="token operator">?</span> <span class="token punctuation">&#123;</span>      params    <span class="token punctuation">&#125;</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      data<span class="token operator">:</span> params    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 调用函数时会传入 url （相当于上面说的xxx），在这里进行拼接，就成了前端调用后端接口的完整 url 了：后端服务地址/api/xxx</span>    url <span class="token operator">=</span> <span class="token constant">REQUESTIP</span> <span class="token operator">+</span> url<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        url<span class="token punctuation">,</span>        method<span class="token punctuation">,</span>        <span class="token operator">...</span>data<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">const</span> get <span class="token operator">=</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> post <span class="token operator">=</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span><span class="token string">'post'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>调用 axios 封装函数的时候：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录/src/api/modules/interface.ts</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> post <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'根目录/src/api/index'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testRegister</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token operator">:</span> <span class="token punctuation">&#123;</span> email<span class="token operator">:</span> string<span class="token punctuation">;</span> cypher<span class="token operator">:</span> string<span class="token punctuation">;</span> captcha<span class="token operator">:</span> string<span class="token punctuation">;</span> identity<span class="token operator">:</span> number<span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 此时前端请求的整个路径为 http://localhost:8080/api/register，那么假设前端项目地址为 http://localhost:3000 ，后端就需要定义接口路径为 http://localhost:3000/api/register</span>  <span class="token keyword">return</span> <span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/register'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 文件结构：根目录/src/pages/login/index.tsx</span><span class="token comment">// 这里结构其实不是很好，因为注册和登录是写在一块的，没有分开来。读者清楚是在注册事件下发送 axios 请求的就好</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> testRegister <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'根目录/src/api/modules/interface'</span><span class="token punctuation">;</span>  <span class="token comment">// 点击“注册”按钮触发的函数：</span><span class="token function-variable function">submitRegister</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">values<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 表单的值</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> account<span class="token punctuation">,</span> password<span class="token punctuation">,</span> identity<span class="token punctuation">,</span> email<span class="token punctuation">,</span> cypher<span class="token punctuation">,</span> captcha <span class="token punctuation">&#125;</span> <span class="token operator">=</span> values<span class="token punctuation">;</span>  <span class="token comment">// 请求参数</span>  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> email<span class="token punctuation">,</span> cypher<span class="token punctuation">,</span> captcha<span class="token punctuation">,</span> identity <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// ！发送请求并获取返回值</span>  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">testRegister</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注册成功</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在当前页跳转至登录界面</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> noTitleKey<span class="token operator">:</span> <span class="token string">'login'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    message<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>然后是在后端定义接口。博主的后端项目使用了 <code>Koa</code> 框架，因此可以调用它的 API :</li></ol><blockquote><p>注意：如果是本地项目要解决跨域，Koa 可以使用 koa2-cors 直接解决；但如果是线上项目的话，还需要另外的配置，网上有多种处理跨域的解决方法，博主采用的方法是配置 nginx 反向代理，具体操作可以跳转到另一篇博客：<a href="https://hcyety.github.io/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/">前后端分离项目线上部署</a>，里面有配置 nginx 的具体步骤，在这里不加叙述。</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 下面 code 仅供参考，大致是这么一个模式</span><span class="token keyword">import</span> Koa <span class="token keyword">from</span> <span class="token string">'koa'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'koa-router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> bodyParser <span class="token keyword">from</span> <span class="token string">'koa-bodyparser'</span><span class="token punctuation">;</span>        <span class="token comment">// 处理 post 请求，有了这个插件才能获取 post 参数【通常前端的请求方式是 post 】</span><span class="token keyword">import</span> cors <span class="token keyword">from</span> <span class="token string">'koa2-cors'</span><span class="token punctuation">;</span> <span class="token comment">// 处理跨域问题</span><span class="token keyword">import</span> register <span class="token keyword">from</span> <span class="token string">'./middleware/register'</span><span class="token punctuation">;</span>   <span class="token comment">// 导入注册的 .ts 文件，用于处理注册事件【通常不放在入口文件里，而是单独抽出来】</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cors</span><span class="token punctuation">(</span>corsOptions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 处理 post 请求的参数。</span><span class="token comment">// 注意这个插件的位置，必须要放在匹配接口之前！！！</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">bodyParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 匹配接口，这里的路径和前端请求路径中端口号后面那部分是保持一致的</span>router<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/api/register'</span><span class="token punctuation">,</span> register<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 组装匹配好的路由，返回一个合并好的中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里启动的后端服务是 8080 端口</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'网站服务器启动成功，请访问 http://localhost:8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>说一句：定义好了后端接口，可以查阅 <a href="https://cloud.tencent.com/developer/article/1876810">postman 使用教程</a>，在 <a href="https://www.postman.com/downloads/">postman 官网</a> 下载 <code>postman</code> ，方便测试接口是否被成功调用，推荐使用！</p></blockquote><h2 id="登录模块（支持邮箱登录）"><a href="#登录模块（支持邮箱登录）" class="headerlink" title="登录模块（支持邮箱登录）"></a>登录模块（支持邮箱登录）</h2><ol><li>跑通前后端服务的逻辑同注册一致，也是【前端发送请求】–【后端接收请求】–【后端响应请求】 –【前端接收响应】 </li></ol><blockquote><p>然而这样简单地实现登录功能，用户是可能通过控制台篡改后端的响应数据的，进而实现登录跳转，这里采用后端 session 身份验证进行防范。同时前端需实现登录拦截，防止用户未经登录便通过 url 跳过登录验证。</p></blockquote><ol start="2"><li>所谓 session 身份验证，打个比方就是“你第一次来的时候我发给你一张身份证，但只是一张写着身份证号码的纸片。以后你每次来办事，我根据这张身份证去后台查一下你的 id 是不是有效”。  </li></ol><p>对应到登录功能，就是每次用户登录的时候，后端获取到用户邮箱，根据这个邮箱查找数据库中存储的该用户的信息，若查找不到说明该用户未注册；若查找得到则说明该用户已注册成功，可以往下匹配密码，若密码错误，则不能登录，也就不用“发放身份证”了；若密码正确，则“可以发放带有身份证号码的身份证”–生成 session 并存进 cookie 中响应给前端。这样用户就算篡改后端响应数据，要登录的时候 session 还是会发生更改，不会与用户篡改后的数据相匹配；同时如果用户在未登录的状态下更改 url ，也会触发登录拦截，后端会验证登录状态。</p><blockquote><p>这个 session 是一个长度为 20 左右的包含数字和大小写字母的 session 随机数，将这个随机数①存进该用户的信息中，以便在维护登录状态时可以根据用户账号获取；②生成一个 cookie ，将 session 存进该 cookie 中。  </p><p>那么问题又来了，session 可以通过 JS 函数 return 一个值得到，但这个 cookie 该如何生成？ session 又如何存进 cookie 中？</p></blockquote><p>在 Koa 中，这两个问题可以一并解决：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录/src/middleware/login.ts</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token operator">:</span>Context</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// generateMixed() 是封装的 JS 函数，用于生成随机数</span>  <span class="token keyword">const</span> session <span class="token operator">=</span> <span class="token function">generateMixed</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置 cookie </span>  ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>    <span class="token string">'session'</span><span class="token punctuation">,</span> session<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> httpOnly<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> maxAge<span class="token operator">:</span> <span class="token number">3600000</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在前端封装 axios 函数的地方加上配置 <code>axios.defaults.withCredentials = true;</code> 之后，就会在前端每次向后端请求数据时，请求头中自动带上 cookie ，后端便可以获取到这个 cookie 对用户身份进行验证：如果与数据库中该用户的 session 一致，则说明用户处于登录状态，否则用户未登录。可以设一个字段标识登录状态，返回给前端，以便前端判断用户是否登录成功。</p><ol start="3"><li>前端在路由页面发送登录请求（参数为 cookie ），如果后端接收到了 cookie ，并在数据库中找到 session 为 cookie 的用户信息，说明用户处于登录状态，否则处于未登录状态。对于未登录的用户，重定向到登录页面即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
            <tag> 注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Ts 项目：在线编程笔试平台</title>
      <link href="/2021/11/02/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/"/>
      <url>/2021/11/02/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客说到线上部署项目到服务器，博主说的就是这个 React-Ts 项目啦，它是博主为将来找实习准备的，用到的技术点有好一些是边学边做的，如果有不同见解的地方还请读者不吝赐教。</p><blockquote><p>需要事先说明的是，关于这个项目的博客，博主并不打算讲解代码实现，每个人的项目用到的技术栈不尽相同，但有一点可以确定，就是项目功能点的实现逻辑是大致相同的，故博主会更多地讲解各模块/功能点的逻辑实现 ^_^</p></blockquote><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>该项目是一个在线编程笔试平台。<br>主要功能是面试官①编辑（可新增、修改、删除）试卷和试题【一张试卷有多道试题】；②查看候选人编程结果并给予评分和备注等信息。候选人①在线完成代码编写并提交；②根据面试官设定的查看权限，决定能否查看已提交或已结束的试题。<br>该项目包含了前端和后端两种技术栈，前端采用的是 React ，后端采用的是 NodeJs ，整个项目为前后端分离项目。</p><h2 id="项目任务拆解"><a href="#项目任务拆解" class="headerlink" title="项目任务拆解"></a>项目任务拆解</h2><ol><li>登录/注册模块</li></ol><ul><li>支持邮箱登录和注册</li><li>支持退出登录</li></ul><ol start="2"><li>面试题模块</li></ol><ul><li>面试官可填写试卷和面试题</li><li>支持新建、修改、删除试卷和面试题目</li><li>支持邀请多个候选人编程</li><li>面试题目支持富文本格式</li></ul><ol start="3"><li>在线编程模块</li></ol><ul><li>候选人可在线编写代码</li><li>代码支持多种语言高亮</li><li>候选人侧可提交最终编程代码</li><li>面试官侧刷新能看到最终代码</li></ul><ol start="4"><li>在线留言模块</li></ol><ul><li>候选人可以通过文字给面试官留言</li><li>面试官可以回复</li><li>留言内容长期保存</li><li>留言模块自动刷新</li></ul><ol start="5"><li>在线编程模块支持自动刷新</li></ol><ul><li>候选人侧代码支持自动保存</li><li>面试官侧代码自动刷新</li></ul><ol start="6"><li>在线留言模块改成实时文字聊天</li></ol><ul><li>候选人和面试官可实时文字聊天</li><li>其他获得链接的人都可参与文字聊天</li></ul><ol start="7"><li>在线语音聊天模块</li></ol><ul><li>候选人和面试官可实时语音聊天</li></ul><ol start="8"><li>在线编程模块支持运行JS代码</li></ol><ul><li>候选人和面试官可在线运行 JS 代码并查看输出</li></ul><ol start="9"><li> 在线编程模块支持协同编辑</li></ol><ul><li>候选人和面试官可实时协作编程<h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2></li><li><input checked="" disabled="" type="checkbox"> 2021/09/04：实现登录/注册的静态页面</li><li><input checked="" disabled="" type="checkbox"> 2021/09/19：实现登录/注册逻辑（包括账号密码登录、登录拦截，session 身份验证）</li><li><input checked="" disabled="" type="checkbox"> 2021/09/29：初步部署前后端项目到阿里云服务器</li><li><input checked="" disabled="" type="checkbox"> 2021/10/04：购买域名并实现自动化部署项目</li><li><input checked="" disabled="" type="checkbox"> 2021/10/05：支持使用邮箱 登录和注册（删除了账号密码登录、注册的方式）</li><li><input checked="" disabled="" type="checkbox"> 2021/10/09：支持新建/删除试卷，在“新建试卷”里新建/修改/删除试题，发送邮件至候选人邮箱</li><li><input checked="" disabled="" type="checkbox"> 2021/10/23：初步完成面试题模块（包含“修改试卷”）</li><li><input checked="" disabled="" type="checkbox"> 2021/10/30：初步完成在线编程模块</li><li><input checked="" disabled="" type="checkbox"> 2021/10/31：搭建个人博客</li><li><input checked="" disabled="" type="checkbox"> 2021/11/02：记录项目从开始到现在的一系列笔记</li></ul><h2 id="项目笔记"><a href="#项目笔记" class="headerlink" title="项目笔记"></a>项目笔记</h2><ol><li><a href="https://hcyety.github.io/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/">ERROR 之部署服务器篇</a></li><li><a href="https://hcyety.github.io/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/">前后端分离项目线上部署</a></li><li><a href="https://hcyety.github.io/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/">项目之登录/注册模块</a></li></ol><h2 id="本文还在持续更新中……"><a href="#本文还在持续更新中……" class="headerlink" title="本文还在持续更新中……"></a>本文还在持续更新中……</h2><p>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</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Ts </tag>
            
            <tag> NodeJs </tag>
            
            <tag> TypeORM </tag>
            
            <tag> Koa </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离项目线上部署</title>
      <link href="/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/"/>
      <url>/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>将项目部署至线上，使得任何用户在不同条件下也能够访问。那么首先需要一个服务器，网上有很多教程，能够教会大家如何拥有属于自己的服务器，这里不再赘述。本人购买的是阿里云的linux/CentOs7.7服务器（据说 21 年底，CentOs 官方将不再维护 CentOs8了，大家看看要配哪个系统好吧，博主之前不知情，选了 CentOs8 ，后来因为某种特殊原因决定重换系统，于是降低版本为 CentOs7）。 </li><li>当大家拥有自己的服务器后，就需要配置各种环境以支持项目能够顺利运行，这也是为什么开发者会说“这个项目在我的机器上能跑”的原了，因为“我的机器上有相关配置，你的机器上怎晓得有没有”。网上虽然有相关的资料，但杂多繁乱，本人当初因为配置环境浪费了很多时间，这里贴下 @b站up主CodeSheep 的 pdf ，真是一个很好的配置说明，一条龙服务，很快就能配置大部分必备的环境<blockquote><p>链接：<a href="https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ">https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ</a><br>提取码：h464 </p></blockquote></li></ol><p><strong>下面将会使用基础和进阶的方法部署项目，先说比较麻烦的手动部署流程，毕竟事情要一步一步来，从易到难嘛。</strong></p><h2 id="前端的手动化部署"><a href="#前端的手动化部署" class="headerlink" title="前端的手动化部署"></a>前端的手动化部署</h2><p>这里使用了 webpack ，由于本文重点不在于如何使用 webpack 配置项目，因此不详述，默认诸位看官已经学会相关知识点。</p><ol><li>首先要将本地项目打包成 dist 包，这点通过 webpack 配置可以完成。</li><li>打开 Xshell 工具，在 nginx 已经配合好的前提下，修改 nginx 的配置文件：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 找到【 nginx 的安装目录下的 conf】，修改 conf 下的 nginx.conf 。</span><span class="token comment">// 举例：我的安装路径是 /usr/local/nginx ，所以 vim /usr/local/nginx/conf/nginx.conf</span><span class="token comment">// 进到文件里面后，按 i 可以进入编辑模式修改文件，修改好后按 esc 可以退出编辑模式，然后输入 :wq 保存并退出文件</span><span class="token comment">// 修改配置如下：</span><span class="token comment">// 1. 在第一行加上 user root;</span><span class="token comment">// 2. 找到 server&#123; location / &#123;&#125; &#125;，修改如下</span>server <span class="token punctuation">&#123;</span>  listen       <span class="token number">80</span><span class="token punctuation">;</span>  server_name  localhost<span class="token punctuation">;</span>  #charset koi8<span class="token operator">-</span>r<span class="token punctuation">;</span>  #access_log  logs<span class="token operator">/</span>host<span class="token punctuation">.</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span>  <span class="token comment">// 这里修改</span>  location <span class="token operator">/</span> <span class="token punctuation">&#123;</span>    root   <span class="token punctuation">&#123;</span> nginx 的安装目录<span class="token operator">/</span>html<span class="token operator">/</span>xxx<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// eg. root   /usr/local/nginx/html/dist，dist 为打包后的前端项目;</span>    index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 配置好 nginx.conf 后，保存退出，重启 nginx</span><span class="token comment">// 重启命令为 &#123; nginx 的安装路径/sbin/nginx -s reload &#125;，举例：/usr/local/nginx/sbin/nginx -s reload</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>打开 Xftp 工具，找到 { nginx 的安装路径/html/ }，例如 /usr/local/nginx/html/ ，将 dist 包上传至 html 目录下。访问 ip 地址就可以看到前端项目的静态界面了<blockquote><p>前端项目的部署相对来说简单一些，只要将打包后的文件夹上传到服务器即可（配置好 nginx 的前提下）。下面看下后端项目的部署</p></blockquote><h2 id="后端的手动化部署"><a href="#后端的手动化部署" class="headerlink" title="后端的手动化部署"></a>后端的手动化部署</h2></li><li>配置好 Tomcat ，相关教程看 上文3.2 的 pdf   </li><li>在 Tomcat 的安装目录下新建一个文件夹，用来存放后端项目，这里命名为 myApp 。打开 Xftp 工具，选中要上传的后端文件，拖拽实现上传  </li><li>打开 Xshell 工具，用命令行进入 myApp ，安装项目所需的依赖 <code>npm install</code> 。用 pm2 监控项目，先全局安装 pm2 <code>npm install pm2 -g</code> ，然后用 pm2 启动项目入口文件 <code>pm2 start &#123;入口文件&#125; </code> 。到这里，后端项目的部署也完成啦，咕咕咕~<blockquote><p>到这里，其实本应该能成功启动前后端项目，并能够跑通服务，但绝大多数情况下总是事与愿违的，似乎老天爷不会让事情这么顺利，总要让我们经历一番磨练，所谓“天将降大任于斯人也，必先苦其心志，劳其筋骨是也”，于是总会出现各种奇奇怪怪的 bug 。博主也遇到了，一度很伤脑筋，所以后来终于解决了，博主的上一篇博客：<a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a> 记录了博主遇到的一些困难，说不定与读者相同，可以借鉴参考其解决方法，如果能顺利帮助到大家就再好不过了！</p></blockquote></li></ol><blockquote><p>如果读者已经顺利完成了项目的非自动化部署，相信能够感受到诸多的不便之处，下面博主会为大家介绍自动化部署前后端分离项目的流程，最终的效果便是在本地编辑器的终端运行两次命令：<code>npm run deploy 服务器的主机 服务器的密码</code> ，便能够分别实现前后端分离这两个项目从打包到上传服务器再到启动项目的一条龙服务，希望对大家有所帮助。</p></blockquote><h2 id="前端的自动化部署"><a href="#前端的自动化部署" class="headerlink" title="前端的自动化部署"></a>前端的自动化部署</h2><p>首先我们需要搞清楚前端项目的一系列部署流程，那便是 <strong>打包–登录服务器–上传打包文件</strong> ，那么按照这个思路，我们来具体捋清楚实现过程：</p><ol><li>逻辑思考</li></ol><ul><li>①运行脚本命令；</li><li>②然后脚本读取配置文件（包含服务器host、port、web目录及本地目录等信息）；</li><li>③<strong>打包生成 dist 包</strong> – <code>npm run build</code>；</li><li>④<strong>使用 scp2 连接服务器</strong>；</li><li>⑤<strong>将本地打包的 dist 上传</strong>至 <code>/usr/local/nginx/html/</code> ；</li><li>⑥<strong>获取脚本命令的自定义参数</strong>，这里的参数为服务器主机和密码，并赋值给服务器配置文件（第④点的目的是防止将服务器的主机和密码泄露在项目中）。  </li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack --config webpack&#x2F;webpack.prod.js&quot;, &#x2F;&#x2F;博主这里的配置是这样的，可能跟大家有点出入  &quot;deploy&quot;: &quot;npm run build &amp;&amp; node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 看到上面的 deploy 中的路径，我们可以知道需要在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js ，这个文件是为了使用 scp2 连接服务器，因此里面还放有服务器的一些相关配置。现在开始编写 index.js ：&#x2F;&#x2F; 注：scp2 的官网有相关 API 的使用方法，需要提醒的是文件上传的路径需要特别注意，因为不同的工具，写法不同，最终的效果也是有所差别的，例如有些工具上传文件时如果发现服务器该路径下没有对应文件，会自动生成文件夹，但有些工具却不会；同时，上传的文件路径后面带不带 “&#x2F;” ，也是会有不同的效果的，读者需要稍微留意一下。&#x2F;&#x2F; 1.引入 scp2 ，用于连接服务器const client &#x3D; require(&#39;scp2&#39;);&#x2F;&#x2F; 2.服务器的配置选项const server &#x3D; &#123;  host: &#39;&#39;, &#x2F;&#x2F; ip 地址  port: 22, &#x2F;&#x2F; 端口号  username: &#39;root&#39;, &#x2F;&#x2F; 用户名  password: &#39;&#39;, &#x2F;&#x2F; 密码  path: &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;dist&#39;  &#x2F;&#x2F; 存放项目的路径&#125;&#x2F;&#x2F; 4.用解构赋值获取脚本命令后面的两个参数：主机和密码const [ , , host, password] &#x3D; process.argv;server.host &#x3D; host;server.password &#x3D; password;&#x2F;&#x2F; 3.连接服务器并上传 dist 包到服务器的指定目录 pathclient.scp(&#39;dist&#x2F;&#39;, &#123;  port: server.port,  host: server.host,  username: server.username,  password: server.password,  path: server.path&#125;, function(err) &#123;  if (err) &#123;    console.log(&#39;文件上传失败&#39;, err)  &#125; else &#123;    console.log(&#39;文件上传成功&#39;);  &#125;&#125;)&#x2F;&#x2F; 之后执行【 npm run deploy 服务器主机 服务器密码 】便可实现前端项目的自动化部署了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后端的自动化部署"><a href="#后端的自动化部署" class="headerlink" title="后端的自动化部署"></a>后端的自动化部署</h2>与前端项目的自动化部署一样，我们也需要搞清楚后端项目的一系列部署流程，也就是 <strong>用一个文件夹单独存放需要上传的文件–登录服务器–上传文件–启动项目</strong> ，我们同样来看看具体实现：</li><li>逻辑思考</li></ol><ul><li>①<strong>手动将需要上传的文件复制到一个新建文件夹里，这个文件夹博主命名为 oppService</strong>；</li><li>②运行脚本命令；</li><li>③然后脚本读取配置文件–包含服务器host、port 和 oppService 目录以及 deploy.sh 脚本等信息；</li><li>④<strong>调用 node-ssh API 连接服务器</strong>；</li><li>⑤将 oppService <strong>文件夹上传至服务器指定目录</strong>；</li><li>⑥启动项目的方式博主是在服务器上运行自己编写的 .sh 脚本，里面编写的是项目上传之后服务器要做的后续命令 – 进入服务器上的 oppService 文件夹里以<strong>执行 deploy.sh 脚本</strong>；</li><li>⑦<strong>获取 npm scripts 命令的自定义参数</strong></li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 同样在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;deploy&quot;: &quot;node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js 。开始编写 index.js ：&#x2F;&#x2F; 1.引入 node-ssh 模块 ，准备调用内置 API&#x2F;&#x2F; 这里有个小问题，貌似官方有个 bug 没解决，不能直接 const node_ssh &#x3D; require(&#39;node-ssh&#39;); ，而是得改成下面的形式去导入const node_ssh &#x3D; require(&#39;node-ssh&#39;).NodeSSH;const ssh &#x3D; new node_ssh();&#x2F;&#x2F; 6.用解构赋值获取脚本命令后面的两个参数：主机和密码，并存入 config 中const [ , , host, password] &#x3D; process.argv;&#x2F;&#x2F; 2.服务器的配置选项const config &#x3D; &#123;  path: &#123;    localPath: &#39;oppService&#x2F;&#39;,    romotePath: &#39;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.71&#x2F;Online-programming-platform_service&#39;,  &#125;,  romote: &#123;    host: &#39;&#39;,    port: 22,    username: &#39;root&#39;,    password: &#39;&#39;  &#125;&#125;function uploadFile() &#123;  &#x2F;&#x2F; 3.连接服务器  ssh.connect(config.romote)  .then(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 4.上传 dist 包到服务器的指定目录 path    ssh.putDirectory(config.path.localPath, config.path.romotePath)    .then(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 5.执行脚本，完成文件上传后服务器的后备工作      ssh.execCommand(&#39;sh deploy.sh&#39;, &#123; cwd: config.path.romotePath &#125;)      .then((res) &#x3D;&gt; &#123;        if (!res.stderr) &#123;          process.exit(0);        &#125;      &#125;)    &#125;).catch(err &#x3D;&gt; &#123;      console.log(err)    &#125;)  &#125;).catch(err &#x3D;&gt; &#123;    console.log(&#39;服务器连接失败！！&#39;)  &#125;)&#125;uploadFile();&#x2F;&#x2F; 编写 deploy.sh 脚本#!&#x2F;bin&#x2F;bash# ①先关闭之前的服务，安装依赖之后再重启pm2 stop src&#x2F;app.ts# ②查看文件中是否已经包含 node_modules ，如果有则先删除file&#x3D;&#39;node_modules&#39;if [ -e $file ]; then  rm -rf $file  npm cache clean --forcefi# ③重新安装依赖cnpm install# ④查看8080端口是否被占用，有则 kill ，防止项目无法开启port&#x3D;8080pid&#x3D;$(netstat -nlp | grep :$port | awk &#39;&#123;print $7&#125;&#39; | awk -F&quot;&#x2F;&quot; &#39;&#123; print $1 &#125;&#39;)if [ -n &quot;$pid&quot; ]; then  kill -9 $pid;fi# ⑤重新启动 pm2pm2 start .&#x2F;src&#x2F;app.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>到这里，前后端分离项目的自动化部署就已经结束了，如果有遇到什么 bug ，也可以看看我的上一篇博客 <a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a>，或许能够带来一点点帮助。<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2>这样一来，项目部署的效率瞬间就提上来了，一条命令就搞定一切，但博主觉得，其实还有优化空间，例如后端项目需要事先将要上传的文件抽离出来，那我们每次编写完代码之后都得把文件更新一遍，不是很方便。这个问题就等后续再完善吧，毕竟在部署这里耽误的时间也差不多了(=￣ω￣=)。如果读者觉得有什么好的解决方案或者是其他可以优化的地方，也可以在评论区提出来哩，先谢过诸位啦~<blockquote><p>后续等有空了会回头来完善的哈</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2>从对服务器一窍不通，到掌握线上项目的部署，再到命令行的熟练操作，以及对解决问题能力的锻炼，这些都是博主在完成这个前后端分离项目线上部署带来的好处，毫无疑问收获是颇丰的。但实现的过程却并不轻松，有时候一个 bug 一卡就是两三天（终究还是能力不够吧 T^T），浪费了很多时间，但坚持总会有作用的，至少排查问题的能力或多或少能有所提高，真心希望读者能顺利完成项目的部署，直接通关【妖魔鬼怪（bug）快离开，妖魔鬼怪（bug）快离开】。<blockquote><p>以上 ^_^</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
            <tag> 线上部署 </tag>
            
            <tag> scp2 </tag>
            
            <tag> node-ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR 之部署服务器篇</title>
      <link href="/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/"/>
      <url>/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/</url>
      
        <content type="html"><![CDATA[<ol><li>POST <a href="http://120.79.193.126:8080/api/login">http://120.79.193.126:8080/api/login</a> net::ERR_CONNECTION_REFUSED?</li></ol><ol start="2"><li>POST <a href="http://localhost:3000/login">http://localhost:3000/login</a> 404 (Not Found)?</li></ol><p>有多种原因：①前端调用后端接口失败，通常是因为接口的路径匹配错误；②后端没有响应数据给前端；前端接收数据的格式与后端返回数据的格式不相符。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_44163269/article/details/105442612">vue项目 前端 POST(GET) http://127.0.0.1xxx 404(Not Found)错误 （多种误区解决）</a></p></blockquote><ol start="3"><li>在服务器运行<code>npm run dev</code>报错：SyntaxError: Cannot use import statement outside a module？  </li></ol><p>这提示一般是node下无法使用import。</p><blockquote><p><a href="https://blog.csdn.net/weixin_43094085/article/details/114832738">解决方法参考这篇文章</a></p></blockquote><ol start="3"><li>在服务器上启动 NodeJs+ts 项目时报错之一：TS错误:⨯无法编译TypeScript(Error: TSError: ⨯ Unable to compile TypeScript)</li></ol><p>解决：从 package.json 中删除 ts-node 和 typescript 。然后：</p><pre class="line-numbers language-none"><code class="language-none">npm install ts-node --save-devnpm install typescript -g npm install typescript --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在服务器上启动 NodeJs + Ts 项目时报错之二：Can’t run my Node.js Typescript project TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension “.ts” for /app/src/App.ts</li></ol><p>情况说明：博主启动项目的命令是 <code>npm start</code> ，项目 <code>package.json</code> 文件中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node src/app.ts</code> 。不幸的是，由于项目中既有 ES6 模块又有 CommonJS 模块，因此不能按照网上的教程只在 <code>package.json</code> 中添加 <code>&quot;type&quot;: &quot;module</code> 或者 只在 <code>tsconfig.json</code> 中添加 <code>&quot;type&quot;: &quot;CommonJS&quot;</code> ，因为如果这样的话，项目运行后还是会报如下的错误：</p><pre class="line-numbers language-none"><code class="language-none">import Koa from &#39;koa&#39;;^^^^^^SyntaxError: Cannot use import statement outside a module<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：修改 <code>package.json</code> 中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node --experimental-modules --loader ts-node/esm &#123; 项目入口文件 &#125;</code> </p><ol start="5"><li>服务器用 pm2 启动项目失败：Error: Cannot find module ‘/Users/wyb/.nvm/versions/io.js/v3.0.0/lib/node_modules/pm2/lib/ProcessContainerFork.js’</li></ol><p>情况说明：笔者的服务器确定是有安装了 pm2 的，使用 <code>pm2 -v</code> 也可以正常查询到版本号。然而此前 NodeJs 因为我误操作卸载重装了，虽然 pm2 也重新安装了一遍，但根目录下残留的文件路径指向的是以前的 pm2 ，因此只要将根目录下的 pm2 删除即可。</p><p>解决：<code>rm -rf ~/.pm2</code>  </p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/36690442/error-cannot-find-module-users-wyb-nvm-versions-io-js-v3-0-0-lib-node-module">overflow 回答</a></p></blockquote><ol start="6"><li>启动 pm2 报错：Process or Namespace ./src/app not found<pre class="line-numbers language-none"><code class="language-none">[PM2][ERROR] Process or Namespace .&#x2F;src&#x2F;app.ts not found[PM2][ERROR] Interpreter &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node is NOT AVAILABLE in PATH. (type &#39;which &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node&#39; to double check.)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>排查流程：正常下，可以先 <code>pm2 -v</code> 查看是否已经安装 pm2 ，如果不能显示版本信息，有两种情况，一种是没有安装，那么运行 <code>npm install pm2 -g</code> ；如果确定安装过了，则可以试试建立软链接：<code>ln -s &#123; 安装 pm2 的绝对路径 &#125; /usr/local/bin/</code> 。如果还不能解决，就再往下看看。</li></ol><p>先看第二个报错，情况①博主的服务器安装了宝塔面板，并在面板里安装了 pm2 管理器，导致与服务器的 pm2 冲突。于是把宝塔面板中的 pm2 管理器卸载，就没有这个报错了。②用 xshell 工具执行这条命令：<code>pm2 start src/app.ts --interpreter ./node_modules/.bin/ts-node</code> 即可。</p><ol start="7"><li><p>将项目中的脚本上传至服务器并执行时报错：npm: command not found？</p><pre class="line-numbers language-none"><code class="language-none">deploy.sh: line 2: npm: command not found&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据网上的解决方法，正解本来应该是 用绝对路径设置软链 ，但博主的情况很特殊，是由于 /usr/bin/env 命令被修改，导致找不到 node ，这也是在我多方尝试无果之后向阿里提交工单，大佬给出的回复。<br>大佬的解决方法便是从版本相同的主机 copy 一份 /usr/bin/env 命令到我本机上，这才恢复正常。</p><blockquote><p>注：在服务器上的操作大家一定要慎重，误删文件可能会导致各种很难解决的 bug ，这已经是我第二次遇到特殊情况了。</p></blockquote></li><li><p>端口被占用？</p></li></ol><ul><li>查看端口使用情况：<code>netstat -ntlp</code></li><li>杀掉进程：<code>kill （对应端口的PID）</code><blockquote><p>参考资料：<a href="http://blog.csdn.net/ljfphp/article/details/78666376">【转】linux下杀死进程（kill）的N种方法</a></p></blockquote></li></ul><ol start="9"><li>无法访问阿里云ip地址？</li></ol><p>解决方法：<a href="https://www.cnblogs.com/ghzjm/p/10677599.html">linux服务器安装nginx及使用</a></p><blockquote><p>排查1：<a href="https://blog.csdn.net/sinat_25957705/article/details/80641077">阿里云服务器 nginx公网IP无法访问浏览器</a><br>排查2：<a href="https://blog.csdn.net/Adime_J/article/details/109155234">linux服务器部署完成之后访问不到—–总结篇</a></p></blockquote><blockquote><ol><li>ping ip成功只能说明主机可以到达，端口还是有可能不可到达的。端口不可到达可能是由于HTTP 服务器未启动或者监听在其他端口入8080上了；还有一个可能是防火墙没开放80端口的访问权限。</li></ol></blockquote><blockquote><p>排查过程中遇到的问题：</p><ol><li>curl: (7) Failed to connect to 120.79.193.126 port 80: Connection refused<br><a href="https://www.cnblogs.com/jukaiit/p/8994448.html">Xshell 链接 Could not connect to ‘192.168.80.129’ (port 22): Connection failed</a><br>在Linux6中查看及设置开机自启信息是使用chkconfig命令，Linux7中此命令已经被替代。虽然Linux7中已经不再使用chkconfig命令来管理服务是否开机自启，但是此命令仍旧可用，但是输出信息提示我们使用chkconfig命令的输出只是呗SysV所管理的服务，不包括systemd管理的服务，所以如果想在CentOS7中查看systemd管理的服务需要使用以下命令：<a href="https://blog.csdn.net/qq_38295166/article/details/79828482">CentOS 7设置ssh服务自动启动</a></li></ol></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_38705903/article/details/101911553">或许有用？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Begin: myfist blog</title>
      <link href="/2021/10/31/begin-myfist-blog/"/>
      <url>/2021/10/31/begin-myfist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做 React-Ts 项目，两个月了，有了这个项目该有的雏形。就在昨天，我实现好了项目 40% 的功能，心里放松了一下，突然觉得有点累了，不是说真的那种累，而是因为 我从这个项目本身学到了很多东西，不仅有知识点的深入理解，还有处理问题的能力、思维逻辑的锻炼等等，得到的好处很多，此前一直投身于项目功能点的实现，还没机会消化，突然松了口气，顿觉身上积攒了很多东西，我觉得是时候该静下心来，沉淀我这两个月来所学到的东西，于是我着手搭建个人博客，准备记录自己的所学所感……</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>大二在读生一枚，我喜欢前端世界，对于前端技术我怀有十分的兴趣，网络上所见到的各种好看、奇特的效果，一想到都是通过代码实现的，我就觉得十分神奇，我之前认为，代码和那些好看的特效是不沾边的东西，没想到那些是用我不知道的方式实现的。对于前端技术的原理，我也感觉十分神奇，让我知道了代码世界里想当然是不对的，如果这样便往往会犯错。当然，后端的世界也不赖，虽然不像前端那样可视化，但有时对数据的处理能够返回预期效果，成就感也十足。这样，我想成为一名前端工程师，努力的话，争取全栈。</p><p>电脑是我日常生活中不能缺少的一件必需品，但生活不能只有电脑，我也喜欢打羽毛球、乒乓球、游泳、聚会（仅限于我在意的人），诗和远方亦是我向往的生活。但我知道心中虽有所往，但那不是想有就有的，诗和远方 都挺贵，目前我所能做的，便是提升我的硬实力，总得拿到长途旅行的门票吧^_^</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>用了一天时间搭建了个人博客，是我喜欢的主题，既然有这么方便好看的工具为我们铺好了红毯，我难道不应该兢兢业业地写好文章、做好博客吗（<em>^▽^</em>）</p><p>我决定先把项目放一边，一个星期，就一个星期，我得总结归纳，好好沉淀一下，学到的 很多很快，如果不及时记录，估计又得还回去了，所谓好记性不如烂笔头，这句话既然能成为谚语，肯定是有它的过人之处的 (￣ェ￣;)。一个星期过后，我再重新扬帆起航吧，再花一个半月左右的时间，应该能把这个项目完全搞定，总计三个半月，应该还可以接受吧（好吧，我觉得有点久了，争取三个月搞定）。那么这一个星期，我就要从头回顾一下我的项目了，这个过程说不定还可以解决掉历史残留问题，总之，要加油了！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上文有说到，搭建个人博客的初衷是沉淀所学所感，因此我对这个博客的定义首先是一个技术博客，我希望它能成为一个有含金量的技术文章存放地；其次是我本人的心灵树洞，我也期望它能成为我倾诉心声的所在，毕竟我是一个有时不太爱说话的人…..</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
