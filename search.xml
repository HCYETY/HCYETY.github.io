<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前后端分离项目线上部署</title>
      <link href="/2021/11/01/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/11/01/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>将项目部署至线上，使得任何用户在不同条件下也能够访问。那么首先需要一个服务器，网上有很多教程，能够教会大家如何拥有属于自己的服务器，这里不再赘述。本人购买的是阿里云的linux/CentOs7.7服务器（据说 21 年底，CentOs 官方将不再维护 CentOs8了，大家看看要配哪个系统好吧，博主之前不知情，选了 CentOs8 ，后来因为某种特殊原因决定重换系统，于是降低版本为 CentOs7）。 </li><li>当大家拥有自己的服务器后，就需要配置各种环境以支持项目能够顺利运行，这也是为什么开发者会说“这个项目在我的机器上能跑”的原了，因为“我的机器上有相关配置，你的机器上怎晓得有没有”。网上虽然有相关的资料，但杂多繁乱，本人当初因为配置环境浪费了很多时间，这里贴下 @b站up主CodeSheep 的 pdf ，真是一个很好的配置说明，一条龙服务，很快就能配置大部分必备的环境<blockquote><p>链接：<a href="https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ">https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ</a><br>提取码：h464 </p></blockquote></li></ol><p><strong>下面将会使用基础和进阶的方法部署项目，先说比较麻烦的手动部署流程，毕竟事情要一步一步来，从易到难嘛。</strong></p><h2 id="前端的手动化部署"><a href="#前端的手动化部署" class="headerlink" title="前端的手动化部署"></a>前端的手动化部署</h2><p>这里使用了 webpack ，由于本文重点不在于如何使用 webpack 配置项目，因此不详述，默认诸位看官已经学会相关知识点。</p><ol><li>首先要将本地项目打包成 dist 包，这点通过 webpack 配置可以完成。</li><li>打开 Xshell 工具，在 nginx 已经配合好的前提下，修改 nginx 的配置文件：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 找到【 nginx 的安装目录下的 conf】，修改 conf 下的 nginx.conf 。</span><span class="token comment">// 举例：我的安装路径是 /usr/local/nginx ，所以 vim /usr/local/nginx/conf/nginx.conf</span><span class="token comment">// 进到文件里面后，按 i 可以进入编辑模式修改文件，修改好后按 esc 可以退出编辑模式，然后输入 :wq 保存并退出文件</span><span class="token comment">// 修改配置如下：</span><span class="token comment">// 1. 在第一行加上 user root;</span><span class="token comment">// 2. 找到 server&#123; location / &#123;&#125; &#125;，修改如下</span>server <span class="token punctuation">&#123;</span>  listen       <span class="token number">80</span><span class="token punctuation">;</span>  server_name  localhost<span class="token punctuation">;</span>  #charset koi8<span class="token operator">-</span>r<span class="token punctuation">;</span>  #access_log  logs<span class="token operator">/</span>host<span class="token punctuation">.</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span>  <span class="token comment">// 这里修改</span>  location <span class="token operator">/</span> <span class="token punctuation">&#123;</span>    root   <span class="token punctuation">&#123;</span> nginx 的安装目录<span class="token operator">/</span>html<span class="token operator">/</span>xxx<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// eg. root   /usr/local/nginx/html/dist，dist 为打包后的前端项目;</span>    index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 配置好 nginx.conf 后，保存退出，重启 nginx</span><span class="token comment">// 重启命令为 &#123; nginx 的安装路径/sbin/nginx -s reload &#125;，举例：/usr/local/nginx/sbin/nginx -s reload</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>打开 Xftp 工具，找到 { nginx 的安装路径/html/ }，例如 /usr/local/nginx/html/ ，将 dist 包上传至 html 目录下。访问 ip 地址就可以看到前端项目的静态界面了<blockquote><p>前端项目的部署相对来说简单一些，只要将打包后的文件夹上传到服务器即可（配置好 nginx 的前提下）。下面看下后端项目的部署</p></blockquote><h2 id="后端的手动化部署"><a href="#后端的手动化部署" class="headerlink" title="后端的手动化部署"></a>后端的手动化部署</h2></li><li>配置好 Tomcat ，相关教程看 上文3.2 的 pdf   </li><li>在 Tomcat 的安装目录下新建一个文件夹，用来存放后端项目，这里命名为 myApp 。打开 Xftp 工具，选中要上传的后端文件，拖拽实现上传  </li><li>打开 Xshell 工具，用命令行进入 myApp ，安装项目所需的依赖 <code>npm install</code> 。用 pm2 监控项目，先全局安装 pm2 <code>npm install pm2 -g</code> ，然后用 pm2 启动项目入口文件 <code>pm2 start &#123;入口文件&#125; </code> 。到这里，后端项目的部署也完成啦，咕咕咕~<blockquote><p>到这里，其实本应该能成功启动前后端项目，并能够跑通服务，但绝大多数情况下总是事与愿违的，似乎老天爷不会让事情这么顺利，总要让我们经历一番磨练，所谓“天将降大任于斯人也，必先苦其心志，劳其筋骨是也”，于是总会出现各种奇奇怪怪的 bug 。博主也遇到了，一度很伤脑筋，所以后来终于解决了，博主的上一篇博客：<a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a> 记录了博主遇到的一些困难，说不定与读者相同，可以借鉴参考其解决方法，如果能顺利帮助到大家就再好不过了！</p></blockquote></li></ol><blockquote><p>如果读者已经顺利完成了项目的非自动化部署，相信能够感受到诸多的不便之处，下面博主会为大家介绍自动化部署前后端分离项目的流程，最终的效果便是在本地编辑器的终端运行两次命令：<code>npm run deploy 服务器的主机 服务器的密码</code> ，便能够分别实现前后端分离这两个项目从打包到上传服务器再到启动项目的一条龙服务，希望对大家有所帮助。</p></blockquote><h2 id="前端的自动化部署"><a href="#前端的自动化部署" class="headerlink" title="前端的自动化部署"></a>前端的自动化部署</h2><p>首先我们需要搞清楚前端项目的一系列部署流程，那便是 <strong>打包–登录服务器–上传打包文件</strong> ，那么按照这个思路，我们来具体捋清楚实现过程：</p><ol><li>逻辑思考</li></ol><ul><li>①运行脚本命令；</li><li>②然后脚本读取配置文件（包含服务器host、port、web目录及本地目录等信息）；</li><li>③<strong>打包生成 dist 包</strong> – <code>npm run build</code>；</li><li>④<strong>使用 scp2 连接服务器</strong>；</li><li>⑤<strong>将本地打包的 dist 上传</strong>至 <code>/usr/local/nginx/html/</code> ；</li><li>⑥<strong>获取脚本命令的自定义参数</strong>，这里的参数为服务器主机和密码，并赋值给服务器配置文件（第④点的目的是防止将服务器的主机和密码泄露在项目中）。  </li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack --config webpack&#x2F;webpack.prod.js&quot;, &#x2F;&#x2F;博主这里的配置是这样的，可能跟大家有点出入  &quot;deploy&quot;: &quot;npm run build &amp;&amp; node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 看到上面的 deploy 中的路径，我们可以知道需要在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js ，这个文件是为了使用 scp2 连接服务器，因此里面还放有服务器的一些相关配置。现在开始编写 index.js ：&#x2F;&#x2F; 注：scp2 的官网有相关 API 的使用方法，需要提醒的是文件上传的路径需要特别注意，因为不同的工具，写法不同，最终的效果也是有所差别的，例如有些工具上传文件时如果发现服务器该路径下没有对应文件，会自动生成文件夹，但有些工具却不会；同时，上传的文件路径后面带不带 “&#x2F;” ，也是会有不同的效果的，读者需要稍微留意一下。&#x2F;&#x2F; 1.引入 scp2 ，用于连接服务器const client &#x3D; require(&#39;scp2&#39;);&#x2F;&#x2F; 2.服务器的配置选项const server &#x3D; &#123;  host: &#39;&#39;, &#x2F;&#x2F; ip 地址  port: 22, &#x2F;&#x2F; 端口号  username: &#39;root&#39;, &#x2F;&#x2F; 用户名  password: &#39;&#39;, &#x2F;&#x2F; 密码  path: &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;dist&#39;  &#x2F;&#x2F; 存放项目的路径&#125;&#x2F;&#x2F; 4.用解构赋值获取脚本命令后面的两个参数：主机和密码const [ , , host, password] &#x3D; process.argv;server.host &#x3D; host;server.password &#x3D; password;&#x2F;&#x2F; 3.连接服务器并上传 dist 包到服务器的指定目录 pathclient.scp(&#39;dist&#x2F;&#39;, &#123;  port: server.port,  host: server.host,  username: server.username,  password: server.password,  path: server.path&#125;, function(err) &#123;  if (err) &#123;    console.log(&#39;文件上传失败&#39;, err)  &#125; else &#123;    console.log(&#39;文件上传成功&#39;);  &#125;&#125;)&#x2F;&#x2F; 之后执行【 npm run deploy 服务器主机 服务器密码 】便可实现前端项目的自动化部署了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后端的自动化部署"><a href="#后端的自动化部署" class="headerlink" title="后端的自动化部署"></a>后端的自动化部署</h2>与前端项目的自动化部署一样，我们也需要搞清楚后端项目的一系列部署流程，也就是 <strong>用一个文件夹单独存放需要上传的文件–登录服务器–上传文件–启动项目</strong> ，我们同样来看看具体实现：</li><li>逻辑思考</li></ol><ul><li>①<strong>手动将需要上传的文件复制到一个新建文件夹里，这个文件夹博主命名为 oppService</strong>；</li><li>②运行脚本命令；</li><li>③然后脚本读取配置文件–包含服务器host、port 和 oppService 目录以及 deploy.sh 脚本等信息；</li><li>④<strong>调用 node-ssh API 连接服务器</strong>；</li><li>⑤将 oppService <strong>文件夹上传至服务器指定目录</strong>；</li><li>⑥启动项目的方式博主是在服务器上运行自己编写的 .sh 脚本，里面编写的是项目上传之后服务器要做的后续命令 – 进入服务器上的 oppService 文件夹里以<strong>执行 deploy.sh 脚本</strong>；</li><li>⑦<strong>获取 npm scripts 命令的自定义参数</strong></li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 同样在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;deploy&quot;: &quot;node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js 。开始编写 index.js ：&#x2F;&#x2F; 1.引入 node-ssh 模块 ，准备调用内置 API&#x2F;&#x2F; 这里有个小问题，貌似官方有个 bug 没解决，不能直接 const node_ssh &#x3D; require(&#39;node-ssh&#39;); ，而是得改成下面的形式去导入const node_ssh &#x3D; require(&#39;node-ssh&#39;).NodeSSH;const ssh &#x3D; new node_ssh();&#x2F;&#x2F; 6.用解构赋值获取脚本命令后面的两个参数：主机和密码，并存入 config 中const [ , , host, password] &#x3D; process.argv;&#x2F;&#x2F; 2.服务器的配置选项const config &#x3D; &#123;  path: &#123;    localPath: &#39;oppService&#x2F;&#39;,    romotePath: &#39;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.71&#x2F;Online-programming-platform_service&#39;,  &#125;,  romote: &#123;    host: &#39;&#39;,    port: 22,    username: &#39;root&#39;,    password: &#39;&#39;  &#125;&#125;function uploadFile() &#123;  &#x2F;&#x2F; 3.连接服务器  ssh.connect(config.romote)  .then(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 4.上传 dist 包到服务器的指定目录 path    ssh.putDirectory(config.path.localPath, config.path.romotePath)    .then(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 5.执行脚本，完成文件上传后服务器的后备工作      ssh.execCommand(&#39;sh deploy.sh&#39;, &#123; cwd: config.path.romotePath &#125;)      .then((res) &#x3D;&gt; &#123;        if (!res.stderr) &#123;          process.exit(0);        &#125;      &#125;)    &#125;).catch(err &#x3D;&gt; &#123;      console.log(err)    &#125;)  &#125;).catch(err &#x3D;&gt; &#123;    console.log(&#39;服务器连接失败！！&#39;)  &#125;)&#125;uploadFile();&#x2F;&#x2F; 编写 deploy.sh 脚本#!&#x2F;bin&#x2F;bash# ①先关闭之前的服务，安装依赖之后再重启pm2 stop src&#x2F;app.ts# ②查看文件中是否已经包含 node_modules ，如果有则先删除file&#x3D;&#39;node_modules&#39;if [ -e $file ]; then  rm -rf $file  npm cache clean --forcefi# ③重新安装依赖cnpm install# ④查看8080端口是否被占用，有则 kill ，防止项目无法开启port&#x3D;8080pid&#x3D;$(netstat -nlp | grep :$port | awk &#39;&#123;print $7&#125;&#39; | awk -F&quot;&#x2F;&quot; &#39;&#123; print $1 &#125;&#39;)if [ -n &quot;$pid&quot; ]; then  kill -9 $pid;fi# ⑤重新启动 pm2pm2 start .&#x2F;src&#x2F;app.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>到这里，前后端分离项目的自动化部署就已经结束了，如果有遇到什么 bug ，也可以看看我的上一篇博客 <a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a>，或许能够带来一点点帮助。<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2>这样一来，项目部署的效率瞬间就提上来了，一条命令就搞定一切，但博主觉得，其实还有优化空间，例如后端项目需要事先将要上传的文件抽离出来，那我们每次编写完代码之后都得把文件更新一遍，不是很方便。这个问题就等后续再完善吧，毕竟在部署这里耽误的时间也差不多了(=￣ω￣=)。如果读者觉得有什么好的解决方案或者是其他可以优化的地方，也可以在评论区提出来哩，先谢过诸位啦~<blockquote><p>后续等有空了会回头来完善的哈</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2>从对服务器一窍不通，到掌握线上项目的部署，再到命令行的熟练操作，以及对解决问题能力的锻炼，这些都是博主在完成这个前后端分离项目线上部署带来的好处，毫无疑问收获是颇丰的。但实现的过程却并不轻松，有时候一个 bug 一卡就是两三天（终究还是能力不够吧 T^T），浪费了很多时间，但坚持总会有作用的，至少排查问题的能力或多或少能有所提高，真心希望读者能顺利完成项目的部署，直接通关【妖魔鬼怪（bug）快离开，妖魔鬼怪（bug）快离开】。<blockquote><p>以上 ^_^</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
            <tag> 线上部署 </tag>
            
            <tag> scp2 </tag>
            
            <tag> node-ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR 之部署服务器篇</title>
      <link href="/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/"/>
      <url>/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ol><li>POST <a href="http://localhost:3000/login">http://localhost:3000/login</a> 404 (Not Found)?</li></ol><p>有多种原因：①前端调用后端接口失败，通常是因为接口的路径匹配错误；②后端没有响应数据给前端；前端接收数据的格式与后端返回数据的格式不相符。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_44163269/article/details/105442612">vue项目 前端 POST(GET) http://127.0.0.1xxx 404(Not Found)错误 （多种误区解决）</a></p></blockquote><ol start="2"><li>在服务器运行<code>npm run dev</code>报错：SyntaxError: Cannot use import statement outside a module？  </li></ol><p>这提示一般是node下无法使用import。</p><blockquote><p><a href="https://blog.csdn.net/weixin_43094085/article/details/114832738">解决方法参考这篇文章</a></p></blockquote><ol start="3"><li>在服务器上启动 NodeJs+ts 项目时报错之一：TS错误:⨯无法编译TypeScript(Error: TSError: ⨯ Unable to compile TypeScript)</li></ol><p>解决：从 package.json 中删除 ts-node 和 typescript 。然后：</p><pre class="line-numbers language-none"><code class="language-none">npm install ts-node --save-devnpm install typescript -g npm install typescript --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在服务器上启动 NodeJs + Ts 项目时报错之二：Can’t run my Node.js Typescript project TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension “.ts” for /app/src/App.ts</li></ol><p>情况说明：博主启动项目的命令是 <code>npm start</code> ，项目 <code>package.json</code> 文件中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node src/app.ts</code> 。不幸的是，由于项目中既有 ES6 模块又有 CommonJS 模块，因此不能按照网上的教程只在 <code>package.json</code> 中添加 <code>&quot;type&quot;: &quot;module</code> 或者 只在 <code>tsconfig.json</code> 中添加 <code>&quot;type&quot;: &quot;CommonJS&quot;</code> ，因为如果这样的话，项目运行后还是会报如下的错误：</p><pre class="line-numbers language-none"><code class="language-none">import Koa from &#39;koa&#39;;^^^^^^SyntaxError: Cannot use import statement outside a module<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：修改 <code>package.json</code> 中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node --experimental-modules --loader ts-node/esm &#123; 项目入口文件 &#125;</code> </p><ol start="5"><li>服务器用 pm2 启动项目失败：Error: Cannot find module ‘/Users/wyb/.nvm/versions/io.js/v3.0.0/lib/node_modules/pm2/lib/ProcessContainerFork.js’</li></ol><p>情况说明：笔者的服务器确定是有安装了 pm2 的，使用 <code>pm2 -v</code> 也可以正常查询到版本号。然而此前 NodeJs 因为我误操作卸载重装了，虽然 pm2 也重新安装了一遍，但根目录下残留的文件路径指向的是以前的 pm2 ，因此只要将根目录下的 pm2 删除即可。</p><p>解决：<code>rm -rf ~/.pm2</code>  </p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/36690442/error-cannot-find-module-users-wyb-nvm-versions-io-js-v3-0-0-lib-node-module">overflow 回答</a></p></blockquote><ol start="6"><li>启动 pm2 报错：Process or Namespace ./src/app not found<pre class="line-numbers language-none"><code class="language-none">[PM2][ERROR] Process or Namespace .&#x2F;src&#x2F;app.ts not found[PM2][ERROR] Interpreter &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node is NOT AVAILABLE in PATH. (type &#39;which &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node&#39; to double check.)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>排查流程：正常下，可以先 <code>pm2 -v</code> 查看是否已经安装 pm2 ，如果不能显示版本信息，有两种情况，一种是没有安装，那么运行 <code>npm install pm2 -g</code> ；如果确定安装过了，则可以试试建立软链接：<code>ln -s &#123; 安装 pm2 的绝对路径 &#125; /usr/local/bin/</code> 。如果还不能解决，就再往下看看。</li></ol><p>先看第二个报错，情况①博主的服务器安装了宝塔面板，并在面板里安装了 pm2 管理器，导致与服务器的 pm2 冲突。于是把宝塔面板中的 pm2 管理器卸载，就没有这个报错了。②用 xshell 工具执行这条命令：<code>pm2 start src/app.ts --interpreter ./node_modules/.bin/ts-node</code> 即可。</p><ol start="7"><li><p>将项目中的脚本上传至服务器并执行时报错：npm: command not found？</p><pre class="line-numbers language-none"><code class="language-none">deploy.sh: line 2: npm: command not found&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据网上的解决方法，正解本来应该是 用绝对路径设置软链 ，但博主的情况很特殊，是由于 /usr/bin/env 命令被修改，导致找不到 node ，这也是在我多方尝试无果之后向阿里提交工单，大佬给出的回复。<br>大佬的解决方法便是从版本相同的主机 copy 一份 /usr/bin/env 命令到我本机上，这才恢复正常。</p><blockquote><p>注：在服务器上的操作大家一定要慎重，误删文件可能会导致各种很难解决的 bug ，这已经是我第二次遇到特殊情况了。</p></blockquote></li><li><p>端口被占用？</p></li></ol><ul><li>查看端口使用情况：<code>netstat -ntlp</code></li><li>杀掉进程：<code>kill （对应端口的PID）</code><blockquote><p>参考资料：<a href="http://blog.csdn.net/ljfphp/article/details/78666376">【转】linux下杀死进程（kill）的N种方法</a></p></blockquote></li></ul><ol start="9"><li>无法访问阿里云ip地址？</li></ol><p>解决方法：<a href="https://www.cnblogs.com/ghzjm/p/10677599.html">linux服务器安装nginx及使用</a></p><blockquote><p>排查1：<a href="https://blog.csdn.net/sinat_25957705/article/details/80641077">阿里云服务器 nginx公网IP无法访问浏览器</a><br>排查2：<a href="https://blog.csdn.net/Adime_J/article/details/109155234">linux服务器部署完成之后访问不到—–总结篇</a></p></blockquote><blockquote><ol><li>ping ip成功只能说明主机可以到达，端口还是有可能不可到达的。端口不可到达可能是由于HTTP 服务器未启动或者监听在其他端口入8080上了；还有一个可能是防火墙没开放80端口的访问权限。</li></ol></blockquote><blockquote><p>排查过程中遇到的问题：</p><ol><li>curl: (7) Failed to connect to 120.79.193.126 port 80: Connection refused<br><a href="https://www.cnblogs.com/jukaiit/p/8994448.html">Xshell 链接 Could not connect to ‘192.168.80.129’ (port 22): Connection failed</a><br>在Linux6中查看及设置开机自启信息是使用chkconfig命令，Linux7中此命令已经被替代。虽然Linux7中已经不再使用chkconfig命令来管理服务是否开机自启，但是此命令仍旧可用，但是输出信息提示我们使用chkconfig命令的输出只是呗SysV所管理的服务，不包括systemd管理的服务，所以如果想在CentOS7中查看systemd管理的服务需要使用以下命令：<a href="https://blog.csdn.net/qq_38295166/article/details/79828482">CentOS 7设置ssh服务自动启动</a></li></ol></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_38705903/article/details/101911553">或许有用？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Begin: myfist blog</title>
      <link href="/2021/10/31/Begin-myfist-blog/"/>
      <url>/2021/10/31/Begin-myfist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做 React-Ts 项目，两个月了，有了这个项目该有的雏形。就在昨天，我实现好了项目 40% 的功能，心里放松了一下，突然觉得有点累了，不是说真的那种累，而是因为 我从这个项目本身学到了很多东西，不仅有知识点的深入理解，还有处理问题的能力、思维逻辑的锻炼等等，得到的好处很多，此前一直投身于项目功能点的实现，还没机会消化，突然松了口气，顿觉身上积攒了很多东西，我觉得是时候该静下心来，沉淀我这两个月来所学到的东西，于是我着手搭建个人博客，准备记录自己的所学所感……</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>大二在读生一枚，我喜欢前端世界，对于前端技术我怀有十分的兴趣，网络上所见到的各种好看、奇特的效果，一想到都是通过代码实现的，我就觉得十分神奇，我之前认为，代码和那些好看的特效是不沾边的东西，没想到那些是用我不知道的方式实现的。对于前端技术的原理，我也感觉十分神奇，让我知道了代码世界里想当然是不对的，如果这样便往往会犯错。当然，后端的世界也不赖，虽然不像前端那样可视化，但有时对数据的处理能够返回预期效果，成就感也十足。这样，我想成为一名前端工程师，努力的话，争取全栈。</p><p>电脑是我日常生活中不能缺少的一件必需品，但生活不能只有电脑，我也喜欢打羽毛球、乒乓球、游泳、聚会（仅限于我在意的人），诗和远方亦是我向往的生活。但我知道心中虽有所往，但那不是想有就有的，诗和远方 都挺贵，目前我所能做的，便是提升我的硬实力，总得拿到长途旅行的门票吧^_^</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>用了一天时间搭建了个人博客，是我喜欢的主题，既然有这么方便好看的工具为我们铺好了红毯，我难道不应该兢兢业业地写好文章、做好博客吗（<em>^▽^</em>）</p><p>我决定先把项目放一边，一个星期，就一个星期，我得总结归纳，好好沉淀一下，学到的 很多很快，如果不及时记录，估计又得还回去了，所谓好记性不如烂笔头，这句话既然能成为谚语，肯定是有它的过人之处的 (￣ェ￣;)。一个星期过后，我再重新扬帆起航吧，再花一个半月左右的时间，应该能把这个项目完全搞定，总计三个半月，应该还可以接受吧（好吧，我觉得有点久了，争取三个月搞定）。那么这一个星期，我就要从头回顾一下我的项目了，这个过程说不定还可以解决掉历史残留问题，总之，要加油了！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上文有说到，搭建个人博客的初衷是沉淀所学所感，因此我对这个博客的定义首先是一个技术博客，我希望它能成为一个有含金量的技术文章存放地；其次是我本人的心灵树洞，我也期望它能成为我倾诉心声的所在，毕竟我是一个有时不太爱说话的人…..</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Ts 项目：在线编程笔试平台</title>
      <link href="/2021/10/31/React-Ts-%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AF%95%E5%B9%B3%E5%8F%B0/"/>
      <url>/2021/10/31/React-Ts-%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AF%95%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个项目是笔者为将来找实习准备的，用到的技术点有好一些是边学边做的，同时在这个过程中也会去做一些自己刚兴趣的玩意如搭建个人博客（与这个项目无关？应该无关^_^），因此整个项目从开始到完成会比较耗时，读者也可能会搞不清楚某个部分与这个项目究竟有个关联，笔者就在这里先解释一下。但宏观说起来，其实也还是有一点点关联在里面的，因为做着做着发现有需要了（比如需要记下笔记等等），笔者才会先放下项目去做别的嘛。总之，顺着时间线一步步下来，也还是不难搞懂的。</p><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>该项目是一个在线编程笔试平台。主要功能是面试官①编辑（可新增、修改、删除）试卷和试题【一张试卷有多道试题】；②查看候选人编程结果并给予评分和备注等信息。候选人①在线完成代码编写并提交；②是否可查看已提交或已结束的试题；③可在评论区留言。<br>该项目包含了前端和后端两种技术栈，前端采用的是 React ，后端采用的是 NodeJs ，整个项目为前后端分离项目。</p><h2 id="项目任务拆解"><a href="#项目任务拆解" class="headerlink" title="项目任务拆解"></a>项目任务拆解</h2><ol><li>登录/注册模块</li></ol><ul><li>支持邮箱登录和注册</li><li>支持退出登录</li></ul><ol start="2"><li>面试题模块</li></ol><ul><li>面试官可填写试卷和面试题</li><li>支持新建、修改、删除试卷和面试题目</li><li>支持邀请多个候选人编程</li><li>面试题目支持富文本格式</li></ul><ol start="3"><li>在线编程模块</li></ol><ul><li>候选人可在线编写代码</li><li>代码支持多种语言高亮</li><li>候选人侧可提交最终编程代码</li><li>面试官侧刷新能看到最终代码</li></ul><ol start="4"><li>在线留言模块</li></ol><ul><li>候选人可以通过文字给面试官留言</li><li>面试官可以回复</li><li>留言内容长期保存</li><li>留言模块自动刷新</li></ul><ol start="5"><li>在线编程模块支持自动刷新</li></ol><ul><li>候选人侧代码支持自动保存</li><li>面试官侧代码自动刷新</li></ul><ol start="6"><li>在线留言模块改成实时文字聊天</li></ol><ul><li>候选人和面试官可实时文字聊天</li><li>其他获得链接的人都可参与文字聊天</li></ul><ol start="7"><li>在线语音聊天模块</li></ol><ul><li>候选人和面试官可实时语音聊天</li></ul><ol start="8"><li>在线编程模块支持运行JS代码</li></ol><ul><li>候选人和面试官可在线运行 JS 代码并查看输出</li></ul><ol start="9"><li> 在线编程模块支持协同编辑</li></ol><ul><li>候选人和面试官可实时协作编程<h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2></li><li><input checked="" disabled="" type="checkbox"> 2021-09-04：实现登录/注册的静态页面</li><li><input checked="" disabled="" type="checkbox"> 2021-09-19：实现登录/注册逻辑（包括账号密码登录、登录拦截，session 身份验证）</li><li><input checked="" disabled="" type="checkbox"> 2021-09-29：初步部署前后端项目到阿里云服务器</li><li><input checked="" disabled="" type="checkbox"> 2021-10-04：购买域名并实现自动化部署项目</li><li><input checked="" disabled="" type="checkbox"> 2021-10-05：支持使用邮箱 登录和注册</li><li><input checked="" disabled="" type="checkbox"> 2021-10-09：支持新建/删除试卷，在“新建试卷”里新建/修改/删除试题，发送邮件至候选人邮箱</li><li><input checked="" disabled="" type="checkbox"> 2021-10-23：初步完成面试题模块</li><li><input checked="" disabled="" type="checkbox"> 2021-10-30：初步完成在线编程模块</li><li><input checked="" disabled="" type="checkbox"> 2021-10-31：搭建个人博客</li></ul><h2 id="本文还在持续更新中……"><a href="#本文还在持续更新中……" class="headerlink" title="本文还在持续更新中……"></a>本文还在持续更新中……</h2>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Ts </tag>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
