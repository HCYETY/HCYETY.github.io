<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>备战前端实习面试之浏览器篇</title>
      <link href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-javascript-pian/"/>
      <url>/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-javascript-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="什么是-xss-攻击"><a href="#什么是-xss-攻击" class="headerlink" title="什么是 xss 攻击"></a>什么是 xss 攻击</h3><p>xss 攻击指的是<strong>跨站脚本攻击</strong>，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使其在用户的浏览器上运行，从而盗取用户的信息，如 cookie 等。</p><p>xss 攻击的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，但浏览器没有能力区分这些恶意代码，只能无条件执行。</p><p>xss 攻击可以分为反射型、存储型、DOM 型：</p><ul><li>反射型指的是攻击者诱导用户访问带有恶意代码的 url ，服务端接收数据后处理，将带有恶意代码的数据发送回浏览器，浏览器解析这段带有 xss 代码的数据后会将其当做脚本执行，以此完成 xss 攻击。</li><li>存储型指的是恶意脚本会存储在服务器上，当浏览器请求数据时，这段恶意脚本会从服务器传回并执行。</li><li>DOM 型指的是攻击者修改网页的 DOM 节点而形成的 xss 攻击。</li></ul><p>反射型 xss 与存储型 xss 的区别：</p><ul><li>反射型作用范围小，仅局限于单体攻击对象；而存储型则是作用于操作到数据库的所有用户。</li><li>反射型的恶意代码存在 url 里，而存储型的恶意代码存储在数据库里。</li></ul><p>DOM xss 与前两种 xss 的区别：</p><ul><li>DOM 型 xss 攻击中，取出和执行恶意代码都由浏览器完成，属于前端 JavaScript 自身的安全漏洞；而其他两种 xss 攻击都是属于服务端的安全漏洞。</li></ul><h2 id="如何防御-xss-攻击："><a href="#如何防御-xss-攻击：" class="headerlink" title="如何防御 xss 攻击："></a>如何防御 xss 攻击：</h2><h3 id="什么是-csrf-攻击"><a href="#什么是-csrf-攻击" class="headerlink" title="什么是 csrf 攻击"></a>什么是 csrf 攻击</h3><p>csrf 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求，如果用户在被攻击网站中保存了登录状态，攻击者就可以利用这个登录状态绕过后台的用户验证，伪装成用户执行操作。</p><p>常见的 csrf 攻击有三种：</p><ul><li>GET 类型的 csrf 攻击：比如在网站中的一个 img 标签里构建一个请求，在用户打开这个网页时就会自动提交。</li><li>POST 类型的 csrf 攻击：比如构建一个表单，然后隐藏它，在用户进入页面时，就会自动提交这个表单。</li><li>链接类型的 csrf 攻击：比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li></ul><h2 id="如何防御-csrf-攻击："><a href="#如何防御-csrf-攻击：" class="headerlink" title="如何防御 csrf 攻击："></a>如何防御 csrf 攻击：</h2><h3 id="什么是网络劫持"><a href="#什么是网络劫持" class="headerlink" title="什么是网络劫持"></a>什么是网络劫持</h3><p>网络劫持分为两种：<br>（1）DNS 劫持：（输入京东被强制跳转到淘宝就属于 DNS 劫持）</p><ul><li>DNS 强制解析：通过修改运营商的本地 DNS 记录，来引导用户流量到缓存服务器</li><li>302跳转的方式：通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的<br>（2）HTTP 劫持：</li></ul><h2 id="进程和线程，以及两者的区别"><a href="#进程和线程，以及两者的区别" class="headerlink" title="进程和线程，以及两者的区别"></a>进程和线程，以及两者的区别</h2><p>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</p><p>线程是进程中的更小单位，描述了执行一段指令所需的时间。</p><p>区别：</p><ul><li>进程可以看做是独立应用，但线程不行</li><li>资源：进程是 CPU 资源分配</li></ul><h2 id="减少回流与重绘的方法"><a href="#减少回流与重绘的方法" class="headerlink" title="减少回流与重绘的方法"></a>减少回流与重绘的方法</h2><ul><li>避免频繁的操作 DOM ，可以创建一个文档片段，在它上面应用所有 DOM 操作，最后再把它添加到文档中</li><li>如果非得操作 DOM ，尽量在低层级的 DOM 节点进行操作</li><li>将 DOM 的多个读操作（写操作）放在一起，而不是读写操作穿插着写。</li><li>使用 CSS 表达式</li><li>不要频繁修改元素的样式，对于静态页面，可以修改类名，而不是样式</li><li>使用 absolute 或 fixed ，使元素脱离文档流</li><li>将元素设置 display: none ，操作结束后再把它显示出来</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>备战前端实习面试之CSS篇</title>
      <link href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-css-pian/"/>
      <url>/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-css-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h2><h2 id="link-和-import-的区别"><a href="#link-和-import-的区别" class="headerlink" title="link 和 @import 的区别"></a>link 和 @import 的区别</h2><p>两者都是外部引用 css 的方式，区别如下：</p><ul><li>link 是 XHTML 标签，无兼容问题；@import 是在 css2.1 时提出的，低版本的浏览器不支持；</li><li>link 引入 css 时，在页面载入时同时加载；@import 需要在页面完全载入以后再加载；</li><li>link 支持使用 JavaScript 去控制 DOM 修改样式，@import不支持；</li><li>link 是 XHTML 标签，除了加载 css 外，还可以定义 rss 等其他事务，@import只属于 css 范畴，只能加载 css</li></ul><h2 id="display-none-与-visibility-hidden-的区别"><a href="#display-none-与-visibility-hidden-的区别" class="headerlink" title="display:none 与 visibility:hidden 的区别"></a>display:none 与 visibility:hidden 的区别</h2><p>这两个属性都是让元素隐藏，不可见。<br>区别如下：</p><ul><li>在渲染树中<ul><li><code>display:none</code> 会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code> 不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul></li><li>是否是继承属性<ul><li><code>display:none</code> 是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code> 是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置 <code>visibility:visible</code> 可以让子孙节点显示；</li></ul></li><li>修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改 <code>visibility</code> 属性只会造成本元素的重绘；</li><li>如果使用读屏器，设置为 <code>display:none</code> 的内容不会被读取，设置为 <code>visibility:hidden</code> 的内容会被读取。</li></ul><h2 id="伪元素和伪类的区别和作用"><a href="#伪元素和伪类的区别和作用" class="headerlink" title="伪元素和伪类的区别和作用"></a>伪元素和伪类的区别和作用</h2><p>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p><p>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。</p><p>总结： 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p><h2 id="替换元素的概念及计算规则"><a href="#替换元素的概念及计算规则" class="headerlink" title="替换元素的概念及计算规则"></a>替换元素的概念及计算规则</h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p><p>替换元素除了内容可替换这一特性以外，还有以下特性：</p><ul><li>内容的外观不受页面上的CSS的影响：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li><li>有自己的尺寸：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素</li><li>在很多CSS属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li><li>所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li></ul><p>替换元素的尺寸从内而外分为三类：</p><ul><li>固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li>HTML尺寸： 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li><li>CSS尺寸： 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li></ul><p>这三层结构的计算规则具体如下：<br>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。<br>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。<br>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。<br>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。<br>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。<br>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p><h2 id="常见的图片格式及使用场景"><a href="#常见的图片格式及使用场景" class="headerlink" title="常见的图片格式及使用场景"></a>常见的图片格式及使用场景</h2><p>（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。<br>（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。<br>（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。<br>（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。<br>（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。<br>（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。<br>（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h2 id="对-CSSSprites-的理解"><a href="#对-CSSSprites-的理解" class="headerlink" title="对 CSSSprites 的理解"></a>对 CSSSprites 的理解</h2><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p>优点：</p><ul><li>利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；</li><li>CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p>缺点：</p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li>CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。</li></ul><h2 id="css-优化和提高性能的方法有哪些"><a href="#css-优化和提高性能的方法有哪些" class="headerlink" title="css 优化和提高性能的方法有哪些"></a>css 优化和提高性能的方法有哪些</h2><p>加载性能：</p><ul><li>打包压缩 css ，减小文件体积</li><li>不要连写，执行效率会提高</li><li>使用 link 而不使用 @import ，前者在页面加载时一起加载，而后者是等待页面加载完之后再进行加载</li></ul><p>选择器性能：</p><ul><li>css 选择符是从右到左进行匹配的，尽可能降低选择器的深度</li><li>避免使用通配规则，如 <code>*&#123;&#125;</code></li><li>不要添加太多的选择器</li><li>避免使用属性选择器，而是用 class</li><li>了解哪些属性是可以通过继承而来的，避免对这些属性重复指定规则</li></ul><p>渲染性能：</p><ul><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ul><p>可维护性、健壮性：</p><ul><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ul><h2 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h2><ul><li>有空格时会有间隙，可以删除空格解决；</li><li>使用 <code>font-size</code> 时，可通过设置 <code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li><li><code>margin</code> 正值时，可以让 <code>margin</code> 使用负值解决；</li></ul><h2 id="单行、多行文本溢出隐藏"><a href="#单行、多行文本溢出隐藏" class="headerlink" title="单行、多行文本溢出隐藏"></a>单行、多行文本溢出隐藏</h2><ul><li><p>单行文本溢出</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> hiddle<span class="token punctuation">;</span><span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span><span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>多行文本溢出</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> hiddle<span class="token punctuation">;</span><span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span><span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span><span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> 3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。</p><h2 id="z-index属性在什么情况下会失效"><a href="#z-index属性在什么情况下会失效" class="headerlink" title="z-index属性在什么情况下会失效"></a>z-index属性在什么情况下会失效</h2><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。<strong>z-index元素的position属性需要是relative，absolute或是fixed</strong>。</p><p>z-index属性在下列情况下会失效：</p><ul><li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li><li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li><li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>备战前端实习面试之HTML篇</title>
      <link href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-html-pian/"/>
      <url>/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-html-pian/</url>
      
        <content type="html"><![CDATA[<p>前端面试题系列小抄：<br>【1】<a href="">备战前端实习面试之HTML篇</a><br>【2】<a href="">备战前端实习面试之CSS篇</a><br>【3】<a href="">备战前端实习面试之JavaScript篇</a><br>【4】<a href="">备战前端实习面试之React篇</a><br>【5】<a href="">备战前端实习面试之Node.js篇</a><br>【6】<a href="">备战前端实习面试之浏览器原理篇</a><br>【8】<a href="">备战前端实习面试之性能优化篇</a><br>【7】<a href="">备战前端实习面试之计算机网络篇</a><br>【9】<a href="">备战前端实习面试之手写代码篇</a><br>【9】<a href="">备战前端实习面试之代码输出结果篇</a></p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="html-常用的标签"><a href="#html-常用的标签" class="headerlink" title="html 常用的标签"></a>html 常用的标签</h2><p><code>h</code> <code>p</code> <code>hr</code> <code>br</code> <code>div</code> <code>span</code> <code>ul li</code> <code>ol li</code> <code>img</code> <code>a</code> <code>input</code> <code>label</code> <code>textarea</code> <code>select</code> <code>form</code> <code>head</code> <code>nav</code> <code>footer</code> <code>article</code> <code>section</code> <code>aside</code> <code>audio</code> <code>video</code>  </p><h2 id="html-新特性"><a href="#html-新特性" class="headerlink" title="html 新特性"></a>html 新特性</h2><ol><li>语义化标签<br><code>header</code>、<code>footer</code>、<code>nav</code>、<code>article</code>、<code>aside</code>、<code>section</code>、<code>meau</code>、<code>template</code></li><li>新增媒体元素：<code>audio</code>、<code>video</code></li><li>用于绘画的 canvas 属性</li><li>新增本地存储方式：<code>sessionStorage</code>、 <code>localStorage</code></li><li>新的技术：<code>webworker</code>、<code>websocket</code></li><li>新增表单控件：<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li></ol><h2 id="对语义化的理解"><a href="#对语义化的理解" class="headerlink" title="对语义化的理解"></a>对语义化的理解</h2><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。</p><p><strong>好处：</strong></p><ul><li>对开发者友好，让人容易理解，利于代码可读性</li><li>对机器友好，让搜索引擎更容易读懂，利于 SEO</li></ul><h2 id="说说-web-worker"><a href="#说说-web-worker" class="headerlink" title="说说 web worker"></a>说说 web worker</h2><p><code>web worker</code> 的作用是为 JavaScript 创造多线程环境，允许主线程创建 <code>Worker 线程</code>，然后将一些任务分配给其运行。</p><p>在主线程运行的同时，Worker 线程在后台运行，两者互不干扰，等到 Worker 线程完成任务后就将结果返回给主线程。这样的好处是：一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程就会很流畅，不会被阻塞或拖慢（通过 <code>postMessage</code> 将结果传回到主线程即可）。</p><p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 <code>Worker</code> 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p><p>这里有几个注意点：</p><ol><li>同源限制<br>分配给 Worker 线程的脚本文件，必须和主线程脚本文件同源。</li><li>通信联系<br>Worker 线程和主线程不在同一个上下文环境，不能直接通信，必须通过消息完成。</li><li>DOM 限制<br>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 <code>document</code>、<code>window</code>、<code>parent</code> 这些对象。但是 Worker 线程可以使用 <code>navigator</code> 对象和 <code>location</code> 对象。</li><li>脚本限制<br>Worker 线程不能执行 <code>alert()</code> 方法和 <code>confirm()</code> 方法，但可以使用 <code>XMLHttpRequest</code> 对象发出 <code>AJAX</code> 请求。</li><li>文件限制<br>Worker 线程无法读取本地文件，即不能打开本机的文件系统，它所加载的脚本，必须来自于网络。</li></ol><blockquote><p><a href="https://www.ruanyifeng.com/blog/2018/07/web-worker.html">阮一峰：Web Worker 使用教程</a></p></blockquote><h2 id="DOCTYPE的作用？严格模式和混杂模式的区别？"><a href="#DOCTYPE的作用？严格模式和混杂模式的区别？" class="headerlink" title="DOCTYPE的作用？严格模式和混杂模式的区别？"></a>DOCTYPE的作用？严格模式和混杂模式的区别？</h2><p><code>!DOCTYPE</code> 告诉浏览器以 <code>HTML5</code> 标准解析页面，如果不写，则进入混杂模式</p><ul><li>严格模式（标准模式）：以 w3c 标准解析代码</li><li>混杂模式（怪异模式）：浏览器用自己的方式解析代码，混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作</li></ul><h2 id="常⽤的-meta-标签有哪些"><a href="#常⽤的-meta-标签有哪些" class="headerlink" title="常⽤的 meta 标签有哪些"></a>常⽤的 meta 标签有哪些</h2><p>meta 标签由 name 和 content 属性定义，用来描述网页文档的属性。<br>|属性|描述|值|例子|<br>|:–:|:–:|:–:|:–|<br>|charset|HTML文档的编码类型|utf-8<br>gb2312|<code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code>|<br>|keywords|页面关键词|自定义|<code>&lt;meta name=&quot;keywords&quot; content=&quot;关键词&quot; /&gt;</code>|<br>|description|页面描述|自定义|<code>&lt;meta name=&quot;description&quot; content=&quot;页面描述内容&quot; /&gt;</code>|<br>|refresh|页面重定向和刷新|自定义|<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</code>|<br>|viewport|适配移动端，可以控制视口的大小和比例|width viewport ：宽度(数值/device-width)<br>height viewport ：高度(数值/device-height)<br>initial-scale ：初始缩放比例<br>maximum-scale ：最大缩放比例<br>minimum-scale ：最小缩放比例<br>user-scalable ：是否允许用户缩放(yes/no）|<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code>|<br>|robots|搜索引擎索引方式|all：文件将被检索，且页面上的链接可以被查询；<br>none：文件将不被检索，且页面上的链接不可以被查询；<br>index：文件将被检索；<br>follow：页面上的链接可以被查询；<br>noindex：文件将不被检索；<br>nofollow：页面上的链接不可以被查询。|<code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</code>|</p><h2 id="iframe-有那些优点和缺点"><a href="#iframe-有那些优点和缺点" class="headerlink" title="iframe 有那些优点和缺点"></a>iframe 有那些优点和缺点</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。<br>优点：</p><ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本可以并行下载</li><li>可以实现跨子域通信</li></ul><p>缺点：</p><ul><li>iframe 会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎索识别</li><li>会产生很多页面，不容易管理</li></ul><h2 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别"></a>defer 和 async 的区别</h2><p>defer 和 async 都是 script 标签的属性。</p><p><strong>defer：</strong></p><ul><li>在 script 标签添加 defer 属性，就可以让这个 script 外联的 js 变成异步加载。当 html 解析过程中碰到这个 script ，就会开辟一个新线程来下载脚本（这个脚本的下载和 html 的解析是同步的），当脚本下载完毕后不会立即执行，而是等待 html 解析完毕后才开始执行。</li><li>所有 defer 的 js 代码都保证按顺序执行。</li></ul><p><strong>async：</strong></p><ul><li>在 script 标签添加 async 属性后，html 解析过程中碰到这个 script ，也会开辟新线程来同步下载脚本，下载完毕后会立即执行脚本，并中断 html 解析流程，等到脚本执行完之后再接着解析 html 。</li><li>async 的 js 代码不能保证按顺序执行，而是谁先下载完就先执行哪个脚本。</li></ul><h2 id="HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="HTML5的离线储存怎么使用，它的工作原理是什么"></a>HTML5的离线储存怎么使用，它的工作原理是什么</h2><p>离线存储指的是：在用户没有连接网络时，可以正常访问站点或应用，当连接上网络后，更新用户机器上的缓存文件。</p><p>原理：html5 的离线缓存是基于一个新建的 <code>.appcache</code> 文件的缓存机制，即通过这个文件上的解析清单 离线缓存资源。之后当网络在离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>使用方法：</p><ol><li>创建一个和 html 同名的 <code>.manifest</code> 文件，然后在页面头部插入 <code>manifest</code> 属性：<code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></li><li>在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：<pre class="line-numbers language-none"><code class="language-none">CACHE:  js&#x2F;app.js  css&#x2F;style.cssNETWORK:  resourse&#x2F;logo.pngFALLBACK:  &#x2F; &#x2F;offline.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li><li>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li></ul><ol start="3"><li>在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</li></ol><p>更新缓存的3种方案：</p><ul><li>更新 manifest 文件</li><li>通过 javascript 操作</li><li>清除浏览器缓存</li></ul><p>注意事项：<br>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。<br>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。<br>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。<br>（4）FALLBACK 中的资源必须和 manifest 文件同源。<br>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。<br>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p><h2 id="浏览器是如何对-HTML5-的离线储存资源进行管理和加载"><a href="#浏览器是如何对-HTML5-的离线储存资源进行管理和加载" class="headerlink" title="浏览器是如何对 HTML5 的离线储存资源进行管理和加载"></a>浏览器是如何对 HTML5 的离线储存资源进行管理和加载</h2><ul><li>在线情况下，浏览器发现 html 头部有 <code>manifest</code> 属性，它会请求 <code>.manifest</code> 文件，<strong>如果是第一次访问页面</strong>，那么浏览器就会根据 <code>.manifest</code> 文件的内容下载相应的资源并进行离线存储；<strong>如果已经访问过页面并进行过离线存储</strong>，那么浏览器会使用离线的资源加载页面，然后对比新旧 <code>.manifest</code> 文件，若文件发生改变就会重新下载文件中的资源并进行存储。</li><li>离线情况下，浏览器会直接使用离线存储的资源加载页面。</li></ul><h2 id="行内元素、块级元素，以及两者的区别"><a href="#行内元素、块级元素，以及两者的区别" class="headerlink" title="行内元素、块级元素，以及两者的区别"></a>行内元素、块级元素，以及两者的区别</h2><ol><li>行内元素有：<code>a</code>、 <code>br</code>、 <code>cite</code>、 <code>em</code>、 <code>i</code>、 <code>img</code>、 <code>input</code>、 <code>label</code>、 <code>select</code>、 <code>span</code>、 <code>strong</code>、 <code>sub</code>、 <code>sup</code>、 <code>textarea</code></li><li>块级元素有：<code>div</code>、<code>p</code>、<code>form</code>、<code>ul</code>、<code>ol</code>、<code>dl</code>、<code>h</code>、<code>hr</code>、<code>table</code>、<code>menu</code>、</li><li>区别：</li></ol><ul><li>块级元素独占一行，行内元素不会</li><li>块级元素可以设置宽高，行内元素不能</li><li>块级元素可以包含行内元素和块级元素，行内元素不能包含块级元素。</li><li>块级元素可以设置 <code>margin</code> 和 <code>padding</code> ，行内元素的水平方向的 <code>padding-left</code>、<code>padding-right</code>、<code>margin-left</code>、<code>margin-right</code> 都产生边距效果，但是竖直方向的 <code>padding-top</code>、<code>padding-bottom</code>、<code>margin-top</code>、<code>margin-bottom</code> 都不会产生边距效果。（水平方向有效，竖直方向无效）<blockquote><p>若是设置为行内块级元素，它也不能独占一行，但能设置宽高</p></blockquote></li></ul><h2 id="渐进增强、优雅降级，以及两者的区别"><a href="#渐进增强、优雅降级，以及两者的区别" class="headerlink" title="渐进增强、优雅降级，以及两者的区别"></a>渐进增强、优雅降级，以及两者的区别</h2><ol><li>渐进增强：针对低版本浏览器也能保证基础功能，然后对高级浏览器改进追加功能（向上兼容）。</li><li>优雅降级：一开始就构建站点的完整功能，然后针对浏览器进行测试和修复（向下兼容）。</li><li>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。</li></ol><h2 id="canvas-和-svg-的区别"><a href="#canvas-和-svg-的区别" class="headerlink" title="canvas 和 svg 的区别"></a>canvas 和 svg 的区别</h2><ul><li>canvas是画布，适合图形密集型的游戏，不支持事件处理</li><li>svg是矢量图，不依赖分辨率，不适合游戏，适合大型渲染区域（地图），支持事件处理</li></ul><h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><ul><li>src 是引入外部资源下载到文档，会暂停其他资源的下载</li><li>href  是链接外部资源，不会暂停其他资源的下载</li></ul><h2 id="label-的作用"><a href="#label-的作用" class="headerlink" title="label 的作用"></a>label 的作用</h2><p><code>label</code> 标签为 input 元素定义标注。</p><p>作用：用于绑定一个表单元素，当点击 <code>label</code> 标签的时候，被绑定的表单元素就会获得输入焦点。</p><h2 id="title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别"><a href="#title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别" class="headerlink" title="title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别"></a>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别</h2><p><code>title</code> 属性没有明确意义只表示是个标题，<code>h1</code> 则表示层次明确的标题。<br><code>strong</code> 标签有语义，是起到加重语气的效果，而 <code>b</code> 标签是没有的。虽然都能加粗字体，但搜索引擎更侧重 <code>strong</code> 标签。<br><code>i</code> 内容展示为斜体，<code>em</code> 表示强调的文本</p>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 实习面试 </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环（Event Loop）</title>
      <link href="/2022/03/01/shi-jian-xun-huan-event-loop/"/>
      <url>/2022/03/01/shi-jian-xun-huan-event-loop/</url>
      
        <content type="html"><![CDATA[<h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><p>Task Queue</p><ul><li>常见宏任务：setTimeout、setInterval、setImmediate、I/O、script、UI rendering</li></ul><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>Job Queue</p><ul><li>常见微任务：<ul><li>浏览器：Promise、MutationObserver</li><li>Node.js：process.nextTick</li></ul></li></ul><h2 id="执行顺序（有异议）"><a href="#执行顺序（有异议）" class="headerlink" title="执行顺序（有异议）"></a>执行顺序（有异议）</h2><ul><li>首先执行同步代码，宏任务</li><li>同步栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>执行完，是否需要渲染页面</li><li>重新开始 Event Loop，执行宏任务中的异步代码</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端必须知道的开发调试知识</title>
      <link href="/2022/01/22/qian-duan-bi-xu-zhi-dao-de-kai-fa-diao-shi-zhi-shi/"/>
      <url>/2022/01/22/qian-duan-bi-xu-zhi-dao-de-kai-fa-diao-shi-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器控制台面板"><a href="#浏览器控制台面板" class="headerlink" title="浏览器控制台面板"></a>浏览器控制台面板</h2><p>浏览器的控制台有很多可供开发者 debug 的功能，在如下图片红色框中可以看到有多个面板各司其职，开发人员可以根据自己的实际情况在相应的板块进行调试<br><img src="https://s4.ax1x.com/2022/01/23/749WDO.png" alt="浏览器控制台面板"></p><h3 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h3><p>动态修改元素和样式</p><ul><li>点击 <code>.cls</code> 动态修改元素的 <code>class</code> ，输入字符串可以动态的给元素添加类名，勾选/取消类名可以动态的查看类名生效效果 <img src="https://s4.ax1x.com/2022/01/22/7hb98e.png" alt=".cls 修改样式"></li><li>点击具体的样式值（字号、颜色、宽度高度等）可以进行编辑，浏览器内容区域可以实时预览 <img src="https://s4.ax1x.com/2022/01/22/7hbVVP.png" alt="修改样式值"></li><li><code>Computed</code> 下点击样式里的箭头可以跳转到 <code>styles</code> 面板中的 css 规则 <img src="https://s4.ax1x.com/2022/01/22/7hbFKA.png" alt="定位 css 规则"></li><li>可以用以下 2 种方式强制激活伪类：<ul><li>选中具有伪类的元素，点击 <code>:hov</code> <img src="https://s4.ax1x.com/2022/01/22/7hbPvd.png" alt=":hov 进行固定"></li><li>DOM 树右键菜单，选择 <code>Force State</code><h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><pre class="line-numbers language-none"><code class="language-none">console.logconsole.warnconsole.errorconsole.debugconsole.infoconsole.table：更加直观的展示 JSON 和数组数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看到共有 6 种打印方式<img src="https://s4.ax1x.com/2022/01/22/7hHXHx.png" alt="6 种打印方式">，并且在 <code>Console</code> 面板的左侧可以选择等级，对日志进行分类查看（如果找不到左侧的分类，则是因为被隐藏了，点击按钮打开即可<img src="https://s4.ax1x.com/2022/01/22/7hbe58.png" alt="打印 Console 左侧面板">）</li></ul></li></ul><p>值得一提的是 <code>console.table</code> ，该打印可以直观的展示 JSON 和数组数据，如图：<img src="https://s4.ax1x.com/2022/01/22/7hba24.png" alt="console.table"></p><p>由于打印字体在未经样式设置时是统一的，如果想醒目的查看的打印信息，可以通过占位符的方式修改打印信息以达到目的，先看看都有什么占位符：</p><pre class="line-numbers language-none"><code class="language-none">%s：字符串占位符；%o：对象占位符；%c：样式占位符；%d：数字占位符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么通过一个例子来看看怎么使用这些占位符，帮助我们在开始过程中更加快速的查看打印信息：<br><img src="https://s4.ax1x.com/2022/01/22/7hbGV0.png" alt="占位符例子"></p><h3 id="Sorce"><a href="#Sorce" class="headerlink" title="Sorce"></a>Sorce</h3><p><img src="https://s4.ax1x.com/2022/01/22/7hbvss.png" alt="Sorce 面板概览"></p><ul><li>区域①：页面资源文件目录树</li><li>区域②：代码预览区域</li><li>区域③：Debug 工具栏，从左到右依次为<ul><li>暂停（继续）</li><li>单步跳过</li><li>进入函数</li><li>跳出函数</li><li>单步执行</li><li>激活（关闭）所有断点</li><li>代码执行异常处自动断点</li></ul></li><li>区域④：断点调试器</li></ul><h4 id="Break-Points-与-Watch"><a href="#Break-Points-与-Watch" class="headerlink" title="Break Points 与 Watch"></a>Break Points 与 Watch</h4><p><img src="https://s4.ax1x.com/2022/01/23/74SFKO.png" alt="Break Points 与 Watch"></p><ul><li>在本地代码中使用关键字 <code>debugger</code> 或在代码预览区域的行号设置断点</li><li>执行到断点处时代码暂停执行</li><li>展开 <code>Breakpoints</code> 列表可以查看断点列表，勾选/取消可以激活/禁用对应断点</li><li>暂停状态下，鼠标 hover 变量可以查看变量的值</li><li>在调试器 <code>Watch</code> 右侧点击 + 可以添加对变量的监控，查看该变量的值<h4 id="Scope-与-Call-Stack"><a href="#Scope-与-Call-Stack" class="headerlink" title="Scope 与 Call Stack"></a>Scope 与 Call Stack</h4><img src="https://s4.ax1x.com/2022/01/23/74SlM8.png" alt="Scope 与 Call Stack"></li><li>展开 <code>Scope</code> 可以查看作用域列表（包含闭包）</li><li>展开 <code>Call Stack</code> 可以查看当前 JavaScript 代码的调用栈<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><img src="https://s4.ax1x.com/2022/01/23/74SjQf.png" alt="Performance 面板概览"></li><li>区域①：控制面板</li><li>区域②：概览面板<ul><li>FPS：每秒帧数</li><li>CPU：处理各个任务花费的时间</li><li>NET：各个请求花费的时间</li></ul></li><li>区域③：线程面板<ul><li>Frames：帧线程</li><li>Main：主线程，负责执行 JavaScript ，解析 HTML/CSS ，完成绘制</li><li>Raster：Raster 线程，负责完成某个 layer 或者某些块（tile）的绘制</li></ul></li><li>区域④：统计面板<h3 id="NetWork"><a href="#NetWork" class="headerlink" title="NetWork"></a>NetWork</h3><img src="https://s4.ax1x.com/2022/01/23/74pyX8.png" alt="NetWork 面板概览"></li><li>区域①：控制面板</li><li>区域②：过滤面板</li><li>区域③：概览区域</li><li>区域④：Request Table 面板</li><li>区域⑤：总结面板</li><li>区域⑥：请求详情面板<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><img src="https://s4.ax1x.com/2022/01/23/74pz1x.png" alt="Application 面板概览"><br>Application 面板展示与本地存储相关的信息</li><li>Local Storage</li><li>Session Storage</li><li>IndexedDB</li><li>Web SQL</li><li>Cookie</li></ul><p>点击左侧 <code>Application</code> 下的 <code>Stroage</code> 面板中的 <code>Clear Site Data</code> 可以清除网页的本地存储数据</p><h2 id="常用开发调试技巧"><a href="#常用开发调试技巧" class="headerlink" title="常用开发调试技巧"></a>常用开发调试技巧</h2><h3 id="线上即时修改-Overrides"><a href="#线上即时修改-Overrides" class="headerlink" title="线上即时修改 Overrides"></a>线上即时修改 Overrides</h3><ol><li>打开 <code>Sources</code> 面板下的 <code>Overrides</code></li><li>点击 <code>Select folders for Overrides</code> 。选择一个本地的空文件夹目录<br><img src="https://s4.ax1x.com/2022/01/23/74PU7F.png" alt="选择保存修改的文件夹"></li><li>允许授权</li><li>在 <code>page</code> 中修改代码，修改完成后 <code>command + s</code> 保存</li><li>打开 DevTools ，点击右上角的三个小点 -&gt; More tools -&gt; Changes ，就能看到所有修改了（红色代表修改前，绿色代表修改后）<br><img src="https://s4.ax1x.com/2022/01/23/74PXNQ.png" alt="对比更改后的代码"><h3 id="利用代理解决开发阶段的跨域问题"><a href="#利用代理解决开发阶段的跨域问题" class="headerlink" title="利用代理解决开发阶段的跨域问题"></a>利用代理解决开发阶段的跨域问题</h3>常见的有通过 <code>nginx</code> 来进行代理<h3 id="启动本地-source-map"><a href="#启动本地-source-map" class="headerlink" title="启动本地 source map"></a>启动本地 source map</h3>线上不存在 <code>Source Map</code> 时可以使用 <code>Map Local</code> 网络映射功能来访问本地的 <code>Source Map</code> 文件<h3 id="小黄鸭调试大法"><a href="#小黄鸭调试大法" class="headerlink" title="小黄鸭调试大法"></a>小黄鸭调试大法</h3>传说中程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向小黄鸭解释每行代码，然后很快就将问题定位修复了 –《程序员修炼之道》</li></ol>]]></content>
      
      
      <categories>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器控制台 </tag>
            
            <tag> 开发调试技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 新特性</title>
      <link href="/2022/01/22/css3-xin-te-xing/"/>
      <url>/2022/01/22/css3-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h2><ol><li>过渡<br>transition： <code>transition-property</code>【CSS属性】，<code>transition-duration</code>【花费时间】，<code>transition-timing-function</code>【效果曲线（默认ease）】，<code>transition-delay</code>【延迟时间（默认0）】。</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css">// 连写（可以省略后面的两个参数）：transition：width<span class="token punctuation">,</span> 5s<span class="token punctuation">,</span> ease<span class="token punctuation">,</span> 2s<span class="token property">transition-property</span><span class="token punctuation">:</span> width<span class="token punctuation">;</span><span class="token property">transition-duration</span><span class="token punctuation">:</span> 1s<span class="token punctuation">;</span><span class="token property">transition-timing-function</span><span class="token punctuation">:</span> linear<span class="token punctuation">;</span><span class="token property">transition-delay</span><span class="token punctuation">:</span> 2s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>transition-timing-function 的参数：<br>|值|描述|<br>|:–|:–|<br>|linear|匀速（等于 cubic-bezier(0,0,1,1)）|<br>|ease|逐渐变慢（cubic-bezier(0.25,0.1,0.25,1)）|<br>|ease-in|加速（等于 cubic-bezier(0.42,0,1,1)）|<br>|ease-out|减速（等于 cubic-bezier(0,0,0.58,1)）|<br>|ease-in-out|先加速后减速（等于 cubic-bezier(0.42,0,0.58,1)）|<br>|cubic-bezier(n,n,n,n)|在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值|<br>2. 动画<br>①animation：<code>animation-name</code>【动画名称】，<code>animation-duration</code>【一个周期花费时间】，<code>animation-timing-function</code>【运动曲线（默认ease）】，<code>animation-delay</code>【动画延迟（默认0）】，<br><code>animation-fill-mode</code>，<code>animation-direction</code>【是否反向播放动画（默认normal）】，<code>animation-iteration-count</code>【播放次数（默认1）】，<code>animation-play-state</code>【是否暂停动画（默认 running ）】<br>②告诉系统外面需要自己创建一个名称叫做xxx的动画</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@keyframes</span> 动画名称</span> <span class="token punctuation">&#123;</span>    <span class="token selector">from</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">to</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>animation-name</code>    规定动画的名称。由大小写敏感的字母a-z、数字0-9、下划线（_）和 <code>/</code> 或横线（-）组成。<em>第一个非横线字符必须是字母，数字不能在字母前面，不允许两个横线出现在开始位置</em>  </li><li><code>animation-duration</code>    规定动画完成一个周期所花费的秒或毫秒。默认是 0 ，表示无动画。  </li><li><code>animation-timing-function</code>    规定动画的速度曲线。默认是 “ease”。可选参数如下： </li></ul><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">linear</td><td align="left">动画从头到尾的速度是相同的。</td></tr><tr><td align="left">ease</td><td align="left">默认。动画以低速开始，然后加快，在结束前变慢。</td></tr><tr><td align="left">ease-in</td><td align="left">动画以低速开始。</td></tr><tr><td align="left">ease-out</td><td align="left">动画以低速结束。</td></tr><tr><td align="left">ease-in-out</td><td align="left">动画以低速开始和结束。</td></tr><tr><td align="left">cubic-bezier(n,n,n,n)</td><td align="left">在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li><code>animation-delay</code>    规定动画何时开始。默认是 0。  </li><li><code>animation-fill-mode</code>    规定对象动画在执行之前和之后如何将样式应用于其目标。可选参数如下：</li></ul><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">none</td><td align="left">默认状态，回到动画没开始时的状态。</td></tr><tr><td align="left">forwards</td><td align="left">让动画停留在结束状态。</td></tr><tr><td align="left">backwards</td><td align="left">让动画回到第一帧的状态。</td></tr><tr><td align="left">both</td><td align="left">向前和向后填充模式都被应用。</td></tr></tbody></table><ul><li><p><code>animation-direction</code>    规定动画是否在下一周期逆向地播放。默认是 “normal”。可选参数如下：</p></li><li><p>normal    默认值。动画正常播放。    </p></li><li><p>alternate    动画轮流反向播放。</p></li><li><p>reverse 动画反向播放。</p></li><li><p>alternate-reverse 动画反向轮流播放。<br>效果如图：<img src="https://s4.ax1x.com/2022/01/23/74ynDH.png" alt="animation-direction 参数效果"></p></li><li><p><code>animation-iteration-count</code> 规定动画被播放的次数。默认是 1。无限播放则是 infinite  </p></li><li><p><code>animation-play-state</code>    规定动画是否正在运行或暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。默认是 “running”。可选参数如下：</p></li></ul><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">paused</td><td align="left">规定动画已暂停。</td></tr><tr><td align="left">running</td><td align="left">规定动画正在播放。</td></tr><tr><td align="left">inherit</td><td align="left">/</td></tr><tr><td align="left">initial</td><td align="left">/</td></tr><tr><td align="left">unset</td><td align="left">/</td></tr></tbody></table><ol start="3"><li>形状转换  </li></ol><ul><li>transform-origin    定义形变点的位置。</li><li>2D transform 方法<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token function">translate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>定义 2D 转换，沿着 X 和 Y 轴移动元素。    <span class="token function">translateX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>定义 2D 转换，沿着 X 轴移动元素。    <span class="token function">translateY</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>定义 2D 转换，沿着 Y 轴移动元素。<span class="token function">rotate</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>定义 2D 旋转，在参数中规定角度，参数为数值、单位 deg。<span class="token function">scale</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>定义 2D 缩放转换，改变元素的宽度和高度，参数为数值、无单位。    <span class="token function">scaleX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>定义 2D 缩放转换，改变元素的宽度。    <span class="token function">scaleY</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>定义 2D 缩放转换，改变元素的高度。<span class="token function">matrix</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span>定义 2D 转换，使用六个值的矩阵。<span class="token function">skew</span><span class="token punctuation">(</span>x-angle<span class="token punctuation">,</span>y-angle<span class="token punctuation">)</span>定义 2D 倾斜转换，沿着 X 和 Y 轴，参数为数值、单位 deg。    <span class="token function">skewX</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>定义 2D 倾斜转换，沿着 X 轴。    <span class="token function">skewY</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>定义 2D 倾斜转换，沿着 Y 轴。x-axis定义视图被置于 X 轴的何处。可能的值：left，center，right，length，%y-axis定义视图被置于 Y 轴的何处。可能的值：top，center，bottom，length，%z-axis定义视图被置于 Z 轴的何处。可能的值：length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>3D Transform 方法<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token function">matrix3d</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span>定义 3D 转换，使用 16 个值的 4x4 矩阵。<span class="token function">translate3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>定义 3D 转化。    <span class="token function">translateX</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>定义 3D 转化，仅使用用于 X 轴的值。    <span class="token function">translateY</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>定义 3D 转化，仅使用用于 Y 轴的值。    <span class="token function">translateZ</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>定义 3D 转化，仅使用用于 Z 轴的值。<span class="token function">scale3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>定义 3D 缩放转换。    <span class="token function">scaleX</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>定义 3D 缩放转换，通过给定一个 X 轴的值。    <span class="token function">scaleY</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>定义 3D 缩放转换，通过给定一个 Y 轴的值。    <span class="token function">scaleZ</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>定义 3D 缩放转换，通过给定一个 Z 轴的值。<span class="token function">rotate3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">,</span>angle<span class="token punctuation">)</span>定义 3D 旋转。    <span class="token function">rotateX</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>定义沿 X 轴的 3D 旋转。    <span class="token function">rotateY</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>定义沿 Y 轴的 3D 旋转。    <span class="token function">rotateZ</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>定义沿 Z 轴的 3D 旋转。<span class="token function">perspective</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>定义 3D 转换元素的透视视图。x-axis定义视图被置于 X 轴的何处。可能的值：left，center，right，length，%y-axis定义视图被置于 Y 轴的何处。可能的值：top，center，bottom，length，%z-axis定义视图被置于 Z 轴的何处。可能的值：lengthtransform-style规定被嵌套元素如何在 3D 空间中显示。    flat子元素将不保留其 3D 位置。    preserve-3d子元素将保留其 3D 位置。perspective规定 3D 元素的透视效果（近大远小）。    number元素距离视图的距离，以像素计。    none默认值。与 0 相同。不设置透视。perspective-origin规定 3D 元素的底部位置。    x-axis定义该视图在 x 轴上的位置。默认值：50%。可能的值：left，center，right，length，%    y-axis定义该视图在 y 轴上的位置。默认值：50%。可能的值：top，center，bottom，length，%backface-visibility定义元素在不面对屏幕时是否可见。    visible背面是可见的。    hidden背面是不可见的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="4"><li><p>阴影<br><code>box-shadow</code>：水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里）;</p></li><li><p>边框图片<br><code>border-image</code>：图片url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认0） 铺满方式–重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch））;</p></li><li><p>边框圆角<br><code>border-radius</code>：左上角，右上角，右下角，左下角;</p></li><li><p>背景  </p></li></ol><ul><li><code>background-clip</code> 规定背景的绘制区域         <ul><li>border-box    背景被裁剪到边框盒。</li><li>padding-box    背景被裁剪到内边距框。</li><li>content-box    背景被裁剪到内容框。</li></ul></li><li><code>background-origin</code>    <ul><li>padding-box    背景图像相对于内边距框来定位。    </li><li>border-box    背景图像相对于边框盒来定位。</li><li>content-box    背景图像相对于内容框来定位。</li></ul></li><li><code>background-size</code><ul><li>length    设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。</li><li>percentage    以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。</li><li>cover    把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</li><li>contain    把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</li></ul></li></ul><ol start="8"><li><p>反射<br><code>-webkit-box-reflect</code>：方向【above-上 | below-下 | right-右 | left-左】，偏移量，遮罩图片</p></li><li><p>文字阴影<br><code>text-shadow</code>：水平阴影，垂直阴影，模糊的距离，以及阴影的颜色</p></li><li><p>颜色<br><code>rgba</code>（rgb为颜色值，a为透明度）<br><code>hsla</code>（h：色相”，“s：饱和度”，“l：亮度”，“a：透明度”）</p></li><li><p>渐变</p></li><li><p>Filter（滤镜）</p></li></ol><ul><li>黑白色 filter: grayscale(100%)</li><li>褐色 filter:sepia(1)</li><li>饱和度 saturate(2)</li><li>色相旋转 hue-rotate(90deg)</li><li>反色 filter:invert(1)</li><li>透明度 opacity(.5)</li><li>亮度 brightness(.5)</li><li>对比度 contrast(2)</li><li>模糊 blur(3px)</li><li>阴影 drop-shadow(5px 5px 5px #000)</li></ul><ol start="13"><li><p>混合模式  </p><ul><li>background-blend-mode（用于同一个元素的背景图片和背景颜色）<ul><li>multiply 正片叠底</li><li>screen 滤色</li><li>overlay 叠加</li><li>darken 变暗</li><li>lighten 变亮</li><li>color-dodge 颜色减淡模式</li><li>color-burn 颜色加深</li><li>hard-light 强光</li><li>soft-light 柔光</li><li>difference 差值</li><li>exclusion 排除</li><li>hue 色相</li><li>saturation 饱和度</li><li>color 颜色</li><li>luminosity 亮度</li></ul></li><li>mix-blend-mode（用于一个元素的背景图片或者颜色和子元素）<ul><li>数值同 background-blend-mode</li></ul></li></ul></li><li><p>多列布局  </p><ul><li><p>加上私有前缀，兼容</p><ul><li>-webkit- （谷歌，Safari，新版Opera浏览器，以及几乎所有iOS系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于WebKit 内核的浏览器）</li><li>-moz- （火狐浏览器）</li><li>-o- （旧版Opera浏览器）</li><li>-ms- （IE浏览器 和 Edge浏览器）</li></ul></li><li><p>column-count    规定元素应该被分隔的列数。</p></li><li><p>column-fill    规定如何填充列。</p></li><li><p>column-gap    规定列之间的间隔。</p></li><li><p>column-rule    设置所有 column-rule-* 属性的简写属性。</p></li><li><p>column-rule-color    规定列之间规则的颜色。</p></li><li><p>column-rule-style    规定列之间规则的样式</p></li><li><p>column-rule-width    规定列之间规则的宽度。</p></li><li><p>column-span    规定元素应该横跨的列数。</p></li><li><p>column-width    规定列的宽度。</p></li><li><p>columns    规定设置 column-width 和 column-count 的简写属性</p></li></ul></li><li><p>媒体查询<br>语法：@media 媒体类型 and （媒体特性）{你的样式}</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>600px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span>900px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    <span class="token selector">body</span> <span class="token punctuation">&#123;</span><span class="token property">background-color</span><span class="token punctuation">:</span>#f5f5f5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>not关键词<ul><li>使用关键词“not”是用来排除某种制定的媒体类型，也就是用来排除符合表达式的设备。换句话说，not关键词表示对后面的表达式执行取反操作，如：  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token keyword">not</span> print <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>1200px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    样式代码<span class="token punctuation">&#125;</span>// 上面代码表示的是：样式代码将被使用在除打印设备和设备宽度小于1200px下的所有设备中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>only关键词<ul><li><a href="https://www.jianshu.com/p/927790abdd80">媒体查询使用方法@media</a></li></ul></li><li>媒体类型<ul><li>all    用于所有媒体类型设备。</li><li>print    用于打印机。</li><li>screen    用于计算机屏幕、平板电脑、智能手机等等。</li><li>speech    用于大声“读出”页面的屏幕阅读器。</li></ul></li><li>媒体特性<ul><li>如果是横屏landscape、竖屏portrait，则语法：orientation：portrait | landscape  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token keyword">only</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">orientation</span><span class="token punctuation">:</span>landscape<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    <span class="token selector">body</span> <span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>lightblue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>但与CSS属性不同的是，媒体特性是通过min/max来表示大于等于或小于做为逻辑判断，而不是使用小于（&lt;）和大于（&gt;）这样的符号来判断<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span>480px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    <span class="token selector">.ads</span><span class="token punctuation">&#123;</span>        <span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>上面代码表示的是：当屏幕小于或等于480px时，页面中的广告区块（.ads）都讲被隐藏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>更复杂的媒体查询</li></ul></li><li>媒体查询中的“与”逻辑  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>400px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">orientation</span><span class="token punctuation">:</span>landscape<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    <span class="token selector">body</span><span class="token punctuation">&#123;</span>        <span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>媒体查询中的“或”逻辑  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>400px<span class="token punctuation">)</span><span class="token punctuation">,</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">orientation</span><span class="token punctuation">:</span>landscape<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>    <span class="token selector">body</span><span class="token punctuation">&#123;</span>        <span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>媒体查询中的“非”逻辑可以用not操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。<pre><code class="css">@media not all and (orientation:landscape) &#123;    body&#123;        color:blue;    &#125;&#125;</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 盒模型</title>
      <link href="/2022/01/11/css-he-mo-xing/"/>
      <url>/2022/01/11/css-he-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>盒模型又称框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。它有两种分类，分别是<strong>标准模型</strong>和 <strong>IE 模型</strong>。</p><h2 id="标准模型和-IE-模型的区别"><a href="#标准模型和-IE-模型的区别" class="headerlink" title="标准模型和 IE 模型的区别"></a>标准模型和 IE 模型的区别</h2><p>IE模型和标准模型唯一的区别是内容计算方式的不同：</p><ul><li>IE 模型元素宽度 <code>width = content + padding + border</code> ，高度计算相同</li><li>标准模型元素宽度 <code>width = content</code> ，高度计算相同</li></ul><p>通过两幅图可以直观了解到区别所在：<br><img src="https://s4.ax1x.com/2022/01/11/7mF13T.png" alt="IE 模型"><br><img src="https://s4.ax1x.com/2022/01/11/7mFlCV.png" alt="标准模型"></p><h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>盒模型分为两种，那么问题来了，是什么因素让浏览器决定使用哪一种盒模型来渲染页面呢？<br>有两种解决方案：</p><ul><li>编写 html 文件时，我们可以在其头部第一行看见这样的代码 <code>&lt;!DOCTYPE html &gt;</code> ，这个是文档类型声明，只要浏览器看到这行代码就会用标准盒模型来渲染页面；如果没有这行代码，各个浏览器就会按照自己的标准去使用不同的盒模型来渲染。</li><li>通过文档声明的方式来渲染可以实现我们的目的，但是很被动。CSS3 给出了一种解决方法：<code>box-sizing</code> ，通过设置这个属性，就可以指定某种盒模型来渲染页面。<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2>通过 css3 新增的属性 <code>box-sizing: content-box | border-box |  inherit</code> 分别设置盒模型为<strong>标准模型（content-box）</strong> 和 <strong>IE 模型（border-box）</strong>。</li><li>content-box：盒子宽高是 <code>content(内容)</code> 的宽高  </li><li>border-box：盒子宽高是 <code>border + padding + content</code> 的宽高。</li><li>inherit：规定应从父元素继承 <code>box-sizing</code> 属性的值。<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2></li></ul><ol><li>在解释什么是BFC之前，我们需要先知道Box、Formatting Context的概念：</li></ol><ul><li>Formatting Context<br>它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</li><li>Box：css布局的基本单位<br>直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。有三种盒子：<ul><li>block-level box：display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li><li>inline-level box：display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li><li>run-in box: css3 中才有</li></ul></li></ul><ol start="2"><li>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</li><li>BFC的布局规则</li></ol><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ul><ol start="4"><li>如何创建BFC<ul><li>根元素或包含根元素的元素，如<code>&lt;html&gt;</code></li><li> 浮动元素（元素的 float 不是 none）</li><li> 绝对定位元素（元素的 position 为 absolute 或 fixed）</li><li> 行内块元素（元素的 display 为 inline-block）</li><li> 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li><li> 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li><li> 匿名表格单元格元素【元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table】</li><li>  overflow 值不为 visible 的块元素</li><li>  display 值为 <a href="https://drafts.csswg.org/css-display/#valdef-display-flow-root">flow-root</a> 的元素</li><li>  contain 值为 layout、content或 strict 的元素</li><li> 弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li><li> 网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li><li> 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li><li>  column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li></ul></li><li>BFC的作用<ul><li>利用BFC避免margin重叠。</li><li>阻止元素被浮动元素覆盖 -&gt; 可应用于自适应两栏布局（避免右侧与左侧发生重叠)</li><li>清除浮动<br>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。这个时候我们根据最后一条规则：计算BFC的高度时，浮动元素也参与计算。于是给父节点激活BFC</li></ul></li><li>举个栗子</li></ol><p>页面布局如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>页面样式如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.left</span> <span class="token punctuation">&#123;</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.right</span> <span class="token punctuation">&#123;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>页面效果如图：<img src="https://s4.ax1x.com/2022/01/11/7ms2ef.png" alt="未设置 BFC 之前"><br>我们看到图片中蓝色块因为浮动叠在了绿色块上面，如果我们的需求是不让这两者发生重叠，解决方法可以是对绿色块启动 BFC ，即在 .right 元素中添加 <code>overflow:hidden</code> （其他启动 BFC 的样式也可），这时就可以看到效果如图：<img src="https://s4.ax1x.com/2022/01/11/7myT4e.png" alt="设置 BFC 之后"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器</title>
      <link href="/2022/01/11/css-xuan-ze-qi/"/>
      <url>/2022/01/11/css-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><ol><li>关于css属性选择器常用的有以下这些：<pre class="line-numbers language-css" data-language="css"><code class="language-css">id选择器（#box） -->选择id为box的元素类选择器（.one） -->选择类名为one的所有元素标签选择器（div） -->选择标签为div的所有元素后代选择器（#box div） -->选择id为box元素内部所有的div元素子选择器（.one>one_1） -->选择父元素为.one的所有.one_1的元素相邻兄弟选择器（.one+.two） -->选择紧接在.one之后的所有.two元素交集选择器（div.one） -->选择类名为one的所有div元素并集选择器（div<span class="token punctuation">,</span>p） -->选择所有div和p元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>还有一些使用频率相对没那么多的选择器：</li></ol><ul><li>伪类选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span>link ：选择未被访问的链接<span class="token punctuation">:</span><span class="token property">visited：选取已被访问的链接</span><span class="token punctuation">:</span><span class="token property">active：选择活动链接</span><span class="token punctuation">:</span>hover ：鼠标指针浮动在上面的元素<span class="token punctuation">:</span>focus ：选择具有焦点的<span class="token punctuation">:</span>first-child：同级别中的第一个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>伪元素选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span><span class="token punctuation">:</span>first-letter ：用于选取指定选择器的首字母<span class="token punctuation">:</span><span class="token punctuation">:</span>first-line ：选取指定选择器的首行<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">before</span> <span class="token punctuation">:</span> 选择器在被选元素的内容前面插入内容<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">after</span> <span class="token punctuation">:</span> 选择器在被选元素的内容后面插入内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>属性选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css">[attribute] 选择带有attribute属性的元素[attribute=value] 选择所有使用attribute=value的元素[attribute~=value] 选择attribute属性包含value的元素[attribute|=value]：选择attribute属性以value开头的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="3"><li>在CSS3中新增的选择器还有：</li></ol><ul><li>通用兄弟选择器（p~ul），选择p元素下的所有ul元素</li><li>结构化伪类选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span>last-child 同级别中的最后一个标签<span class="token punctuation">:</span><span class="token function">nth-child</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 同级别中的第n个元素<span class="token punctuation">:</span><span class="token function">nth-child</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span> <span class="token property">同级别中的所有奇数</span><span class="token punctuation">:</span><span class="token function">nth-child</span><span class="token punctuation">(</span>even<span class="token punctuation">)</span> <span class="token property">同级别中的所有偶数</span><span class="token punctuation">:</span>only-child <span class="token property">父元素中唯一的标签</span><span class="token punctuation">:</span>first-of-type 同级别中同类型的第一个元素<span class="token punctuation">:</span>last-of-type 同级别中同类型的最后一个元素<span class="token punctuation">:</span><span class="token function">nth-of-type</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 同级别中同类型的第n个元素<span class="token punctuation">:</span><span class="token function">nth-last-of-type</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 同级别中同类型的倒数第n个元素<span class="token punctuation">:</span>only-of-type  <span class="token property">父元素中唯一的同类型的标签</span><span class="token punctuation">:</span>root 设置HTML文档<span class="token punctuation">:</span>empty 指定空的元素<span class="token punctuation">:</span>enabled 选择被禁用元素<span class="token punctuation">:</span>disabled 选择被禁用元素<span class="token punctuation">:</span>checked 选择选中的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>属性选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css">[attribute|=value]：选择attribute属性开头为value，且value是被-或其他内容隔开的所有元素[attribute^=value]：选择attribute属性开头为value的所有元素，无论value会不会被-隔开[attribute$=value]：选择attribute属性结尾为value的所有元素[attribute~=value]：选择attribute属性值包含value，且value被空格隔开的所有元素[attribute*=value]：选择attribute属性值包含value的所有元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="CSS-三大特性"><a href="#CSS-三大特性" class="headerlink" title="CSS 三大特性"></a>CSS 三大特性</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性。在 CSS 的继承中，不仅仅是儿子可以继承，只要是后代都可以继承。</p><ol><li>可继承的属性</li></ol><ul><li>所有元素可以继承的属性：<ul><li>元素可见性：<code>visibility</code></li><li>光标属性：<code>cursor：箭头可以变成需要的形状</code></li></ul></li><li>内联元素可以继承的属性：<ul><li>字体系列属性  <pre class="line-numbers language-css" data-language="css"><code class="language-css">font：组合字体font-family：字体系列font-weight：字体的粗细font-size：字体的大小font-style：字体的风格font-variant：偏大或偏小的字体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>文本系列属性  <pre class="line-numbers language-css" data-language="css"><code class="language-css">text-indent：文本缩进text-align：文本水平line-height：行高word-spacing：单词之间的间距letter-spacing：中文或者字母之间的间距text-transform：控制文本大小写direction：规定文本的书写方向color：文本颜色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>表格布局属性  <pre class="line-numbers language-css" data-language="css"><code class="language-css">caption-side：定位表格标题位置border-collapse：合并表格边框border-spacing：设置相邻单元格的边框间的距离empty-cells：单元格的边框的出现与消失table-layout：表格的宽度由什么决定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>列表属性<pre class="line-numbers language-css" data-language="css"><code class="language-css">list-style-type：文字前面的小点点样式list-style-position：小点点位置list-style：以上的属性可通过这属性集合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>引用：<code>quotes：设置嵌套引用的引号类型</code></li></ul></li></ul><ol start="2"><li>不可继承的属性</li></ol><ul><li>a 标签的字体颜色</li><li>h 标签字体的大小</li><li>display：规定元素应该生成的框的类型</li><li>文本属性：<ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul></li><li>盒子模型的属性：width、height、margin、border、padding</li><li>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li>生成内容属性：content、counter-reset、counter-increment</li><li>轮廓样式属性：outline-style、outline-width、outline-color、outline</li><li>页面样式属性：size、page-break-before、page-break-after</li><li>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ul><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>层叠性就是 CSS 处理冲突的一种能力。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>什么是优先级：当多个选择器选中同一个标签，并且给同一个标签设置相同的属性时，如何层叠就由优先级来确定。</p><p>优先级判断的3种方式：</p><ol><li>是否是直接选中（间接选中就是值继承）</li></ol><ul><li>如果是间接选中，那么就是谁离目标标签比较近就听谁的</li></ul><ol start="2"><li>相同选择器（直接选中）</li></ol><ul><li>如果都是直接选中，并且都是同类型的选择器，那么就是谁写在后面就听谁的</li></ul><ol start="3"><li>不同选择器（直接选中）</li></ol><ul><li>如果都是直接选中，并且不是相同类型的选择器，那么就会按照选择器的优先级来层叠：【!important &gt;】内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器【&gt; 通配符 &gt; 继承 &gt; 浏览器默认属性】</li></ul><p>如果是多个选择器混合在一起使用，就需要计算权重。<br>权重的计算规则：</p><ol><li>首先计算选择器中有多少个 id ，id 多的选择器优先级最高</li><li>如果 id 的个数一样，那么再看类名的个数，类名个数多的优先级最高</li><li>如果这两者的个数都一样，同时标签名称个数也一样，那么就不会继续往下计算了，此时谁写在后面就听谁的。也就是说优先级如果一样，那么谁写在后面就听谁的<blockquote><p>注意：只有选择器是直接选中标签的才需要计算权重，否则一定会听直接选中的选择器的 </p></blockquote></li></ol><p>如果再到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li>如果存在内联样式，那么 A = 1, 否则 A = 0</li><li>B的值等于 ID选择器出现的次数</li><li>C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数</li><li>D 的值等于 标签选择器 和 伪元素 出现的总次数</li></ul><p>这里举个例子：#nav-global &gt; ul &gt; li &gt; a.nav-link ，套用上面的算法，依次求出 A B C D 的值：</p><ul><li>因为没有内联样式 ，所以 A = 0</li><li>ID选择器总共出现了1次， B = 1</li><li>类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C = (1 + 0 + 0) = 1</li><li>标签选择器出现了3次， 伪元素出现了0次，所以 D = (3 + 0) = 3</li><li>上面算出的A 、 B、C、D 可以简记作：(0, 1, 1, 3)</li></ul><p>知道了优先级是如何计算之后，就来看看比较规则：</p><ul><li>从左往右依次进行比较 ，较大者优先级更高</li><li>如果相等，则继续往右移动一位进行比较</li><li>如果4位全部相等，则后面的会覆盖前面的</li><li>经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用 <code>!important</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 之内存管理</title>
      <link href="/2022/01/10/js-zhi-nei-cun-guan-li/"/>
      <url>/2022/01/10/js-zhi-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h2><p>JS有两种数据类型，分别是原始数据类型（<code>String、Number、Boolean、Null、Undefined、Symbol</code>）和引用数据类型（<code>Object</code>）。<br>而存放这两种数据类型的内存又可以分为两部分，分别是栈内存（Stack）和堆内存（Heap）。</p><p>这里说下栈内存和堆内存的区别：<br>|栈内存|堆内存|<br>|:–:|:–:|<br>|先进后出，后进先出|无序存储，根据引用直接获取|<br>|存储原始数据类型|存储引用数据类型|<br>|存储的值大小固定|存储的值大小不固定，可动态调整|<br>|按值访问|按引用访问|<br>|可以直接操作|不允许直接操作|<br>|空间小，但运行效率高|空间大，但运行效率相对低|</p><p>不知道大家有没有过这样一个疑问：Js 声明变量时，底层是怎么实现这个声明过程的，或者说是怎么存储这个变量的，感兴趣的话可以看看下面这两篇文章：</p><ul><li><a href="http://www.dennisgo.cn/Articles/JavaScript/MemoryManagement.html#%E6%A0%88%E5%86%85%E5%AD%98">原始数据类型是如何存进栈内存的</a>  </li><li><a href="https://segmentfault.com/a/1190000015118062">基本类型和引用类型发生复制行为后的不同影响</a></li></ul><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：   </p><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放/归还</li></ol><p>JS的内存分配</p><ol><li>值的初始化<br>在定义变量时就完成了内存分配</li><li>使用值<br>使用值的过程实际上是对分配内存进行读取与写入的操作。这个操作可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</li><li>释放不再需要的内存</li></ol><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak），会导致内存溢出。</p><blockquote><p>内存溢出：指程序申请内存时，没有足够的内存供申请者使用。例如，给一块存储int类型数据的存储空间，但却存储long类型的数据，那么结果就是内存不够用，此时就会报错，即所谓的内存溢出。</p></blockquote><h3 id="常见-JavaScript-内存泄露"><a href="#常见-JavaScript-内存泄露" class="headerlink" title="常见 JavaScript 内存泄露"></a>常见 JavaScript 内存泄露</h3><ol><li>意外的全局变量 </li></ol><p>①未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window 。<br>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  bar <span class="token operator">=</span> <span class="token string">"this is a hidden global variable"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 实际上是：</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  window<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"this is an explicit global variable"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  如果 bar 是一个应该指向 foo 函数作用域内变量的引用，但是你忘记使用 var 来声明这个变量，这时就会创建一个全局变量。</p><p>  ②另一种意外的全局变量可能由 this 创建：<br>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>variable <span class="token operator">=</span> <span class="token string">"potential accidental global"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  函数自身发生了调用，this 指向全局对象（window）</p><p>  为了防止这种错误的发生，可以在你的 JavaScript 文件开头添加 <code>&#39;use strict&#39;;</code> 语句。这个语句实际上开启了解释 JavaScript 代码的严格模式，可以避免创建意外的全局变量。</p><p>总结：</p><ul><li>全局变量的注意事项：如果你必须使用全局变量来存储很多的数据，请确保在使用过后将它设置为 <code>null</code> 或者将它<strong>重新赋值</strong>。常见的和全局变量相关的引发内存消耗增长的原因就是缓存。（缓存存储着可复用的数据）</li><li>解决方法：①避免创建全局变量；②使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 use strict。</li></ul><ol start="2"><li>闭包引起的内存泄漏</li></ol><p>原理：闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。 </p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> leaks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> leak <span class="token operator">=</span> <span class="token string">'xxxxxx'</span><span class="token punctuation">;</span> <span class="token comment">// 被闭包所引用，不会被回收</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>leak<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 比如：在循环中的函数表达式，能复用最好放到循环外面。</span><span class="token comment">// 不要这样：</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> <span class="token function-variable function">t</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建了10次函数对象</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token function">t</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 这样比较好：</span><span class="token keyword">function</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">t</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>t <span class="token operator">=</span> <span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>没有清理的 DOM 元素引用</li></ol><p>原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 在对象中引用DOM</span><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  btn<span class="token operator">:</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  elements<span class="token punctuation">.</span>btn<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">removeBtn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 将body中的btn移除，也就是移除DOM树中的btn</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 但是此时全局变量 elements 还是保留了对 btn 的引用，btn 还是存在于内存中，不能被 GC 回收</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：手动删除，elements.btn = null。</p><ol start="4"><li><p>没有移除计时器或回调函数</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。</span><span class="token comment">// 定时器</span><span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'renderer'</span><span class="token punctuation">)</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    renderer<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token comment">// 观察者模式</span><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"I'm innerHTML"</span><span class="token punctuation">&#125;</span>btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：①手动删除定时器和 dom；②removeEventListener 移除事件监听</p></li><li><p>循环引用 </p></li></ol><p>当出现了一个含有DOM对象的循环引用时，就会发生内存泄露。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="内存泄露的解决方案"><a href="#内存泄露的解决方案" class="headerlink" title="内存泄露的解决方案"></a>内存泄露的解决方案</h3><p>下面的方案是从网上搜索到的资料，本人并没有实践过（主要是还不懂），仅供大家参考：</p><ul><li> 显式类型转换</li><li> 避免事件导致的循环引用</li><li> 不影响返回值地打破循环引用</li><li> 延迟appendChild</li><li> 代理DOM对象<blockquote><p>更加具体的解决方法可点击这里：<a href="https://zhuanlan.zhihu.com/p/67843006?from=from_parent_mindnote">传送门</a></p></blockquote><h2 id="V8-垃圾回收机制"><a href="#V8-垃圾回收机制" class="headerlink" title="V8 垃圾回收机制"></a>V8 垃圾回收机制</h2>上文有提到：内存会发生泄露是因为没有及时释放多余的内存。那么问题来了，应该由谁去释放多余的内存，又是怎么释放内存的？答案是 V8 垃圾回收机制。在了解这个机制之前，我们先来认识下什么是 V8 。<h3 id="认识V8"><a href="#认识V8" class="headerlink" title="认识V8"></a>认识V8</h3>V8 是 Google 采用 C++ 编写的开源 JavaScript 引擎。采用即时编译，直接翻译成机器语言，并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。</li></ul><p>V8内存设限：64bit操作系统上不超过1.5G，32bit操作系统上不超过800M 这么设限为了浏览器使用内存足够，内部还有垃圾运行机制，时间也在用户感知的合理范围</p><p>目前V8垃圾回收采用增量标记算法需要50ms，采用非增量标记算法需要1s</p><p>这里先停一下，康康这篇文章再往下会更好：<a href="https://segmentfault.com/a/1190000018605776">前端面试：谈谈 JS 垃圾回收机制</a></p><hr><p>ddd，如果已经看完了上面这篇文章，就让我们继续往下吧~</p><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><p>一般来说没有被引用的对象就是垃圾，就是要被清除。 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p><h3 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h3><p>基本思路：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。值得注意的是，垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用–属于“不可判定的”问题，这意味着靠算法是解决不了的。</p><p>我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在，此时，栈（或堆）内存会分配空间以保存相应的值。当函数在内部使用了变量，然后退出，此时，就不再需要那个局部变量了，它占用的内存可以释放了。但垃圾回收程序并不知道哪个局部变量是要被释放的，因此，程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用。</p><p>原始数据都是由程序语言自身控制的，这里的回收还是指主要存活在堆区的对象数据，这个过程是离不开内存操作的，那在这种情况下是如何对垃圾进行回收的?答案是：</p><ol><li>采用分代回收的思想</li><li>内存分为新生代存储区、老生代存储区</li><li>针对不同代采用不同的 GC 算法</li></ol><p>下面针对 GC 算法展开讨论。</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>相关概念：</p><ul><li><p>GC：垃圾回收机制的简写，垃圾回收期完成具体的工作，可以找到内存中的垃圾、并释放和回收空间</p></li><li><p>GC 算法：是 GC 工作时查找和回收所遵循的规则</p><h3 id="常见-GC-算法："><a href="#常见-GC-算法：" class="headerlink" title="常见 GC 算法："></a>常见 GC 算法：</h3></li><li><p>引用计数（不太常用）</p><ul><li>核心思想：跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成 0 了，就可以将其内存空间回收。</li><li>实现原理：<ul><li>引用计数器</li><li>当引用关系改变时修改引用数字</li><li>当引用数字为0时立即回收</li></ul></li><li>实例：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>age<span class="token operator">:</span><span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> user2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>age<span class="token operator">:</span><span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> user3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>age<span class="token operator">:</span><span class="token number">13</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> nameList <span class="token operator">=</span> <span class="token punctuation">[</span>user1<span class="token punctuation">.</span>age<span class="token punctuation">,</span> user2<span class="token punctuation">.</span>age<span class="token punctuation">,</span> user<span class="token punctuation">.</span>age<span class="token punctuation">]</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> num2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    num3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当函数调用过后，<code>num1</code> 和 <code>num2</code> 在外部不能使用，引用数为 0，会被回收;</li><li><code>num3</code> 是挂载在window上的，所以不会被回收;</li><li><code>user1</code>、<code>user2</code>、<code>user3</code> 被 <code>nameList</code> 引用，所以引用数不为 0，故不会被回收 ;</li></ul></li><li>优缺点：<table><thead><tr><th align="center">引用计数算法</th><th align="left">内容</th></tr></thead><tbody><tr><td align="center">优点</td><td align="left">1.发现垃圾时立即回收<br>2.最大限度减少程序暂停，让空间不会有被占满的时候</td></tr><tr><td align="center">缺点</td><td align="left">1.无法回收循环引用的对象<br>2.资源消耗开销大（对所有对象进行数值的监控和修改，本身就会占用时间和资源）</td></tr></tbody></table><ul><li>举一栗子说明上面缺点中无法回收循环应用对象的情况：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  obj1<span class="token punctuation">.</span>name <span class="token operator">=</span> obj2   obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> obj1  <span class="token keyword">return</span> <span class="token string">'hello world'</span> <span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  obj1 和 obj2 因为互相有引用，所以计数器并不为 0 ，fn 调用结束之后依旧无法回收这两个对象</li></ul></li></ul></li><li><p>标记清除（最常用）</p><ul><li>核心思想：<strong>当变量进入执行上下文时</strong>（比如在函数内部声明一个变量时），这个变量会被加上存在于上下文中的标记；<strong>而在上下文中的变量</strong>，从逻辑上来说，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们；<strong>当变量离开上下文时</strong>，也会被加上离开上下文的标记【也有的说法是标记被清除，不过《JavaScript 高级程序设计》中写的是前者，就以该书为主吧】。于是当垃圾回收时就会销毁那些带标记的值并回收他们的内存空间。</li><li>实现原理：分 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段完成<ul><li>第一阶段：遍历所有对象找活动对象（可达对象）进行标记（层次用递归进行操作）<ol><li>有一组基本的固有可达值，由于显而易见的原因无法删除。例如:<ul><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的- 变量和参数</li><li>全局变量</li><li>还有一些其他的，内部的这些值称为根。</li></ul></li><li>如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的<ul><li>例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为可达性， 它引用的那些也是可以访问的。</li></ul></li></ol></li><li>第二阶段：遍历所有对象，清除没有标记的对象，并抹掉第一个阶段标的标记<ul><li>注意：js中的标记是标记所有的变量，清除掉被标记为离开状态的变量；而老生代中的标记使标记存活的变量，清除没有被标记的变量。（什么是老生代？后面会讲到的）</li></ul></li><li>收尾：回收相应空间，将回收的空间加到空闲链表中，方便后面的程序申请空间使用</li></ul></li><li>优缺点：<table><thead><tr><th align="center">标记清除算法</th><th align="left">内容</th></tr></thead><tbody><tr><td align="center">优点</td><td align="left">1.相对于引用计数算法来说，解决了对象循环引用的问题。因为局部作用域里面的内容无法被标记，所以即使有引用还是会被清除掉<br>2.回收速度较快</td></tr><tr><td align="center">缺点</td><td align="left">1.空间链表地址不连续（空间碎片化），不能进行空间最大化使用<br>2.不会立即回收垃圾对象，清除的时候程序是停止工作的</td></tr></tbody></table><ul><li>下面是空间链表地址不连续的图示，可以更好的帮我们理解这个缺点是怎么肥事：<img src="https://s4.ax1x.com/2022/01/10/7EKZIs.jpg" alt="不连续空间链表"></li></ul></li></ul></li><li><p>标记整理</p><ul><li><p>核心思想：在 标记 和 清除 中间，添加了内存空间的 整理</p></li><li><p>实现原理：（标记整理可以看做是标记清除的 增强）</p><ul><li>标记阶段：与标记清除一致</li><li>整理阶段：清除垃圾前先执行整理操作，移动对象位置，在地址上产生连续</li><li>最后留出了整个的空闲空间</li></ul></li><li><p>流程图示：<br><img src="https://s4.ax1x.com/2022/01/10/7EK1LF.png" alt="未整理前"><br><img src="https://s4.ax1x.com/2022/01/10/7EK8Z4.png" alt="整理后"><br><img src="https://s4.ax1x.com/2022/01/10/7EKlsU.png" alt="回收后"></p></li><li><p>优缺点：</p><table><thead><tr><th align="center">标记整理算法</th><th align="left">内容</th></tr></thead><tbody><tr><td align="center">优点</td><td align="left">相较标记清除算法减少了碎片化空间</td></tr><tr><td align="center">缺点</td><td align="left">不会立即回收垃圾对象，清除的时候程序是停止工作的</td></tr></tbody></table></li></ul></li><li><p>空间复制</p><ul><li>新生代区域垃圾回收使用空间换时间</li><li>主要采用复制算法，要有空闲空间存在，当然新生代本身空间小，分出来的复制的空间更小，所以浪费这点空间换取时间的效率是微不足道的</li><li>老生代区域垃圾回收不适合复制算法，老生代空间大一分为二，会造成一半的空间浪费，存放数据多复制时间长。</li></ul></li><li><p>分代回收 (一定会用)</p><ul><li>新生代对象回收<blockquote><p>新生代 —— 就是指存活时间较短的对象，例如：一个局部作用域中，只要函数执行完毕之后变量就会回收。</p></blockquote><ul><li>主要使用算法：采用赋值算法 + 标记整理算法</li><li>回收过程：<ul><li>新生代内存区分为<strong>两个等大小空间</strong>，使用空间为From，空闲空间为To</li><li>如果需要申请空间使用，回收步骤如下：<ol><li>首先会将所有活动对象存储于From空间，这个过程中To是空闲状态。   </li><li>当From空间使用到一定程度之后就会触发GC操作，这个时候会进行标记整理——对活动对象进行标记并移动位置将使用空间变得连续。<br><img src="https://s4.ax1x.com/2022/01/10/7EKQMT.png" alt="步骤 1、2 图示"></li><li>将活动对象拷贝至To空间，拷贝完成之后活动空间就有了备份，这个时候就可以考虑回收操作了。</li><li>把From空间完成释放，回收完成。<br><img src="https://s4.ax1x.com/2022/01/10/7EKnGq.png" alt="步骤 3、4 图示"> </li><li>对From和To名称进行调换，继续重复之前的操作。<br><img src="https://s4.ax1x.com/2022/01/10/7EKmin.png" alt="步骤 5 图示"></li></ol></li></ul></li><li>这种算法的缺点是：只能使用堆内存的一半。</li><li>总结：使用From -&gt; 触发GC标记整理 -&gt; 拷贝到To -&gt; 回收From -&gt; 名称互换 -&gt; 重复之前</li></ul></li><li>晋升<ul><li>定义：拷贝的过程中某个对象的指代在老生代空间，就可能出现晋升。 晋升就是将新生代对象移动至老生代。</li><li>什么时候触发晋升操作?<ul><li>1.<strong>一轮GC之后还存活的新生代对象</strong>就需要晋升</li><li>2.在拷贝过程中，To空间的使用率超过25%，将这次的活动对象都移动至老生代空间<ul><li>Q：为什么设置25%这个阈值</li><li>A：当这次回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</li></ul></li></ul></li></ul></li><li>老生代对象回收<blockquote><p>老生代 —— 就是指存活时间较长的对象，例如：全局对象，闭包变量数据。</p></blockquote><ul><li>主要使用算法：主要采用标记清除 （首要） 、标记整理、增量标记算法</li></ul></li><li>V8内存空间一分为二，分为新生代存储区和老生代存储区<ul><li>左边小空间用于存储新生代对象<ul><li>64bit操作系统上不超过32M</li><li>32bit操作系统上不超过16M</li></ul></li><li>右边较大空间用于存储老生代对象<ul><li>64bit操作系统上不超过1.6G</li><li>32bit操作系统上不超过700M</li></ul></li></ul></li></ul></li><li><p>标记增量 (提高效率用)</p><ul><li>将一整段的垃圾回收操作标记拆分成多个小段完成回收，主要是为了实现程序和垃圾回收的交替完成，这样进行 效率优化 带来的时间消耗更加的合理。</li><li>优化垃圾回收：看图可以将垃圾回收分成两个部分，一个是程序的执行，一个是垃圾的回收。当垃圾回收的时候其实会阻塞程序的执行，所以中间会有空档期。<br>  <img src="../img/12.png"><blockquote><p>这篇文章也挺好，小伙伴们可以看看：<a href="http://newhtml.net/v8-garbage-collection/">传送门</a></p></blockquote></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是闭包</title>
      <link href="/2022/01/09/shi-me-shi-bi-bao/"/>
      <url>/2022/01/09/shi-me-shi-bi-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>指有权访问外层函数作用域中的变量的函数。</p><p>什么意思呢？举个栗子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>a</code> 对于 foo 函数来说，属于外层函数作用域中的变量，由于作用域链，使得 foo 函数可以访问到变量 <code>a</code> ，因此就构成了一个闭包。</p><h3 id="创建闭包的方式"><a href="#创建闭包的方式" class="headerlink" title="创建闭包的方式"></a>创建闭包的方式</h3><p>那么该如何创建一个闭包呢？<br>常见方式：就是<strong>在一个函数内部创建另一个函数。</strong></p><h3 id="执行上下文的角度看闭包"><a href="#执行上下文的角度看闭包" class="headerlink" title="执行上下文的角度看闭包"></a>执行上下文的角度看闭包</h3><p>下面从执行上下文的角度看下闭包是怎么一回事：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> scope<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ol><blockquote><p>思考一个问题：当 f 函数执行的时候，checkscope 函数上下文已经被销毁了(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p></blockquote><ul><li>这是因为 f 执行上下文维护了一个作用域链：<pre class="line-numbers language-js" data-language="js"><code class="language-js">fContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> checkscopeContext<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>就是因为这个作用域链，<code>f</code> 函数依然可以读取到 <code>checkscopeContext.AO</code> 的值，说明当 <code>f</code> 函数引用了 <code>checkscopeContext.AO</code> 中的值的时候，即使 <code>checkscopeContext</code> 被销毁了，但是 JavaScript 依然会让 <code>checkscopeContext.AO</code> 活在内存中，<code>f</code> 函数依然可以通过 <code>f</code> 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</li></ul><h3 id="一道刷题必刷，面试必考的闭包题"><a href="#一道刷题必刷，面试必考的闭包题" class="headerlink" title="一道刷题必刷，面试必考的闭包题"></a>一道刷题必刷，面试必考的闭包题</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来分析一下为什么答案全为 3 ？</p><ul><li>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：<pre class="line-numbers language-js" data-language="js"><code class="language-js">globalContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">VO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    data<span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    i<span class="token operator">:</span><span class="token number">3</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：<pre class="line-numbers language-js" data-language="js"><code class="language-js">data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Context <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>data[0]Context 的 AO 并没有 i 值，所以会从 <code>globalContext.VO</code> 中查找，i 为 3，所以打印的结果就是 3。</li><li>data[1] 和 data[2] 是一样的道理。</li></ul><p><strong>将上面的题改成闭包看看：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：（跟没改之前一模一样）  <pre class="line-numbers language-js" data-language="js"><code class="language-js">globalContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token constant">VO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        data<span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        i<span class="token operator">:</span><span class="token number">3</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：  <pre class="line-numbers language-js" data-language="js"><code class="language-js">data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Context <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> 匿名函数Context<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>匿名函数执行上下文的AO为：  <pre class="line-numbers language-js" data-language="js"><code class="language-js">匿名函数Context <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token constant">AO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>        arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>            <span class="token number">0</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>            length<span class="token operator">:</span><span class="token number">1</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        i<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>data[0]Context</code> 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数<code> Context.AO</code> 中查找，这时候就会找 i 为 0，找到了就不会往 <code>globalContext.VO</code> 中查找了（即使 <code>globalContext.VO</code> 也有 i 的值–为3），所以打印的结果就是0。</li><li>data[1] 和 data[2] 是一样的道理。</li></ul><p>以下代码块中，c 会报错，并不会读取到bar 执行上下文中变量对象c</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innerFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    fn <span class="token operator">=</span> innerFoo<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>虽然 fn() ，即 innerFoo() 是在 bar 里面执行的，但是 innerFoo 函数执行的时候它的作用域 scope 里面分别是 <code>[AO,fooContext.AO, globalContext.AO]</code> ，并没有包括 barContext.AO 在里面，所以根本就没有声明 c 这个变量，所以报错</li></ul><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><blockquote><p>推荐阅读文章：<a href="https://segmentfault.com/a/1190000003985390">[译] JavaScript：立即执行函数表达式（IIFE）</a></p></blockquote><p>当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"Barry"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 无法从外部访问变量 name</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出错误："Uncaught ReferenceError:name is not defined"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"Barry"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// IIFE 执行后返回的结果：</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Barry"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 的流量控制机制</title>
      <link href="/2022/01/08/tcp-de-liu-liang-kong-zhi-ji-zhi/"/>
      <url>/2022/01/08/tcp-de-liu-liang-kong-zhi-ji-zhi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 运输层 </tag>
            
            <tag> TCP </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 的运输连接管理</title>
      <link href="/2022/01/06/tcp-de-yun-shu-lian-jie-guan-li/"/>
      <url>/2022/01/06/tcp-de-yun-shu-lian-jie-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-运输连接的三个阶段"><a href="#TCP-运输连接的三个阶段" class="headerlink" title="TCP 运输连接的三个阶段"></a>TCP 运输连接的三个阶段</h2><p>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的，共有三个阶段，即：</p><ul><li>连接建立（“三报文握手”）</li><li>数据传送</li><li>连接释放（“四报文挥手”）</li></ul><p>TCP 连接的建立采用客户–服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>，被动等待连接建立的应用进程叫做<strong>服务器</strong>。</p><blockquote><p>下文将<strong>客户</strong>简写为 A ，将<strong>服务器</strong>简写为 B 。</p></blockquote><h2 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h2><p>TCP 建立连接的过程叫做<strong>握手</strong>，握手需要在 A 和 B 之间交换三个 TCP 报文段。</p><p>首先，来认识一下握手挥手中用到的一些标识位和缩写的含义：</p><ul><li>SYN（Synchronize Sequence Numbers)：同步序列编号，表示建立链接</li><li>FIN：标识位，表示关闭链接</li><li>ACK（Acknowledgement）：标识位，表示响应</li><li>ack（Acknowledgement Number）：确认号码，是期望收到对方下一个报文的第一个数据字节的序号</li><li>seq（Sequence Number）：顺序号码（TCP连接中传送的字节流中的每个字节都按顺序编号）</li></ul><p>接下来先看下 TCP 三次握手的流程图：<br><img src="https://s4.ax1x.com/2022/01/05/TXqBZ9.png" alt="TCP 三次握手流程图"></p><ul><li>最初两端的 TCP 进程都处于 <code>CLOSED</code> （关闭）状态。</li><li>一开始，B 的 TCP 服务器进程先创建 <strong>传输控制块 TCB</strong> 【用于存储 TCP 连接中的一些重要信息，如 TCP 连接表、指向发送和接收缓存的指针、当前的发送和接收序号】，准备接受 A 的连接请求。然后服务器进程就处于 <code>LISTEN</code>（收听）状态，等待客户的链接请求。</li><li>A 的 TCP 客户进程也是首先创建 <strong>传输控制块 TCB</strong>。然后，在打算建立 TCP 连接时，向 B 发送 TCP 连接请求报文段，并进入 <code>SYN-SENT</code> （同步已发送）状态。<br>TCP 连接请求报文段首部中的同步位 <code>SYN = 1</code>（表明这是一个 TCP 连接请求报文段）；序号字段 <code>seq = x</code> （作为 TCP 客户进程所选择的初始序号）。【注意：TCP 规定 <code>SYN = 1</code> 的报文段不能携带数据，但要<strong>消耗掉一个序号</strong>。】</li><li>B 收到 TCP 连接请求报文段后，如果同意建立连接，则向 A 发送 TCP 连接请求确认报文段，并进入 <code>SYN-RCVD</code> （同步已接受）状态。<br>该报文段首部中的同步位 <code>SYN</code> 和确认位 <code>ACK</code> 都设置为 1 （表明这是一个 TCP 连接请求确认报文段）；序号字段 <code>seq = y</code>（作为 TCP 服务器进程所选择的初始序号），确认号字段 <code>ack = x + 1</code> （这是对 TCP 客户进程所选择的初始序号的确认）。【注意：这个报文段也不能携带数据，因为它是 <code>SYN</code> 被设置为 1 的报文段，但同样要消耗掉一个序号】。</li><li>A 收到 B 的确认后，还要向 B 发送一个普通的 TCP 确认报文段，并进入 <code>ESTABLISHED</code> （连接已建立）状态。<br>该报文段首部中的确认位 <code>ACK = 1</code> (表明这是一个普通的 TCP 确认报文段）；序号字段 <code>seq = x + 1</code> （这是因为 TCP 客户进程发送的第一个 TCP 报文段的序号为 x ，并且不携带数据，因此第二个报文段的序号为 x + 1）。【注意： TCP 规定普通的 TCP 确认报文段可以携带数据，但如果不携带数据，则不消耗序号】。在这种情况下，所发送的下一个数据报文段的序号仍是 <code>seq = x + 1</code>；确认号字段 <code>ack</code> 被设置为 y + 1 （这是对 TCP 服务器进程所选择的初始序号的确认）。</li><li>TCP 服务器进程收到该确认报文段后也进入 <code>ESTABLISHED</code> （连接已建立）状态。现在，TCP 双方都进入了连接已建立状态，他们可以基于已建立好的 TCP 连接进行可靠的数据传输了。</li></ul><p>现在有一个问题：为什么 A 最后还要发送一次确认呢？<br>答案是：防止已经失效的连接请求报文突然又传送到服务器，从而导致不必要的错误和资源的浪费。<br>所谓“已失效的连接请求报文段”是这样产生的：  </p><ul><li>先考虑一种正常情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 重新发送一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。这时 A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B ，没有“已失效的连接请求报文段”。  </li><li>现假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B 。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误以为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 B 发出确认新的连接就建立了。<br>而由于现在 A 不并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。这样的话， B 的许多资源就这样白白浪费了。</li></ul><blockquote><p>至此，三次握手就到此结束啦~</p></blockquote><h2 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h2><p>先看下四次挥手的流程图，心里有数好一点：<br><img src="https://s4.ax1x.com/2022/01/06/TvT11O.png" alt="TCP 四次挥手流程图"></p><ul><li>当TCP 的运输连接管理的第二个阶段-数据传输结束后，通信的双方都可释放连接。</li><li>现在 A 和 B 都处于 <code>ESTABLISHED</code> （连接已建立）状态。假设 A 的应用进程通知其主动关闭 TCP 连接，就发送 TCP 连接释放报文段，停止发送数据，并进入 <code>FIN-WAIT-1</code> （终止等待1）状态。<br>TCP 连接释放报文段首部中的终止位 <code>FIN</code> 和确认为 <code>ACK</code> 的值都被设置为 1 （表明这是一个 TCP 连接释放报文段，同时也对之前收到的报文段进行确认）；序号 <code>seq = u</code> （它等于 TCP 客户进程之前已传送过的数据的最后一个字节的序号加 1 ）【注意：TCP 规定终止位 FIN 等于 1 的报文段即使不携带数据，也要消耗掉一个序号。】；确认号 <code>ack = v</code> （它等于 TCP 客户进程之前已收到的数据的最后一个字节的序号加 1 ）。</li><li>B 收到 TCP 连接释放报文段后，会发送一个普通的 TCP 确认报文段并进入 <code>CLOSE-WAIT</code>（关闭等待） 状态。<br>TCP 确认报文段首部中的确认位 <code>ACK = 1</code> （表明这是一个普通的 TCP 确认报文段）；序号 <code>seq = v</code> （它等于 TCP 服务器进程之前已传送过的数据的最后一个字节的序号加 1 ，这也与之前收到的 TCP 连接释放报文段中的确认号匹配）；确认号 <code>ack = u + 1</code> （这是对 TCP 连接释放报文段的确认）。<br>收到 A 发来的连接释放报文段后，B 应用进程这时应通知高层应用进程：TCP 客户进程要断开与自己的 TCP 连接。于是，从 A –&gt; B 这个方向的连接就释放了。这时的 TCP 连接属于 <code>half-close</code> （半关闭）状态，也就是 A 已经没有数据要发送了。但如果 B 还有数据要发送，A 仍要接收。也就是说，从 B –&gt; A 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li><li>A 收到来自 B 的确认后，就进入 <code>FIN-WAIT-2</code> （终止等待2）状态，等待 B 发出的连接释放报文段。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 <code>FIN = 1</code> 。现假定 B 的序号为 w （在半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 <code>ack = u + 1</code> 。这时 B 就进入 <code>LAST-ACK</code> （最后确认）状态，等待 A 的确认。</li><li>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 <code>ACK = 1</code> ，确认号 <code>ack = w + 1</code> ，而自己的序号是 <code>seq = u + 1</code> （根据 TCP 标准，前面发送过的 FIN 报文段要消耗掉一个序号），然后进入到 <code>TIME-WAIT</code> （时间等待）状态。【<strong>注意：现在 TCP 连接还没有释放掉，必须经过时间等待计时器设置的时间 <code>2 MSL</code>（最长报文段寿命，RFC 793 建议设为 2 分钟，现如今 2 分钟可能已经太长了，可以自己修改合适的时间） 后，A 才能进入到 <code>CLOSED</code> 状态</strong>，然后才能开始建立下一个新的连接】。当 A 撤销相应的传输控制块 TCB 后，就算结束了这次的 TCP 连接。</li><li>B 只要收到了 A 发出的确认，立即进入 <code>CLOSED</code> 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。</li><li>可以看到，B 结束 TCP 连接的时间要比 B 早一些。</li></ul><p>那么问题又来了：为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？<br>答案是：①保证客户端发送的最后一个 ACK 报文段能够达到服务器；②防止已经失效的关闭连接报文段出现在本连接中。为什么这么说呢，可以来看看：  </p><ul><li>①由于这个 ACK 报文段有可能丢失，因而使处在 <code>LAST-ACK</code> 状态的 B 收不到对己发送的 FIN + ACK 报文段的确认。<br>B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。<br>接着 A 重传一次确认，重新启动 <code>2MSL</code> 计时器。最后，A 和 B 都正常进入到 <code>CLOSED</code> 状态。<br>如果 A 在 TIME-WAIT 状态不等待一段时间，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 <code>CLOSED</code> 状态。</li><li>② A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL ，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ul><blockquote><p>至此，四报文握手就到此结束啦~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 运输层 </tag>
            
            <tag> TCP </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文</title>
      <link href="/2022/01/05/zhi-xing-shang-xia-wen/"/>
      <url>/2022/01/05/zhi-xing-shang-xia-wen/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们首先来看一个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照代码书写顺序，应该先输出 111，再输出 666 才对，但是很遗憾，两次输出均为 666。<br>如果我们将上述代码中的函数声明改为函数表达式，结果又不太一样：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//111</span><span class="token keyword">var</span> <span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是很意外，这其中的奥秘其实就在于JS的执行上下文里，看完下面的内容，你就会理解为什么了。</p><h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p><strong>JS 代码在执行之前，JS 引擎会先做一下“准备工作”，也就是创建对应的执行上下文。</strong><br>执行上下文有且只有三类：<strong>全局执行上下文</strong>，<strong>函数上下文</strong>，与eval上下文。由于eval一般不会使用，就不深入探究了。  </p><blockquote><p>插一句，在 JavaScript 中，运行环境主要包含了全局环境和函数环境。<br>而 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。<br>全局环境和函数环境所对应的执行上下文我们分别称为全局（执行）上下文和函数（执行）上下文。<br>下面进入正题：</p></blockquote><ol><li>全局执行上下文  </li></ol><ul><li>全局执行上下文只有一个，在客户端中一般由浏览器创建，也就是我们熟知的 window 对象，我们能通过 this 直接访问到它。<br><code>console.log(this);</code></li><li>全局对象 window 上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，如：<br><code>console.log(this.Math.random())</code>等</li><li>window 对象是 var 声明的全局变量的载体。我们通过 var 创建的全局对象，都可以通过 window 直接访问。  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  window<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ol start="2"><li>函数执行上下文<br>每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。（即使是调用同一个函数）<br>每次调用函数时，都会为该函数创建一个新的执行上下文。<br>于是我们很容易得知函数执行上下文可存在无数个。</li></ol><p>综上，执行上下文可以理解为代码在被解析以前或者在执行时候所处的环境。之所以这么理解，是因为全局上下文是在代码被解析前就已经由浏览器创建好了的，函数上下文是在函数调用时创建的。</p><blockquote><p>Q：接下来问题来了，我们写的函数多了去了，如何管理创建的那么多函数上下文呢？<br>A1：所以 JavaScript 引擎创建了执行上下文栈<code>（Execution context stack，ECStack）</code>【是一种拥有 LIFO（后进先出）数据结构的栈】来管理执行上下文。<br>A2：当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出  </p></blockquote><blockquote><p>既如此，当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 <code>globalContext</code> 表示它，并且只有当整个应用程序结束的时候（比如关闭网页或退出浏览器），ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 <code>globalContext</code> 。</p></blockquote><h2 id="执行上下文的三个重要属性"><a href="#执行上下文的三个重要属性" class="headerlink" title="执行上下文的三个重要属性"></a>执行上下文的三个重要属性</h2><h3 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h3><p>是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。   </p><blockquote><p>因为不同执行上下文下的变量对象稍有不同，所以来理一下全局上下文中的变量对象和函数上下文中的变量对象。</p><ul><li><strong>全局上下文中的变量对象就是全局对象！</strong><ul><li>全局对象是由 Object 构造函数实例化的一个对象。<br><code>console.log(this instanceof Object);</code></li></ul></li><li><strong>在函数上下文中，用活动对象来表示变量对象。</strong>      <ul><li>活动对象(activation object, AO)和变量对象其实是同一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</li><li>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</li></ul></li></ul></blockquote><blockquote><p>再看下执行过程：<strong>执行上下文的代码会分成两个阶段进行处理：创建（代码预编译）阶段 和 执行（代码执行）阶段</strong></p></blockquote><ul><li>1.预编译阶段（进入执行上下文，这时候还没有执行代码）<br>先进行语法分析，没有问题以后，在预编译阶段对JavaScript代码中<strong>变量的内存空间</strong>进行分配（变量提升就是在这个阶段完成的）。<ul><li>变量对象会包括：<ul><li>1）函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 <code>undefined</code></li></ul></li><li>2）函数声明【由名称和对应值（函数对象）组成一个变量对象的属性被创建】</li><li>3）变量声明【由名称和对应值（<code>undefined</code>）组成一个变量对象的属性被创建】</li></ul></li></ul></li></ul><p>举个栗子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在进入执行上下文后，这时候的AO是：</span><span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>   arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>       <span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>       length<span class="token operator">:</span><span class="token number">1</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 函数调用时创建的函数上下文，所以为 1</span>   b<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>   c<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>   d<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">        > [执行上下文创建阶段的另一种参考解释1](https://www.cnblogs.com/echolun/p/11438363.html)  [执行上下文创建阶段的另一种参考解释2](https://blog.csdn.net/qq_33718648/article/details/90754331)  [执行上下文创建阶段的另一种参考解释3](https://juejin.cn/post/6844903682283143181#heading-4)- 2.代码执行阶段（执行代码逻辑，修改变量对象的值）  </span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>js                  <span class="token comment">// 还是上面的栗子，当代码执行完之后，这时候的AO是：</span>  <span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>      arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>          <span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>          length<span class="token operator">:</span><span class="token number">1</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>      b<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>      c<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      d<span class="token operator">:</span>reference to FunctionExpression <span class="token string">"d"</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结上述所说：</p><ul><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值，同时执行上下文在这个阶段会全部创建完成<h3 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h3>作用域链是指由当前上下文和上层上下文的一系列变量对象组成的层级链。</li></ul><p>我们已经知道，<strong>执行上下文分为创建和执行两个阶段</strong>，在执行上下文的执行阶段，当需要查找某个变量或函数时，会先在当前上下文的变量对象（活动对象）中进行查找，<strong>若是没有找到，则会依靠当前上下文中的作用域链，沿着上层上下文的变量对象进行查找，直到全局上下文中的变量对象（全局对象）</strong>。</p><blockquote><p>Q：既然如此，那作用域链又是怎么创建的？<br>A：我们都知道，JavaScript 中主要包含了全局作用域和函数作用域，而<strong>函数作用域是在函数被声明的时候确定的</strong>。<br>每一个函数都会包含一个 [[scope]] 内部属性，<strong>在函数被声明的时候，该函数的 [[scope]] 属性会保存其上层上下文的变量对象</strong>，形成包含上层上下文变量对象的层级链。**[[scope]] 属性的值是在函数被声明的时候确定的**。<br>当函数被调用的时候，其执行上下文会被创建并入栈。在创建阶段生成其变量对象后，会将该变量对象添加到作用域链的顶端并将 [[scope]] 添加进该作用域链中。而在执行阶段，变量对象会变为活动对象，其相应属性会被赋值。<br>所以，作用域链是由当前上下文变量对象及上层上下文变量对象组成的：<br><code>SC = AO + [[scope]]</code></p></blockquote><p>看个栗子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分析如下：</span><span class="token comment">// 在 fn1 函数上下文中，fn2 函数被声明，所以</span>fn2<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>fn1_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> globalObj<span class="token punctuation">]</span><span class="token comment">// 当 fn2 被调用的时候，其执行上下文被创建并入栈，此时会将生成的变量对象添加进作用域链的顶端，并且将 [[scope]] 添加进作用域链</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">SC</span><span class="token operator">=</span><span class="token punctuation">[</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token parameter">fn2<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">=></span>fn2_EC<span class="token punctuation">.</span><span class="token constant">SC</span><span class="token operator">=</span><span class="token punctuation">[</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> fn1_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> globalObj<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面用个例子总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> scope2 <span class="token operator">=</span> <span class="token string">'local scope'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> scope2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>①由于先处理函数声明。于是checkscope 函数被创建，保存作用域链到内部属性[[scope]]（[[scope]] 属性会保存其上层上下文的变量对象（也就是全局对象））</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>②执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>③checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  Scope<span class="token operator">:</span>checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>读到这里可能会有以下疑问：</p><blockquote><p>Q1：checkscope函数被创建时保存到[[scope]]的作用域链，和 checkscope执行前的准备工作中复制函数[[scope]]属性创建的作用域链有什么不同？<br>A1：checkscope函数创建的时候，保存的是根据词法所生成的作用域链。checkscope执行的时候，会复制这个作用域链，作为自己作用域链的初始化，然后根据环境生成变量对象，然后将这个变量对象，添加到这个复制的作用域链，这才完整的构建了自己的作用域链。  </p></blockquote><blockquote><p>Q2：为什么会有两个作用域链？<br>A2：因为在函数创建的时候并不能确定最终的作用域的样子。而为什么会采用复制的方式而不是直接修改呢？应该是因为函数会被调用很多次吧。</p></blockquote><ul><li>④第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>    length<span class="token operator">:</span><span class="token number">0</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  scope2<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>⑤第三步：将活动对象压入checkscope 作用域顶端<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    scope2<span class="token operator">:</span><span class="token keyword">undefined</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>⑥准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    scope2<span class="token operator">:</span><span class="token string">'local scope'</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>⑦查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>至此，作用域链的知识点over :）<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3>首先需要清楚，<code>this</code> 是执行上下文的一个属性，而不是某个变量对象的属性。<code>this</code> 的指向也不是如常识一般指向某某，而是依据调用栈和执行位置决定的（即取决于函数在哪里被调用）。【 <code>this</code> <strong>是在运行时绑定的，并不是在编写时绑定</strong>】<blockquote><p>this 绑定有五种场景：默认绑定、隐式绑定、显式绑定、new绑定、箭头函数绑定</p></blockquote></li></ul><ul><li><p>默认绑定<br>即函数调用时无任何调用前缀。默认绑定时，不管函数在何处调用， <code>this</code> 指向全局对象 <code>window</code>（非严格模式）；在严格模式下，默认绑定的 <code>this</code> 指向 <code>undefined</code>。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 666</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// --> 默认绑定</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught TypeError: Cannot read property 'num' of undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>温馨提示：在严格模式下调用不在严格模式中的函数，并不会影响this指向，如下：</p>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'yfz'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yfz</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>隐式绑定<br>如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">,</span>  func<span class="token operator">:</span> fn<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 666</span><span class="token comment">// 上面代码中，this 指向 obj，obj 有 num 属性，所以输出 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果函数调用前存在多个对象，this 指向距离调用自己最近的对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">,</span>  func<span class="token operator">:</span> fn<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">111</span><span class="token punctuation">,</span>  o<span class="token operator">:</span> obj<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里稍微拓展一下，如果将 obj 对象的 name 属性注释掉，却会输出 undefined</p>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  func<span class="token operator">:</span> fn<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'yfz'</span><span class="token punctuation">,</span>  o<span class="token operator">:</span> obj<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  obj 对象虽然是 obj1 的属性，但它们两个的原型链并不相同，并不是父子关系，由于 obj 未提供 name 属性，所以是 undefined 。注意不要将作用域链和原型链弄混淆了，如果有小伙伴不能弄清楚，也可以看看我的另一篇博客：<a href="https://hcyety.github.io/2022/01/07/yuan-xing-lian/">原型链</a>。</p></blockquote><blockquote><p>既然说到这里了，索性再理清一下作用域链与原型链的区别：<br>  –&gt; 当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象 window ，如果 window 都没有这个变量则报错。<br>  –&gt; 当在对象上访问某属性时，首先会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是 null ，如果全程都没找到则返一个 undefined ，而不是报错。</p></blockquote></li><li><p>显式绑定<br>指通过call、apply、bind以及js API中的部分方法改变this指向</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// call、apply、bind</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">111</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">999</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 111</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 666</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 999</span><span class="token comment">// API</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 3 次 666</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，如果在使用 call 之类的方法改变this指向时，指向参数提供的是 null 或者 undefined ，那么 this 将指向全局对象。</p></blockquote></li><li><p>new绑定</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> echo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>echo<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token comment">// 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上方代码中，构造调用创建了一个新对象 echo ，而在函数体内，this 将指向新对象 echo 上</p></li></ul><blockquote><p>如果一个函数调用存在多种绑定方法，this最终指向谁呢？<br>这里给出前面四种绑定方法的优先级：<br>显式绑定 &gt; 隐式绑定 &gt; 默认绑定<br>new绑定 &gt; 隐式绑定 &gt; 默认绑定  </p><p>为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错。</p></blockquote><ul><li>箭头函数this指向:<br>箭头函数中没有自己的 this ，箭头函数的 this 指向取决于外层作用域中的 this ：外层作用域或函数的 this 指向谁，箭头函数中的 this 便指向谁；最终保障是指向 window 。</li></ul><blockquote><p>参考学习资料：<a href="https://www.cnblogs.com/echolun/p/11962610.html">this的指向问题</a><br>另外可学习冴羽大神之不同的角度看this：<a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a></p></blockquote><p>说到这里，执行上下文的三个属性终于说完了，以上。</p><h2 id="执行上下文栈和执行上下文的具体变化过程"><a href="#执行上下文栈和执行上下文的具体变化过程" class="headerlink" title="执行上下文栈和执行上下文的具体变化过程"></a>执行上下文栈和执行上下文的具体变化过程</h2><p>还是那个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> scope<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>全局上下文初始化<pre class="line-numbers language-js" data-language="js"><code class="language-js">globalContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">VO</span><span class="token operator">:</span><span class="token punctuation">[</span>global<span class="token punctuation">]</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span>globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token operator">:</span>globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><ol start="3"><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>checkscope 函数执行上下文初始化：</li></ol><ul><li>1）复制函数 [[scope]] 属性创建作用域链，</li><li>2）用 arguments 创建活动对象，</li><li>3）初始化活动对象，即加入形参、函数声明、变量声明，</li><li>4）将活动对象压入 checkscope 作用域链顶端。</li><li>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    scope<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>    f<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="5"><li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  fContext<span class="token punctuation">,</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>f 函数执行上下文初始化, 以下跟第 4 步相同：</li></ol><ul><li>1）复制函数 [[scope]] 属性创建作用域链</li><li>2）用 arguments 创建活动对象</li><li>3）初始化活动对象，即加入形参、函数声明、变量声明</li><li>4）将活动对象压入 f 作用域链顶端<pre class="line-numbers language-js" data-language="js"><code class="language-js">fContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  arguments<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      length<span class="token operator">:</span><span class="token number">0</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  Scope<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> checkscopeContext<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="7"><li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>  checkscopeContext<span class="token punctuation">,</span>  globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  globalContext<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>以上就是执行上下文的全部知识点，以及其底层实现过程，希望对大家有所帮助。</p></blockquote><h2 id="最后注明"><a href="#最后注明" class="headerlink" title="最后注明"></a>最后注明</h2><p>学习资料参考冴羽大神的博客：</p><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript深入之执行上下文栈</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript深入之变量对象</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript深入之作用域链</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/8">JavaScript深入之执行上下文</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链的继承</title>
      <link href="/2022/01/04/yuan-xing-lian-de-ji-cheng/"/>
      <url>/2022/01/04/yuan-xing-lian-de-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Q：什么是原型继承？<br>A：一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。</p><p>下面看看原型链的六种继承方式。</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ul><li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'siyang'</span><span class="token punctuation">,</span> <span class="token string">'hcy'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>son<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy"]</span>son<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy", "hg"]</span><span class="token keyword">var</span> sis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sis<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy", "hg"]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sis<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy", "hg"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h2></li><li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'kevin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span><span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'daisy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// daisy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>优点：<ul><li>避免了引用类型的属性被所有实例共享：关键在于this指向（call 实现）；</li><li>可以在子构造函数中向父构造函数传参。</li></ul></li><li>缺点：由于必须在构造函数中定义方法，因此函数不能重用。<h2 id="组合继承（伪经典继承）（原型链继承-经典继承）"><a href="#组合继承（伪经典继承）（原型链继承-经典继承）" class="headerlink" title="组合继承（伪经典继承）（原型链继承+经典继承）"></a>组合继承（伪经典继承）（原型链继承+经典继承）</h2>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</li><li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token string">'hcy'</span><span class="token punctuation">,</span><span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>son<span class="token punctuation">.</span>color<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hcy</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["blue", "red"]</span><span class="token keyword">var</span> sister <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sister<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["blue"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。而且 <code>instanceof</code> 和 <code>isPrototypeof()</code> 也能够用于识别基于组合继承创建的对象。</li><li>缺点：<strong>会调用两次父构造函数</strong>。一次是设置子类型实例的原型的时候：<code>child.prototype = new Parent()</code> ；另一次在创建子类型实例的时候：<code>var son = new child(&#39;hcy&#39;,&#39;20&#39;)</code>。<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2>借助原型可以基于已有的对象创建新的对象，同时还不必因此创建自定义的类型。于是有了下面这个函数。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>在 <code>createObj()</code> 函数内部，先创建了一个临时性构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例</li></ul><p>看个栗子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span><span class="token string">'kevin'</span><span class="token punctuation">,</span>    friends<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'daisy'</span><span class="token punctuation">,</span> <span class="token string">'kelly'</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'person1'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'taylor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['daisy', 'kelly', 'taylor']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 <code>name</code> 值，而是因为<code>person1.name = &#39;person1&#39;</code>是给<code>person1</code>添加了 <code>name</code> 值，并非修改了原型上的 <code>name</code> 值。</p><ul><li>下面看看原型式的模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建一个临时性的构造函数</span>    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 将传入的对象作为这个构造函数的原型</span>    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>    <span class="token comment">// 返回这个临时类型的一个新实例</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">"hcy"</span><span class="token punctuation">,</span>    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"et"</span><span class="token punctuation">,</span> <span class="token string">"siyang"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> another <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hcy</span>another<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["et", "siyang", "hg"]</span>son<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'zbc'</span><span class="token punctuation">;</span><span class="token keyword">var</span> sister <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sister<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hcy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样</li><li>使用场景：不需要单独创建构造函数，但仍然需要在对象间共享信息</li></ul><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><p>举个栗子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  clone<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> clone<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span><span class="token string">'siyang'</span><span class="token punctuation">;</span>  friends<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'hg'</span><span class="token punctuation">,</span><span class="token string">'hcy'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>anotherPerson<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "hi"</span><span class="token comment">// 将 `createObj` 函数返回的结果赋值给 `clone` ，然后给 `clone` 添加了 sayName 方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>  clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> clone<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span><span class="token string">'siyang'</span><span class="token punctuation">,</span>  friends<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'hcy'</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> another <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>another<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello World!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法，函数不能复用使效率低下，与借用构造函数继承类似。</li><li>使用场景：主要关注对象，而不在乎类型和构造函数</li></ul><h2 id="寄生组合式继承（引用类型最理想的继承范式）"><a href="#寄生组合式继承（引用类型最理想的继承范式）" class="headerlink" title="寄生组合式继承（引用类型最理想的继承范式）"></a>寄生组合式继承（引用类型最理想的继承范式）</h2><p>即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。<br>基本思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。<br>本质上：使用寄生式继承来继承父类原型，然后再将返回的新对象赋值给子类原型。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> person</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>  child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栗子：<br>先放一个组合继承的代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改造目标：不使用 <code>Child.prototype = new Parent()</code> ，而是间接的让 <code>Child.prototype</code> 访问到 <code>Parent.prototype</code>。</p><p>明白需求之后，开始动手：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 关键的三步</span><span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是封装：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">prototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>prototye<span class="token punctuation">)</span><span class="token punctuation">;</span>  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>  child<span class="token punctuation">.</span>prototpe <span class="token operator">=</span> prototype<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 当我们使用的时候：</span><span class="token function">prototype</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。同时，原型链还能保持不变；因此，还能够正常使用 <code>instanceof</code> 和 <code>isPrototypeOf。</code></p><ul><li>完整模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">obj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> Parent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 创建父类原型的一个副本</span>  <span class="token keyword">var</span> _prototype <span class="token operator">=</span> <span class="token function">obj</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 为创建的副本添加 constructor 属性，弥补因重写原型而失去的默认的 constructor 属性</span>  <span class="token class-name">_prototype</span><span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>  <span class="token comment">// 将新创建的对象（即副本）赋值给子类原型</span>  child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> _prototype<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> sister <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token string">'siyang'</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sister<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>sister<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// siyang</span>sister<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sister<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  ["blue", "red", "yellow"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链</title>
      <link href="/2022/01/03/yuan-xing-lian/"/>
      <url>/2022/01/03/yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<h2 id="原型链的基本构想"><a href="#原型链的基本构想" class="headerlink" title="原型链的基本构想"></a>原型链的基本构想</h2><p>Q：什么是原型链？<br>A：当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 <code>Object.prototype</code> 的原型时，此时原型为 <code>null</code> ，查找停止。这种通过 通过原型链接的逐级向上的查找链被称为原型链。</p><p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。下面 step by step 来探究原型链的奥妙。<br><img src="https://s4.ax1x.com/2022/01/07/7pek60.png" alt="原型链中的各种关系"><br>从上图我们可以了解到构造函数（<code>Person</code>）、原型（<code>Person.prototype</code>）和实例（<code>person</code>）之间的关系：<br>每个构造函数都有一个原型对象（用<code>Person.prototype</code>），原型对象都包含一个指向构造函数的指针（用<code>Person.prototype.constructor</code>获取），而实例都包含一个指向原型对象的内部指针（用<code>person._proto_</code>）。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p><p>下面来认识 <code>constructor</code> 和 <code>_proto_</code>：</p><ol><li>constructor<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在解释为什么之前，我们需要了解到原型链的搜索机制：在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。<strong>对属性和方法的搜索会一直持续到原型链的末端</strong>。</p></blockquote></li></ol><p>那么现在可以来看看为什么代码块中的打印会为 true 了：当获取 person.constructor 时，其实 person 中并没有 <code>constructor</code> 属性，当不能读取到 <code>constructor</code> 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性。</p><ol start="2"><li><strong>proto</strong><br>是实例对象指向原型对象的指针，隐式原型，是每个对象都会有的一个属性。</li></ol><p>来看个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承了 SuperType</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SubType<span class="token punctuation">.</span>prototpye<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码我们可以看到，<code>SubType</code> 通过创建 <code>SuperType</code> 的实例继承了 <code>SuperType</code>，于是 <code>SubType</code> 从构造函数变成了实例，<code>SuperType</code> 的实例变成了 <code>SubType</code> 的原型。这样一来，原本存在于 <code>SuperType</code> 的实例中的所有属性和方法，现在也存在于 <code>SubType.prototype</code>中了。<br>后面的代码还在继承的基础上，给 <code>SubType</code> 添加了一个新方法。于是：<img src="../img/36.png"><br>提醒：<code>getSuperValue()</code>方法仍然还在 <code>SuperType.prototype</code>中，但<code>property</code>则位于<code>SubType.prototype</code>中。这是因为<code>property</code>是一个实例属性，而<code>getSuperValue()</code>则是一个原型方法。既然<code>SubType.prototype</code>现在是<code>SuperType</code>的实例，那么<code>property</code>当然就位于该实例中了。<br>于是我们懂了，当原型对象等于另一个类型的实例后，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么如此递进，就会构成实例与原型的链条，也就是原型链。</p><h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>实际上，原型链中还有一环。我们知道所有引用类型默认都继承自 <code>Object</code> ，所有函数的默认原型也都是 <code>Object</code> 的实例，因此默认原型都会包含一个内部指针，指向 <code>Object.prototype</code> 。这也正是所有自定义类型都会继承 <code>toString()</code>、<code>valueOf()</code> 等默认方法的根本原因。</p><h3 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h3><p>原型与实例的关系可以通过两种方式来确定。<br>①是使用 <code>instanceof</code> 操作符，如果一个实例的原型链中出现过相应的构造函数，则 <code>instanceof</code> 返回 <code>true</code>。如下所示：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承了 SuperType</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SubType</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从技术上讲，<code>instance</code> 是 <code>Object</code>、<code>SubType</code>、<code>SuperType</code> 的实例，因为 <code>instance</code> 的原型链中包含这些构造函数的原型。</p><p>②是使用 <code>isPrototypeOf()</code> 方法。原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回 <code>true</code> 。如下所示：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="原型链的问题："><a href="#原型链的问题：" class="headerlink" title="原型链的问题："></a>原型链的问题：</h3><ol><li>原型中如果存在引用类型的值，会被所有实例共享，如下所示：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'greeb'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span> <span class="token comment">// "red, blue, green, black"</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "red, blue, green, black"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>如果原型的属性被所有的实例共享，就会存在一个实例修改了这个属性后，也会影响到其他实例，这往往会造成一些不必要的麻烦。因此，通常的做法是在构造函数中，而不是在原型中定义属性，如：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["black"]</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li></ol><p>实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。<br>为了解决这些问题，可以使用一种叫做 借用构造函数的技术（有时候也叫做伪造对象或经典继承），即在子类型构造函数的内部调用超类型构造函数。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 继承了 SuperType ，同时还传递了参数</span>    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 实例属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'siyang'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "siyang"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "hg"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 28</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码在 SubType 内部使用 call 实现了对 SuperType 的”继承”，同时每个实例都有自己的实例属性，互不影响；而且创建实例时还可以向超类型 SuperType 传递参数。</p><blockquote><p>说到原型链的继承，也是一个 JS 必须学习的一个重点，在我另一篇博客中也有详细介绍：<a href="https://hcyety.github.io/2022/01/07/yuan-xing-lian-de-ji-cheng/">原型链的继承</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var let const 的区别使用</title>
      <link href="/2021/12/27/var-let-const-de-qu-bie-shi-yong/"/>
      <url>/2021/12/27/var-let-const-de-qu-bie-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><strong>用于声明变量，变量声明的同时，可以赋值也可不赋值（不赋值的情况下，变量会保存一个特殊值 <code>undefined</code> ），后续可以更改变量的值。</strong></p><ul><li>注意1：<ul><li>变量名可以包含字母，数字，下划线和美元符号，但要以字母开头【也可以以$和_开头（但一般不这么用）】。</li><li>变量名是大小写敏感的（y和Y是不同的变量）</li><li>保留字（如JavaScript关键字）不能作为变量名使用</li></ul></li><li>注意2：var会发生“变量提升”现象。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> age<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这就是所谓的“变量提升”，也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用 var 声明同一个变量也没有问题：<pre class="line-numbers language-js" data-language="js"><code class="language-js">  <span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>### <span class="token keyword">var</span> 声明作用域使用 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">var</span><span class="token template-punctuation string">`</span></span> 操作符定义的变量会成为 包含它的函数的局部变量。比如，使用 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">var</span><span class="token template-punctuation string">`</span></span> 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>`js<span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">'hi'</span><span class="token punctuation">;</span>  <span class="token comment">// 局部变量</span><span class="token punctuation">&#125;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 出错！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这里，<code>message</code> 变量是在函数内部使用 <code>var</code> 定义的。函数为 <code>test()</code> ，调用它就会创建这个变量并给该变量赋值；调用之后变量随即被销毁，因此实例中的最后一行会导致错误。<br>不过，在函数内定义变量时省略 var 操作符，可以创建一个全部变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  message <span class="token operator">=</span> <span class="token string">'hi'</span><span class="token punctuation">;</span>  <span class="token comment">// 全局变量</span><span class="token punctuation">&#125;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "hi"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>去掉之前的 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test() ，就会定义这个变量，并且可以在函数外部访问到。<blockquote><p>注意：虽然可以省略 var 操作符定义全局变量，但不推荐这么做。因为在局部作用域中定义的全局变量很难维护，也会造成困扰。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 <code>ReferenceError</code> 。</p></blockquote></li></ul><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><strong>它的用法类似于var，但是所声明的变量，只在 let 命令所在的代码块内有效。</strong> 看下面例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'hg'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hg</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hg</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError：age 没有定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，age 变量之所以不能再 if 块外部被引用，是因为它的作用域仅限于该块内部。<br>由于块作用域是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let 。</p><ul><li>注意1：let不允许在相同作用域内，重复声明同一个变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js">  <span class="token comment">// 报错</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 报错</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 报错</span>  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> arg<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>  <span class="token comment">// 不报错</span>  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> arg<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">     - 注意2：let不像var那样会发生“变量提升”现象。## const**声明一个只读的常量。一旦声明，常量的值就不能改变；且声明变量时，就必须立即初始化，不能留到以后赋值。**- 注意1：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 的作用域与 </span><span class="token template-punctuation string">`</span></span><span class="token keyword">let</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 命令相同：只在声明所在的块级作用域内有效。- 注意2：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 命令声明的常量也是不提升，只能在声明的位置后面使用。- 注意3：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 声明的常量，也与 </span><span class="token template-punctuation string">`</span></span><span class="token keyword">let</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 一样不可重复声明。- 注意4：对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 声明的限制只适用于它指向的变量的引用。**const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，也就是说，如果 const 变量引用的是一个对象，那么修改整个对象内部的属性并不违反 const 限制。**       栗子1：    </span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>js    <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>    foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// TypeError："foo" is read-only</span>    <span class="token comment">// 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  栗子2：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可执行</span>a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 可执行</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Dave'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 报错</span><span class="token comment">// 上面代码中，常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a ，就会报错。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>关于变量提升，还有一些东西可以探讨一下。首先，变量提升是指把变量声明提升到当前执行环境的最顶端。</p><p>看一个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错ReferenceError</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 以上代码可看作：</span><span class="token keyword">var</span> foo<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错ReferenceError</span>foo <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，由于 <code>var</code> 发生了“变量提升”现象，将 <code>foo</code> 的声明提升到了 <code>console.log(foo)</code> 前面，即脚本开始运行时，变量 <code>foo</code> 已经存在了，但是没有值，所以会输出 <code>undefined</code>。<br>变量 <code>bar</code> 用 let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol><li><code>var</code> 和 <code>function</code> 的变量提升是有优先级的，且 <code>function</code> 的高于 <code>var</code> 的。（另外，如果函数名字相同，后面函数会覆盖前面的函数。）<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// ƒ a() &#123;&#125;</span><span class="token comment">// 可以隐式地理解为：</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> a<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ƒ a() &#123;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>当遇到函数和变量同名且都会被提升的情况，由于函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：function a()&#123; alert('我是函数') &#125;</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出：'我是变量'</span><span class="token comment">// 上面代码可以隐式的理解为：</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">var</span> a<span class="token punctuation">;</span>    <span class="token comment">// undefined</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//输出：function a()&#123; alert('我是函数') &#125;</span>a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span><span class="token comment">//赋值</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出：'我是变量'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>var 和 function 的变量提升优先级显而易见，但如果是函数声明 <code>function foo()&#123;&#125;</code> 和函数表达式 <code>var foo = function()&#123;&#125;</code> 呢？<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token comment">// function f1()&#123;&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token comment">// undefined</span><span class="token keyword">var</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 函数表达式</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 函数声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>上面的代码并不是说函数声明的提升优先级高于函数表达式，而是因为当遇到函数表达式的时候，首先会将<strong>关键字+变量名</strong>提升到当前执行环境的最顶端，也就是<code>var f2</code> 先被提升，然而此时 <code>f2</code> 的值为 <code>undefined</code>，所以 <code>f2</code> 打印值为 <code>undefined</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 之作用域</title>
      <link href="/2021/12/23/js-zhi-zuo-yong-yu/"/>
      <url>/2021/12/23/js-zhi-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>是指作用域是指程序源代码中定义变量的区域。</p><ul><li>块级作用域<br>指在代码块 {} 里面定义的变量，只会在当前代码块有效，如果外层作用域下想访问该变量，会报引用错误异常。<br>使用关键字 <code>let</code> 或 <code>const</code> 定义块级作用域的变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// ReferenceError: i is not defined</span><span class="token comment">// 因为 i 是用 let 生命的，只能在 let 的作用域里使用，即 for 循环内部有效，外部作用域是访问不到的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>函数作用域<br>是指包裹在函数里的作用域，其中的变量或者内部函数，对外都是封闭的，即外界无法访问。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token comment">// ReferenceError: a, b, c is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>全局作用域<br>是最外层的全局作用域，任何地方都可以访问得到。<br>在最外层作用域下使用 var 关键字会定义全局变量，也就是说会挂载在 window 对象上，或者不使用关键字 var、let、const 直接对变量名字进行赋值，JS也会自动为其创建为全局变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    b <span class="token operator">=</span> <span class="token number">20</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> <span class="token number">30</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>    <span class="token punctuation">&#125;</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// b 和 c 变量被隐式声明到全局变量了，所以能访问到，这也叫变量提升机制</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// 20</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// 30</span><span class="token comment">// 但 a，b，c 也被挂载在 window 对象（全局作用域）上面了</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token comment">// 20</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token comment">// 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><ul><li>词法作用域<br>在变量定义时决定（也叫静态作用域）。例如函数的作用域是在函数<strong>定义</strong>时决定的。  </li><li>动态作用域<br>在变量调用时才决定。例如函数的作用域是在函数<strong>调用</strong>的时候才决定的。<br>基于这两种作用域的不同，于是作用域的嵌套情况也不相同。 </li></ul><p>下面来看一个案例：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 结果是？？？</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>假设JavaScript采用静态作用域，让我们分析下执行过程：<ul><li>嵌套情况：全局作用域–&gt;foo函数作用域–&gt;bar函数作用域</li><li>于是：执行 <code>foo</code> 函数，先从 <code>foo</code> 函数作用域里查找是否有局部变量 <code>value</code>。如果没有，就根据函数定义的位置，往外一层的作用域里查找变量，发现在全局作用域里找到变量 <code>value</code> ，所以结果会打印 1。</li></ul></li><li>假设JavaScript采用动态作用域，让我们分析下执行过程：<ul><li>嵌套情况：全局作用域–&gt;bar函数作用域–&gt;foo函数作用域</li><li>于是：执行 <code>foo</code> 函数，依然是从 <code>foo</code> 函数作用域里查找是否有局部变量 <code>value</code>。如果没有，就从调用函数的作用域，再往外一层也就是 <code>bar</code> 函数作用域里查找 <code>value</code> 变量，所以结果会打印 2。</li></ul></li><li>由于<strong>JavaScript采用的是静态作用域</strong>，所以这个例子的结果是 1。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作服务器用到的 Linux 命令</title>
      <link href="/2021/12/21/bu-shu-fu-wu-qi-yong-dao-de-linux-ming-ling/"/>
      <url>/2021/12/21/bu-shu-fu-wu-qi-yong-dao-de-linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><ul><li>下载：<code>yum install ...</code>（阿里云服务器默认安装了 yum ，没有 yum 的可用 apt 代替）</li><li>检查是否安装：<code>rpm -qa ...</code>【有输出说明已安装，如果没有输出则没有安装，需使用安装命令进行安装】<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><pre class="line-numbers language-none"><code class="language-none">ls　　          显示文件或目录  -l                列出文件详细信息l(list)  -a                列出当前目录下所有文件及目录，包括隐藏的a(all)mkdir           创建目录  -p                创建目录，若无父目录，则创建p(parent)cd              切换目录touch           创建空文件echo            创建带有内容的文件。cat             查看文件内容cp              拷贝mv              移动或重命名rm              删除文件  -r                递归删除，可删除子目录及文件  -f                强制删除find            在文件系统中搜索某文件wc              统计文本中行数、字数、字符数grep            在文本文件中查找某个字符串rmdir           删除空目录tree            树形结构显示目录，需要安装tree包pwd             显示当前目录ln              创建链接文件more、less      分页显示文本文件内容head、tail      显示文件头、尾内容ctrl+alt+F1     命令行全屏模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h2><pre class="line-numbers language-none"><code class="language-none">gzip：            压缩方式一bzip2：           压缩方式二后面可带参数：  -c              归档文件  -x              压缩文件  -z              gzip压缩文件  -j              bzip2压缩文件  -v              显示压缩或解压缩过程 v(view)  -f              使用档名例：tar -cvf &#x2F;home&#x2F;abc.tar &#x2F;home&#x2F;abc           只打包，不压缩tar -zcvf &#x2F;home&#x2F;abc.tar.gz &#x2F;home&#x2F;abc       打包，并用gzip压缩tar -jcvf &#x2F;home&#x2F;abc.tar.bz2 &#x2F;home&#x2F;abc      打包，并用bzip2压缩当然，如果想解压缩，就直接将上面命令 tar -cvf  &#x2F; tar -zcvf  &#x2F; tar -jcvf 中的 “c” 换成 “x” 就可以了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2></li><li>查看服务运行状态：<code>ps -ef | gref ...</code></li><li>启动tomcat：<code>./startup.sh</code>；关闭：<code>./shutdown.sh</code></li><li>查询所有开放端口信息：<code>netstat -anp</code><h2 id="检查Linux上防火墙是否关闭"><a href="#检查Linux上防火墙是否关闭" class="headerlink" title="检查Linux上防火墙是否关闭"></a>检查Linux上防火墙是否关闭</h2></li><li>输入命令关闭：<code>systemctl stop firewalld.service</code></li><li>输入命令开启：<code>systemctl start firewalld.service</code></li><li>查看防火墙状态：<code>firewall-cmd --state</code>（not running表示关闭，running表示开启)</li><li>查询所有开放的端口：<code>firewall-cmd --list-all</code></li><li>查询指定端口是否开放：<code>firewall-cmd --query-port=8080/tcp</code>（yes：开放；no：未开放）</li><li>开放指定端口：<code>firewall-cmd --add-port=8080/tcp --permanent</code></li><li>移除指定端口：<code>firewall-cmd --permanent --remove-port=8080/tcp</code></li><li>重载新开放的端口：<code>firewall-cmd --reload</code><h2 id="在服务器上访问-ip"><a href="#在服务器上访问-ip" class="headerlink" title="在服务器上访问 ip"></a>在服务器上访问 ip</h2></li><li>连接方式：<code>curl http://（ip地址）</code></li><li>查看日志：<code>nginx access.log</code>（日志未滚动，代表本机访问不到公网ip）</li><li>网络检测：1)ping主机可以；2)telnet 主机3306端口不可以；telnet 主机22端口可以。则说明与本机网络没有关系；</li></ul><blockquote><p>学习资料：<a href="https://www.cnblogs.com/laov/p/3541414.html"> Linux 服务器中常用操作命令</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 之精度丢失</title>
      <link href="/2021/12/18/js-zhi-jing-du-diu-shi/"/>
      <url>/2021/12/18/js-zhi-jing-du-diu-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h2><p><strong>一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。</strong></p><ul><li><p>首先是对阶，所谓对阶，就是把阶码调整为相同。</p><ul><li>比如 0.1 是 1.1001100110011…… * 2^-4，阶码是 -4，</li><li>而 0.2 就是 1.10011001100110…* 2^-3，阶码是 -3；</li><li>两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… * 2^-3</li></ul></li><li><p>接下来是尾数计算：</p><ul><li>&nbsp;&nbsp;0.1100110011001100110011001100110011001100110011001101    +1.1001100110011001100110011001100110011001100110011010—————————————————————————————— 10.0110011001100110011001100110011001100110011001100111   </li><li>我们得到结果为：10.0110011001100110011001100110011001100110011001100111 * 2^-3</li></ul></li><li><p>将这个结果处理一下，即结果规格化：</p><ul><li>变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2，括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。</li></ul></li><li><p>再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入。</p><ul><li>因为我们要把括号里的 1 丢了，所以这里会进一，结果变成1.0011001100110011001100110011001100110011001100110100 * 2^-2</li></ul></li><li><p>本来还有一个溢出判断，因为这里不涉及，就不讲了。</p></li></ul><p>所以最终的结果存成 64 位就是0 01111111101 0011001100110011001100110011001100110011001100110100，<br>将它转换为10进制数就得到 0.30000000000000004440892098500626。<br>因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 十进制转二进制 </span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=></span> <span class="token string">"0.0001100110011001100110011001100110011001100110011001101"</span> <span class="token comment">// 二进制转十进制 </span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">1100100</span><span class="token punctuation">,</span><span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token number">100</span> <span class="token comment">// 以指定的精度返回该数值对象的字符串表示 </span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">21</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">"0.300000000000000044409"</span> <span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">21</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">"0.299999999999999988898"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 之数据类型转换</title>
      <link href="/2021/12/14/js-zhi-shu-ju-lei-xing-zhuan-huan/"/>
      <url>/2021/12/14/js-zhi-shu-ju-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="显式数据类型转化"><a href="#显式数据类型转化" class="headerlink" title="显式数据类型转化"></a>显式数据类型转化</h2><p>ES6 前，JavaScript 共有六种数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Object</code>。</p><h3 id="原始值转布尔"><a href="#原始值转布尔" class="headerlink" title="原始值转布尔"></a>原始值转布尔</h3><p>我们使用 <code>Boolean函数</code> 将类型转换成布尔类型，在 JavaScript 中，只有 6 种值可以被转换成 false，其他都会被转换成 true。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 当 Boolean 函数不传任何参数时，会返回 false。 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原始值转数字"><a href="#原始值转数字" class="headerlink" title="原始值转数字"></a>原始值转数字</h3><p>我们可以使用 <code>Number函数</code> 将类型转换成数字类型。如果 Number 函数<strong>不传参数，返回 +0</strong>；如果<strong>有参数，隐式调用 ToNumber(value)<strong>，ToNumber 则直接给了一个对应的结果表，表如下。但如果</strong>参数无法被转换为数字，则返回 NaN</strong>。</p><table><thead><tr><th align="center">参数类型</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">Undefined</td><td align="center">NaN</td></tr><tr><td align="center">Null</td><td align="center">+0</td></tr><tr><td align="center">Boolean</td><td align="center">如果参数是true，返回1；参数为false，返回+0</td></tr><tr><td align="center">Number</td><td align="center">返回与之相等的值</td></tr><tr><td align="center">String</td><td align="center">这段比较复杂，看例子</td></tr></tbody></table><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 不传参</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// +0 </span><span class="token comment">// 传参</span><span class="token operator">-</span> Undefinedconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN </span><span class="token operator">-</span> Nullconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// +0 </span><span class="token operator">-</span> Booleanconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// +0 </span><span class="token operator">-</span> Stringconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"-123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -123 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"1.2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1.2 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"000123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"-000123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -123 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"0x11"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 17 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"123 123"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">"100a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果通过 Number 转换函数<strong>传入一个字符串，它会试图将其转换成一个整数或浮点数，而且会忽略所有前导的 0</strong>；如果<strong>有一个字符不是数字，结果都会返回 NaN</strong>。鉴于这种严格的判断，我们一般还会使用更加灵活的 <code>parseInt</code> 和 <code>parseFloat</code> 进行转换。</p><ul><li>parseInt 只解析整数。如果字符串前缀是 “0x” 或者”0X”，会将其解释为十六进制数。  <pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0xFF"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 255 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0.1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>parseFloat 则可以解析整数和浮点数。  <pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"3.14 abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 3.14 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">".1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0.1 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>parseInt 和 parseFloat 都会<strong>跳过任意数量的前导空格</strong>，尽可能解析更多数值字符，并忽略后面的内容。如果<strong>第一个非空格字符是非法的数字直接量，将最终返回 NaN</strong>：  <pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"3 abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 3 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"-12.34"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -12 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="原始值转字符串"><a href="#原始值转字符串" class="headerlink" title="原始值转字符串"></a>原始值转字符串</h3>我们使用 <code>String函数</code> 将类型转换成字符串类型。如果 String 函数<strong>不传参数，返回空字符串</strong>，如果**有参数，隐式调用 ToString(value)**。而 ToString 也给了一个对应的结果表，表如图：<table><thead><tr><th align="center">参数类型</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">Undefined</td><td align="center">“undefined”</td></tr><tr><td align="center">Null</td><td align="center">“null”</td></tr><tr><td align="center">Bolean</td><td align="center">如果参数是true，返回true。参数为false，返回false</td></tr><tr><td align="center">Number</td><td align="center">又是比较复杂，可以看例子</td></tr><tr><td align="center">String</td><td align="center">返回与之相等的值</td></tr></tbody></table><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 不传参</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 空字符串 </span><span class="token comment">// 传参</span><span class="token operator">-</span> Undefinedconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// undefined </span><span class="token operator">-</span> Nullconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// null </span><span class="token operator">-</span> Booleanconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span><span class="token operator">-</span> Numberconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Infinity </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -Infinity </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原始值转对象"><a href="#原始值转对象" class="headerlink" title="原始值转对象"></a>原始值转对象</h3>原始值通过调用 <code>String()</code>、<code>Number()</code> 或者 <code>Boolean()</code> 构造函数，转换为它们各自的包装对象，（<code>null</code> 和 <code>undefined</code> 属于例外，当将它们用在期望是一个对象的地方都会造成一个类型错误 (TypeError) 异常，而不会执行正常的转换）。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="对象转布尔值"><a href="#对象转布尔值" class="headerlink" title="对象转布尔值"></a>对象转布尔值</h3>所有对象(包括数组和函数)都转换为 true，对于包装对象也是这样。<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="对象转字符串和数字"><a href="#对象转字符串和数字" class="headerlink" title="对象转字符串和数字"></a>对象转字符串和数字</h3>对象到字符串 和 对象到数字 的转换都是通过调用待转换对象的一个方法来完成的。而 JavaScript 对象有两个不同的方法来执行转换，一个是 <code>toString</code>，一个是 <code>valueOf</code>。注意这个跟上面所说的 ToString 和 ToNumber 是不同的，这两个方法是真实暴露出来的方法。</li><li>当调用对象的 toString 方法时，其实调用的是 Object.prototype 上的 toString 方法。<ul><li>然而 JavaScript 下的很多类根据各自的特点，定义了更多版本的 toString 方法。例如：</li><li>数组的 toString 方法将每个数组元素转换成一个字符串，并在元素之间添加逗号后合并成结果字符串。  <pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1,2,3 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>函数的 toString 方法返回函数本身  <pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [object Object]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// function ()&#123;var a = 1;&#125; </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>日期的 toString 方法返回一个可读的日期和时间字符串。  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Fri Jan 01 2010 00:00:00 GMT+0800 (CST)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>RegExp 的 toString 方法返回一个表示正则表达式直接量的字符串。  <pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// /\d+/g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li>而另一个转换对象的函数是 valueOf，表示对象的原始值。默认的 valueOf 方法返回这个对象本身，数组、函数、正则简单的继承了这个默认方法，也会返回对象本身。日期是一个例外，它会返回它的一个内容表示: 1970 年 1 月 1 日以来的毫秒数。  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1495296000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ol><li>对象转字符串   </li></ol><p>对象到字符串是如何转换的，其实就是 ToString 方法的对应表，只是这次我们加上 Object 的转换规则：   </p><table><thead><tr><th align="center">参数类型</th><th align="left">结果</th></tr></thead><tbody><tr><td align="center">Object</td><td align="left">1.primValue = ToPrimitive(input, String)<br>2.返回ToString(primValue)</td></tr></tbody></table><p>所谓的 ToPrimitive 方法，其实就是输入一个值，然后返回一个一定是基本类型的值。   </p><ul><li>语法：ToPrimitive(input[, PreferredType])<ul><li>第一个参数是 input，表示要处理的输入值。<strong>如果传入的 input 是 Undefined、Null、Boolean、Number、String 类型，直接返回该值。</strong></li><li>第二个参数是 PreferredType，非必填，表示希望转换成的类型，有两个值可以选，Number 或者 String。<strong>当不传入 PreferredType 时，如果 input 是日期类型，相当于传入 String，否则，都相当于传入 Number。</strong></li></ul></li></ul><ul><li><p>如果是 ToPrimitive(obj, Number)，处理步骤如下：   </p><ul><li>如果 obj 为 基本类型，直接返回</li><li>否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。</li><li>否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。</li><li>否则，JavaScript 抛出一个类型错误异常。</li></ul></li><li><p>如果是 ToPrimitive(obj, String)，处理步骤如下：   </p><ul><li>如果 obj为 基本类型，直接返回</li><li>否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。</li><li>否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。</li><li>否则，JavaScript 抛出一个类型错误异常。</li></ul></li></ul><p>初次总结：当我们用 String 方法转化一个值的时候，如果是基本类型，就参照 “原始值转字符” 这一节的对应表，如果不是基本类型，我们会将调用一个 ToPrimitive 方法，将其转为基本类型，然后再参照“原始值转字符” 这一节的对应表进行转换。</p><p>最终总结：对象转字符串(就是 Number() 函数)可以概括为：</p><ul><li>如果对象具有 toString 方法，则调用这个方法。如果他返回一个原始值，JavaScript 将这个值转换为字符串，并返回这个字符串结果。</li><li>如果对象没有 toString 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf 方法。如果存在这个方法，则 JavaScript 调用它。如果返回值是原始值，JavaScript 将这个值转换为字符串，并返回这个字符串的结果。</li><li>否则，JavaScript 无法从 toString 或者 valueOf 获得一个原始值，这时它将抛出一个类型错误异常。</li></ul><ol start="2"><li>对象转数字   </li></ol><p>其实，从对象到数字的转换也是一样：<br>|参数类型|结果|<br>|:–:|:–|<br>|Object|1.primValue = ToPrimitive(input, Number)<br>2.返回ToNumber(primValue)| </p><p><strong>虽然转换成基本值都会使用 ToPrimitive 方法，但传参有不同，最后的处理也有不同 -&gt; 转字符串调用的是 ToString，转数字调用 ToNumber。</strong></p><p>对象转数字的过程中，JavaScript 做了同样的事情，只是它会首先尝试 valueOf 方法。   </p><ul><li>如果对象具有 valueOf 方法，且返回一个原始值，则 JavaScript 将这个原始值转换为数字并返回这个数字。</li><li>否则，如果对象具有 toString 方法，且返回一个原始值，则 JavaScript 将其转换并返回。</li><li>否则，JavaScript 抛出一个类型错误异常。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 例子</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>a <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1262275200000</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>注意，在以上代码块中，[] 和 [0] 都返回了 0，而 [1, 2, 3] 却返回了一个 NaN。我们分析一下原因：</li><li>当我们 Number([]) 的时候，先调用 [] 的 valueOf 方法，此时返回 []，因为返回了一个对象而不是原始值，所以又调用了 toString 方法，此时返回一个空字符串，接下来调用 ToNumber 这个规范上的方法，参照对应表，转换为 0, 所以最后的结果为 0。</li><li>而当我们 Number([1, 2, 3]) 的时候，先调用 [1, 2, 3] 的 valueOf 方法，此时返回 [1, 2, 3]，再调用 toString 方法，此时返回 1,2,3，接下来调用 ToNumber，参照对应表，因为无法转换为数字，所以最后的结果为 NaN。</li></ul><h2 id="隐式数据类型转化"><a href="#隐式数据类型转化" class="headerlink" title="隐式数据类型转化"></a>隐式数据类型转化</h2><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符 +"></a>一元操作符 +</h3><p>当 + 运算符作为一元操作符的时候，会调用 ToNumber 处理该值，既然是调用 ToNumber 方法，当输入的值是对象的时候，先调用 ToPrimitive(input, Number) 方法，例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [] 调用 valueOf 方法，返回一个空数组；</span>    <span class="token comment">// 因为不是原始值，继续调用 toString 方法，返回 ""；</span>    <span class="token comment">// 得到返回值后，然后再调用 ToNumber 方法，"" 对应的返回值是 0，所以最终返回 0。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符 +"></a>二元操作符 +</h3><p>当计算 value1 + value2时：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">lprim <span class="token operator">=</span> <span class="token function">ToPrimitive</span><span class="token punctuation">(</span>value1<span class="token punctuation">)</span>rprim <span class="token operator">=</span> <span class="token function">ToPrimitive</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果 lprim 是字符串或者 rprim 是字符串，那么返回 ToString(lprim) 和 ToString(rprim)的拼接结果   </li><li>返回 ToNumber(lprim) 和 ToNumber(rprim)的运算结果</li></ul><p>1.Null 与数字</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>lprim = ToPrimitive(null) 因为null是基本类型，直接返回，所以 lprim = null</li><li>rprim = ToPrimitive(1) 因为 1 是基本类型，直接返回，所以 rprim = 1</li><li>lprim 和 rprim 都不是字符串</li><li>返回 ToNumber(null) 和 ToNumber(1) 的运算结果：ToNumber(null) 的结果为0，ToNumber(1) 的结果为 1。所以，null + 1 相当于 0 + 1，最终的结果为数字 1。</li></ul><p>2.数组与数组</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>lprim = ToPrimitive([])，[]是数组，相当于ToPrimitive([], Number)，先调用valueOf方法，返回对象本身，因为不是原始值，调用toString方法，返回空字符串””</li><li>rprim类似。</li><li>lprim和rprim都是字符串，执行拼接操作：[] + []相当于 “” + “”，最终的结果是空字符串””。</li></ul><p>3.数组与对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 两者结果一致 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>lprim = ToPrimitive([])，lprim = “”</li><li>rprim = ToPrimitive({})，相当于调用 ToPrimitive({}, Number)，先调用 valueOf 方法，返回对象本身，因为不是原始值，调用 toString 方法，返回 “[object Object]”</li><li>lprim 和 rprim 都是字符串，执行拼接操作：[] + {} 相当于 “” + “[object Object]”，最终的结果是 “[object Object]”。<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">+</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object Object][object Object]" </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">04</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// "Sun May 21 2017 00:00:00 GMT+0800 (CST)1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="相等"><a href="#相等" class="headerlink" title="== 相等"></a>== 相等</h3><ol><li><p>null和undefined</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    规则<span class="token number">2</span>）x是<span class="token keyword">null</span>并且y是<span class="token keyword">undefined</span>，返回<span class="token boolean">true</span>    规则<span class="token number">3</span>）x是<span class="token keyword">undefined</span>并且y是<span class="token keyword">null</span>，返回<span class="token boolean">true</span>    <span class="token comment">// 所以例子的结果自然为 true。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串与数字</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    规则<span class="token number">4</span>）x是数字，y是字符串，判断x <span class="token operator">==</span> <span class="token function">ToNumber</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token function">规则5）x是字符串，y是数字，判断ToNumber</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> y    <span class="token comment">// 都先转换成数字后再进行比较，所以例子的结果为true。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>布尔值和其他类型</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">==</span> <span class="token string">'2'</span><span class="token punctuation">)</span>    <span class="token function">规则6）x是布尔值，判断ToNumber</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> y    规则<span class="token number">7</span>）y是布尔值，判断x <span class="token operator">==</span><span class="token function">ToNumber</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token comment">// 当一方出现布尔值的时候，就会对这一方的值进行ToNumber处理，也就是说true会被转化成1，true == '2' 就相当于 1 == '2' 就相当于 1 == 2，结果自然是 false。</span>        <span class="token comment">// 所以当一方是布尔值的时候，会对布尔值进行转换，因为这种特性，所以尽量少使用 xx == true 和 xx == false 的写法。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对象与非对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token string">'42'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    规则<span class="token number">8</span>）x是字符串或者数字，y是对象，判断x <span class="token operator">==</span> <span class="token function">ToPrimitive</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token function">规则9）x是对象，y不是字符串或者数字，判断ToPrimitive</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> y    <span class="token comment">// 以这个例子为例，会使用 ToPrimitive 处理 ['42']，调用valueOf，返回对象本身，再调用 toString，返回 '42'，所以42 == ['42'] 相当于 42 == '42' 相当于42 == 42，结果为 true。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其他：一概返回 false<br>再多举几个例子进行分析：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span>    <span class="token comment">// false == undefined 相当于 0 == undefined 不符合上面的情形，执行最后一步 返回 false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">// false == [] 相当于 0 == [] 相当于 0 == '' 相当于 0 == 0，结果返回 true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">// 首先会执行 ![] 操作，转换成 false，相当于 [] == false 相当于 [] == 0 相当于 '' == 0 相当于 0 == 0，结果返回 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>最后再举一些会让人踩坑的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token string">"0"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 以上均返回 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常见的类型转换"><a href="#常见的类型转换" class="headerlink" title="常见的类型转换"></a>常见的类型转换</h2><table><thead><tr><th align="center">类型</th><th align="center">值</th><th align="center">to Boolean</th><th align="center">to Number</th><th align="center">to String</th></tr></thead><tbody><tr><td align="center">Boolean</td><td align="center">true</td><td align="center">true</td><td align="center">1</td><td align="center">“true”</td></tr><tr><td align="center">Boolean</td><td align="center">false</td><td align="center">false</td><td align="center">0</td><td align="center">“false”</td></tr><tr><td align="center">Number</td><td align="center">123</td><td align="center">true</td><td align="center">123</td><td align="center">“123”</td></tr><tr><td align="center">Number</td><td align="center">Infinity</td><td align="center">true</td><td align="center">Infinity</td><td align="center">“Infinity”</td></tr><tr><td align="center">Number</td><td align="center">0</td><td align="center">false</td><td align="center">0</td><td align="center">“0”</td></tr><tr><td align="center">Number</td><td align="center">NaN</td><td align="center">false</td><td align="center">NaN</td><td align="center">“NaN”</td></tr><tr><td align="center">String</td><td align="center">“”</td><td align="center">false</td><td align="center">0</td><td align="center">“”</td></tr><tr><td align="center">String</td><td align="center">“123”</td><td align="center">true</td><td align="center">123</td><td align="center">“123”</td></tr><tr><td align="center">String</td><td align="center">“123abc”</td><td align="center">true</td><td align="center">NaN</td><td align="center">“123abc”</td></tr><tr><td align="center">String</td><td align="center">“abc”</td><td align="center">true</td><td align="center">NaN</td><td align="center">“abc”</td></tr><tr><td align="center">Null</td><td align="center">null</td><td align="center">false</td><td align="center">0</td><td align="center">“null”</td></tr><tr><td align="center">Undefined</td><td align="center">undefined</td><td align="center">false</td><td align="center">NaN</td><td align="center">“undefined”</td></tr><tr><td align="center">Function</td><td align="center">function()</td><td align="center">{}</td><td align="center">true</td><td align="center">NaN</td></tr><tr><td align="center">Object</td><td align="center">{}</td><td align="center">true</td><td align="center">NaN</td><td align="center">“[object Object]”</td></tr><tr><td align="center">Array</td><td align="center">[]</td><td align="center">true</td><td align="center">0</td><td align="center">“”</td></tr><tr><td align="center">Array</td><td align="center">[“abc”]</td><td align="center">true</td><td align="center">NaN</td><td align="center">“abc”</td></tr><tr><td align="center">Array</td><td align="center">[“123”]</td><td align="center">true</td><td align="center">123</td><td align="center">“123”</td></tr><tr><td align="center">Array</td><td align="center">[“123”, “abc”]</td><td align="center">true</td><td align="center">NaN</td><td align="center">“123, abc”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 之数据类型</title>
      <link href="/2021/12/06/js-zhi-shu-ju-lei-xing/"/>
      <url>/2021/12/06/js-zhi-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="总共-7-种"><a href="#总共-7-种" class="headerlink" title="总共 7 种"></a>总共 7 种</h3><p>ECMAScript 有 <code>6</code> 种<strong>简单数据类型</strong>（也称为<strong>原始类型</strong>）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>；还有一种复杂数据类型：<code>Object</code>。</p><p>除过上面的 6 种基本数据类型外，剩下的就是引用数据类型了，统称为 <code>Object</code> 类型。细分的话，有：<code>Object</code>类型、<code>Array</code> 类型、<code>Date</code> 类型、<code>RegExp</code>类型、<code>Function</code> 类型 等。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>下面记录三个需要注意的数据类型：<br>一、Undefined 类型<br><code>Undefined</code> 类型只有一个值，就是 <code>undefined</code>。当使用 <code>var</code> 或 <code>let</code> 声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code> 值，因此：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ECMA-262 第3版之前，字面量 <code>undefined</code> 是不存在的，增加这个值是为了正式明确空对象指针（null）和未初始化变量的区别。</p><p>需要注意的是，未声明的变量和声明了但未赋值的变量是不同的，请看下面例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "undefined"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前面说过，声明变量时没有进行初始化就相当于给变量赋予 <code>undefined</code> 值，于是可以打印出 <code>&quot;undefined&quot;</code> ；但未声明的变量进行打印等操作就会报错，这点不难理解。难以理解的是下面这一点，对于未声明的变量，只能执行一个有效的操作，那就是对它调用 <code>typeof</code> （对未声明的变量调用 <code>delete</code> 也不会报错，只是没什么用，实际上在严格模式下会抛出错误），问题来了：在对未初始化的变量调用 <code>typeof</code> 时，返回的结果是 <code>&quot;undefined&quot;</code> ，但对为声明的变量调用它时，也返回了 <code>&quot;undefined&quot;</code> ，这就有点不是很好。比如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "undefined"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// "undefined"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>无论变量是否声明，<code>typeof</code> 返回的都是 <code>&quot;undefined&quot;</code> 。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><blockquote><p>！注意：建议声明变量的同时进行初始化。这样，当 <code>typeof</code> 返回 <code>&quot;undefined&quot;</code> 时，开发者就能知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p></blockquote><p>二、Null<br><code>Null</code> 类型只有一个值，即特殊值 <code>null</code> 。**<code>null</code> 值表示一个空对象指针**，这就是 <code>typeof null</code> 会返回 <code>&quot;object&quot;</code> 的原因：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "object"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>！建议：在定义将来要保存对象值的变量时，建议使用 null 来初始化，而不是使用其他值。这样，只要检查整改变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>message <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// message 是一个对象的引用</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>这里还有一个小点： <code>undefined</code> 值是由 <code>null</code> 值派生来的，因此 ECMA-262 将它们定义为表面上相等，如 <code>console.log(null == undefined); // true</code> </p><p>三、Symbol<br>具体的参考阮一峰老师的 <a href="https://es6.ruanyifeng.com/#docs/symbol">ECMAScript 6 入门之 Symbol</a>，这里就不班门弄斧了。</p><h4 id="基本数据类型的特性"><a href="#基本数据类型的特性" class="headerlink" title="基本数据类型的特性"></a>基本数据类型的特性</h4><ol><li>基本数据类型的值是不可变的，任何方法都无法改变一个基本类型的值，比如一个字符串：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>name<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hang</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HELLO</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>通过这两个例子，我们会发现原先定义的变量name的值始终没有发生改变。</li><li>而调用 <code>substr()</code> 和 <code>toUpperCase()</code> 方法后返回的是一个新的字符串，跟原先定义的变量 name 并没有关系。</li></ul><p>或许有人会有以下的疑问：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>name <span class="token operator">=</span> <span class="token string">"change1"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>这样看起来 name 的值“改变了”，其实 var name = “change”，这里的基础类型是 string ，也就是“change”,这里的“change”是不可以改变的，name只是指向“change”的一个指针，指针的指向可以改变，所以你可以name = “change1”，代表此时name指向了“change1”。同理，这里的“change1”同样不可以改变。</li><li>也就是说这里你认为的改变只是“指针的指向改变”，这里的基础类型指的是“change”，而不是name，需区分清楚。</li></ul><ol start="2"><li>基本数据类型不可以添加属性和方法<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function-variable function">method</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>通过上面的代码，我们知道不能给基本类型添加属性和方法，也再次说明基本类型是不可变的。</li><li>基本数据类型的赋值是简单赋值</li></ol><p>如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>a<span class="token operator">++</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中， a 中保存的值是10。当使用 a 的值来初始化 b 时， b 中也保存了值 10 。但 b 中的 10 和 a 中的 10 是完全独立的。 b 中的值只是 a 中值的一个副本。所以这两个变量可以参与任何操作而不会相互影响。<br>4. 基本数据类型的比较是值的比较</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面 a 和 b 的数据类型不同，但是也可以进行值的比较，这是因为在比较之前，自动进行了数据类型的 隐式转换。<br>5. 基本数据类型是存放在栈区的</p><p>假如有以下几个基本类型的变量：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"jozo"</span><span class="token punctuation">;</span><span class="token keyword">var</span> city <span class="token operator">=</span> <span class="token string">"guangzhou"</span><span class="token punctuation">;</span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么它的存储结构如下所示：<br>|栈区A|栈区A|<br>|:–:|:–:|<br>|name|jozo|<br>|city|guangzhou|<br>|age|22|</p><p>同一个栈区里包括了变量的标识符和变量的值</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h4 id="引用数据类型的特性"><a href="#引用数据类型的特性" class="headerlink" title="引用数据类型的特性"></a>引用数据类型的特性</h4><ol><li>引用类型的值是可以改变的</li><li>引用类型可以添加属性和方法</li><li>引用类型是同时保存在栈区和堆区中的</li></ol><p>引用类型的存储需要在内存的栈区和堆区共同完成，栈区保存变量标识符和指向堆内存的地址</p><p>假如有以下两个对象：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> man <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> woman <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>man <span class="token operator">===</span> woman<span class="token punctuation">)</span> <span class="token comment">// 输出：false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则这两个对象在内存中保存的情况如下图：<br><img src="https://s4.ax1x.com/2021/12/06/osS36O.png" alt="变量在内存中的保存情况"><br>4. 引用类型的赋值是对象引用</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"change"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change</span>b<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 a 向 b 赋值引用类型的值时，同样也会将储存在 a 中的对象的值复制一份，并放到为 b 分配的空间中。此时引用类型保存在 b 中的是对象在堆内存中的地址。所以，与基本数据类型的简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。那么赋值操作后，两个变量都保存了同一个对象地址，而这两个地址指向了同一个对象。因此，改变其中任何一个变量，都会互相影响。 他们的关系如下图：<br><img src="https://s4.ax1x.com/2021/12/06/osSDc8.png" alt="变量赋值后在内存中的保存情况"><br>5. 引用类型的比较是引用的比较</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token operator">==</span> person2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Q：为什么两个对象看起来一摸一样，但是却不相等呢？</li><li>A：因为引用类型的比较是引用的比较，换句话说，就是比较两个对象保存在栈区的指向堆内存的地址是否相同，此时，虽然 p1 和 p2 看起来都是一个”{}”，但是他们保存在栈区中的指向堆内存的地址却是不同的，所以两个对象不相等<h2 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h2><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3>用于确定任意变量的数据类型，对一个值使用 <code>typeof</code> 操作符会返回下列字符串之一：</li><li>“undefined” 表示值未定义；</li><li>“boolean” 表示值为布尔值；</li><li>“string” 表示值为字符串；</li><li>“number” 表示值为数值；</li><li>“object” 表示值为对象（而不是函数）或 null；</li><li>“function” 表示值为函数；</li><li>“symbol” 表示值为符号；</li></ul><p>使用 typeof 操作符的示例：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// es5</span><span class="token keyword">typeof</span> <span class="token string">''</span>           <span class="token comment">// string</span><span class="token keyword">typeof</span> <span class="token number">1</span>            <span class="token comment">// number</span><span class="token keyword">typeof</span> <span class="token boolean">true</span>         <span class="token comment">// boolean</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span>    <span class="token comment">// undefined</span><span class="token keyword">typeof</span> Array        <span class="token comment">// function</span><span class="token keyword">typeof</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>           <span class="token comment">// object</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>           <span class="token comment">// object</span><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// symbol</span><span class="token keyword">typeof</span> console      <span class="token comment">// object</span><span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log  <span class="token comment">// function</span><span class="token keyword">typeof</span> <span class="token keyword">null</span>         <span class="token comment">// object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是：<code>null</code> 会返回  <code>&quot;object&quot;</code> 是因为特殊值 <code>null</code> 被认为是一个对空对象的引用（这只是 <code>JavaScript</code> 存在的一个悠久 Bug，不代表 <code>null</code> 就是引用数据类型，并且 <code>null</code> 本身也不是对象）。那为什么会被这么认为呢？这就需要了解变量是如何被存储的。在 <code>Javascript</code> 底层存储变量的时候，会在变量的机器码低位 1-3 位表示类型信息：</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li><li>null：所有码都是0</li><li>undefined：用 -2^30 表示</li></ul><p>而 <code>null</code> 的低位 1-3 解析到的为 000，刚好与 <code>object</code> 一样，因此就被当做了对象来看待。</p></blockquote><p><code>typeof</code> 的实现大致如下，在 JS 诞生之初就只有六种类型判断：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_VOID</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断是否为 undefined</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_VOID</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_OBJECT</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 object</span>  obj <span class="token operator">=</span> <span class="token constant">JSVAL_TO_OBJECT</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ops <span class="token operator">=</span> obj<span class="token operator">-</span><span class="token operator">></span>map<span class="token operator">-</span><span class="token operator">></span>ops<span class="token punctuation">,</span> ops <span class="token operator">==</span> <span class="token operator">&amp;</span>js_ObjectOps<span class="token punctuation">)</span>     <span class="token operator">?</span> <span class="token punctuation">(</span>clasp <span class="token operator">=</span> <span class="token constant">OBJ_GET_CLASS</span><span class="token punctuation">(</span>cx<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">,</span> clasp<span class="token operator">-</span><span class="token operator">></span>call <span class="token operator">||</span> clasp <span class="token operator">==</span> <span class="token operator">&amp;</span>js_FunctionClass<span class="token punctuation">)</span>    <span class="token operator">:</span> ops<span class="token operator">-</span><span class="token operator">></span>call <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    type <span class="token operator">=</span> <span class="token constant">JSTYPE_FUNCTION</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    type <span class="token operator">=</span> <span class="token constant">JSTYPE_OBJECT</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_NUMBER</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 number</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_NUMBER</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_STRING</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 string</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_STRING</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSVAL_IS_BOOLEAN</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断是否为 boolean</span>  type <span class="token operator">=</span> <span class="token constant">JSTYPE_BOOLEAN</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p>使用方法：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 判断一个实例是否属于某种类型：</span><span class="token keyword">let</span> <span class="token function-variable function">person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> nicole <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nicole <span class="token keyword">instanceof</span> <span class="token class-name">person</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token comment">// 判断一个实例是否是其父类型或者祖先类型的实例</span><span class="token keyword">let</span> <span class="token function-variable function">person</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token function-variable function">programmer</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>programmer<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> nicole <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">programmer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nicole <span class="token keyword">instanceof</span> <span class="token class-name">person</span> <span class="token comment">// true</span>nicole <span class="token keyword">instanceof</span> <span class="token class-name">programmer</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法挺简单的，那么其底层实现原理是什么呢？根据 ECMAScript 语言规范，大概的思路如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">new_instance_of</span><span class="token punctuation">(</span><span class="token parameter">leftVaule<span class="token punctuation">,</span> rightVaule</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">let</span> rightProto <span class="token operator">=</span> rightVaule<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 取右表达式的 prototype 值</span>  leftVaule <span class="token operator">=</span> leftVaule<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// 取左表达式的__proto__值</span>  <span class="token comment">// 循环体一直循环，直到在 leftVaule 的原型链上找到 rightVaule；或者走到 leftVaule 原型链的尽头也还是找不到 rightVaule ，则退出循环</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVaule <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVaule <span class="token operator">===</span> rightProto<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 不用执行 rightVaule = rightVaule.__proto__ ，因为 rightVaule 就是要查找的对象</span>    leftVaule <span class="token operator">=</span> leftVaule<span class="token punctuation">.</span>__proto__ <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总而言之，<code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，要想理解 <code>instanceof</code> 的原理，就还必须熟悉 JavaScript 的原型继承原理，不太清楚的小伙伴可以浏览我的 <a href="https://hcyety.github.io/2022/01/03/yuan-xing-lian/">另一篇文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的各种增删查改</title>
      <link href="/2021/11/22/shu-zu-de-ge-chong-zeng-shan-cha-gai/"/>
      <url>/2021/11/22/shu-zu-de-ge-chong-zeng-shan-cha-gai/</url>
      
        <content type="html"><![CDATA[<h2 id="一、增"><a href="#一、增" class="headerlink" title="一、增"></a>一、增</h2><h3 id="1-push-【改变原数组】"><a href="#1-push-【改变原数组】" class="headerlink" title="1. push 【改变原数组】"></a>1. push 【改变原数组】</h3><p><strong>定义：</strong><code>push()</code> 方法（在数组结尾处）向数组添加一个或多个新元素，返回值为新数组的长度</p><p><strong>语法：</strong><code>arr.push(ele,ele2,ele3…);</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> m <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'arr:'</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">'m'</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// arr:[1, 2, 3, 4, 5] m:5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-unshift-【改变原数组】"><a href="#2-unshift-【改变原数组】" class="headerlink" title="2. unshift 【改变原数组】"></a>2. unshift 【改变原数组】</h3><p><strong>定义：</strong><code>unshift()</code>方法（在开头）向数组添加一个或多个新元素，并“反向位移”旧元素，返回值为新数组的长度</p><p><strong>语法：</strong><code>arr.unshift(ele,ele2,ele…);</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> m <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"原数组："</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">"返回值:"</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原数组： ["a", "b", 1, 2] 返回值:4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-concat-【合成一个新数组，不改变原数组】"><a href="#3-concat-【合成一个新数组，不改变原数组】" class="headerlink" title="3. concat 【合成一个新数组，不改变原数组】"></a>3. concat 【合成一个新数组，不改变原数组】</h3><p><strong>定义：</strong><code>concat()</code> 方法通过合并（连接）一个或多个数组来创建一个新数组</p><p><strong>语法：</strong><code>arr.concat(arr1,arr2…);</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 合并两个数组</span><span class="token keyword">var</span> myGirls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Cecilie"</span><span class="token punctuation">,</span> <span class="token string">"Lone"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myBoys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Emil"</span><span class="token punctuation">,</span> <span class="token string">"Tobias"</span><span class="token punctuation">,</span> <span class="token string">"Linus"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myChildren <span class="token operator">=</span> myGirls<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>myBoys<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 连接 myGirls 和 myBoys</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myChildren<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Emma","Isabella","Jacob","Michael","Ethan"]</span><span class="token comment">// 合并三个数组</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Cecilie"</span><span class="token punctuation">,</span> <span class="token string">"Lone"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Emil"</span><span class="token punctuation">,</span> <span class="token string">"Tobias"</span><span class="token punctuation">,</span> <span class="token string">"Linus"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Robin"</span><span class="token punctuation">,</span> <span class="token string">"Morgan"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myChildren <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span> arr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ["Cecilie","Lone","Emil", "Tobias", "Linus","Robin", "Morgan"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-length-属性"><a href="#4-length-属性" class="headerlink" title="4. length 属性"></a>4. length 属性</h3><p>使用数组的 <code>length</code> 属性向数组添加新元素</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">[</span>fruits<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Lemon"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana","Orange","Apple","Mango","Lemon"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong><br>添加最高索引的元素可在数组中创建未定义的“洞”：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Lemon"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana","Orange","Apple","Mango","undefined","undefined","Lemon"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="splice-【改变原数组】"><a href="#splice-【改变原数组】" class="headerlink" title="splice 【改变原数组】"></a>splice 【改变原数组】</h3><p><strong>定义：</strong><code>splice()</code> 方法在数组中添加/删除/查看/修改项目，并返回删除的项目。</p><p><strong>语法：</strong><code>array.splice(index, howmany, item1, ....., itemX)</code>  </p><p><strong>参数：</strong></p><ul><li>index：必需。整数，指定在什么位置添加/删除项目，使用负值指定从数组末尾开始的位置。</li><li>howmany：可选。要删除的项目数。如果设置为 0，则不会删除任何项目。</li><li>item1, …, itemX：可选。要添加到数组中的新项目。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 第二个参数为 0 且有第三个或三个以上的参数即说明是增加元素，增加的元素数量为第二个参数之后的参数数量</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"Lemon"</span><span class="token punctuation">,</span> <span class="token string">"Kiwi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana","Orange","Lemon","Kiwi","Apple","Mango"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、删"><a href="#二、删" class="headerlink" title="二、删"></a>二、删</h2><h3 id="delete-【改变原数组】"><a href="#delete-【改变原数组】" class="headerlink" title="delete 【改变原数组】"></a>delete 【改变原数组】</h3><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">delete</span> fruits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ["undefined", "Orange", "Apple", "Mango"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="shift-【改变原数组】"><a href="#shift-【改变原数组】" class="headerlink" title="shift 【改变原数组】"></a>shift 【改变原数组】</h3><p><strong>定义：</strong><code>shift()</code> 方法删除数组的第一个元素，并返回删除的这个元素</p><p><strong>语法：</strong><code>array.shift();</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"原数组："</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">"返回值:"</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原数组： [2] 返回值:1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pop-【改变原数组】"><a href="#pop-【改变原数组】" class="headerlink" title="pop 【改变原数组】"></a>pop 【改变原数组】</h3><p><strong>定义：</strong><code>pop()</code> 方法删除数组的最后一个元素，并返回删除的这个元素</p><p><strong>语法：</strong><code>array.pop();</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"原数组："</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">"返回值:"</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原数组： [1] 返回值:2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>第二个参数不为 0 且无第三个参数则说明是从 以第一个参数为下标值 开始删除数组元素，删除的数组元素个数为第二个参数的值</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 在位置 2，添加新项目，并删除 1 个项目：</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana", "Orange", "Lemon"]</span><span class="token comment">// 在位置 2，删除 2 个项目：</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">,</span> <span class="token string">"Kiwi"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Banana", "Orange", "Kiwi"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、查"><a href="#三、查" class="headerlink" title="三、查"></a>三、查</h2><h3 id="slice-【不改变原数组】"><a href="#slice-【不改变原数组】" class="headerlink" title="slice 【不改变原数组】"></a>slice 【不改变原数组】</h3><p><strong>定义：</strong><code>slice()</code> 方法将原来的数组的元素替换，返回新的数组。</p><p><strong>语法：</strong><code>array.slice(start, end);</code></p><p><strong>参数：</strong></p><ul><li>start：可选。整数，指定从哪里开始选择（第一个元素的索引为 0）；若使用负数则从数组的末尾进行选择；如果省略，则类似于 “0”。</li><li>end：可选。整数，指定结束选择的位置；如果省略，将选择从开始位置到数组末尾的所有元素；若使用负数则从数组末尾进行选择。</li></ul><p><strong>注意：选定参数后，区间范围为【左闭右开】。即操作数组时，只截取从 start 到 end - 1 位置的数组元素</strong></p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 两个参数都不写，就是复制完整数组；否则就是复制指定元素的数组</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"aaaa"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> newArr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [4, 5, 6, 3, 7, 8, 8]  ["aaaa", 5, 6, 3, 7, 8, 8]</span><span class="token comment">// 使用正值选择元素：</span><span class="token keyword">const</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Lemon"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> citrus <span class="token operator">=</span> fruits<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>citrus<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Orange","Lemon"]</span><span class="token comment">// 使用负值选择元素：</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Lemon"</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Mango"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> myBest <span class="token operator">=</span> fruits<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myBest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["Lemon","Apple"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p><strong>定义：</strong><code>includes()</code> 方法返回一个布尔值，表示某个数组是否包含给定的值</p><p><strong>语法：</strong><code>Array.includes(para, start);</code></p><p><strong>参数：</strong></p><ul><li>para：必需。表示要查找的值。</li><li>start：可选。表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       <span class="token comment">// true</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>       <span class="token comment">// false</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span>   <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p><strong>定义：</strong><code>indexOf</code> 法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1</p><p><strong>语法：</strong><code>Array.indexOf(para, index);</code></p><p><strong>参数：</strong></p><ul><li>para：必需。要查找的元素。</li><li>index：可选。开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1；如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找……。 注意：如果参数中提供的索引值是一个负值，并<strong>不改变其查找顺序</strong>，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 0</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// -1</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span>array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="find-【不改变原数组】"><a href="#find-【不改变原数组】" class="headerlink" title="find 【不改变原数组】"></a>find 【不改变原数组】</h3><p><strong>定义：</strong><code>find()</code> 方法返回通过测试（函数内判断）的数组的第一个元素的值。</p><p><strong>语法：</strong><code>Array.find(function(currentValue, index, arr),thisValue)</code></p><p><strong>参数：</strong></p><ul><li>function：必需。数组每个元素需要执行的函数。<ul><li>currentValue：必需。当前元素。</li><li>index：可选。当前元素的索引值。</li><li>arr：可选。当前元素所属的数组对象。</li></ul></li><li>thisValue：可选。传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值</li></ul><p><strong>说明：</strong><br>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</li><li>如果没有符合条件的元素返回 undefined</li></ul><p><strong>注意：</strong><br>find() 对于空数组，函数是不会执行的。</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> inventory <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'apples'</span><span class="token punctuation">,</span> quantity<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'bananas'</span><span class="token punctuation">,</span> quantity<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'cherries'</span><span class="token punctuation">,</span> quantity<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">findCherries</span><span class="token punctuation">(</span><span class="token parameter">fruit</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> fruit<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'cherries'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inventory<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>findCherries<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123; name: 'cherries', quantity: 5 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、改"><a href="#四、改" class="headerlink" title="四、改"></a>四、改</h2><h3 id="splice-1"><a href="#splice-1" class="headerlink" title="splice"></a>splice</h3><p>第二个参数不为 0 且有第三个或三个以上的参数则说明是从 以第一个参数为下标值 开始修改数组元素，修改的数组元素个数为第二个参数之后的参数数量</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> newArr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [4, 5, "a", "b", 3, 7, 8, 8] [6]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="reverse-【改变原数组】"><a href="#reverse-【改变原数组】" class="headerlink" title="reverse 【改变原数组】"></a>reverse 【改变原数组】</h3><p><strong>定义：</strong><code>reverse()</code> 方法可以反转数组中的所有元素</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'arr:'</span> <span class="token operator">+</span> arr<span class="token punctuation">,</span> <span class="token string">'newArr:'</span> <span class="token operator">+</span> newArr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// arr:[5,4,3,2,1] newArr:[5,4,3,2,1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><strong>定义：</strong><code>reduce()</code> 方法对数组中的每个元素执行一个由您提供的函数(升序执行)，将其结果汇总为单个返回值。</p><p><strong>语法：</strong><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></p><p><strong>参数：</strong></p><ul><li>function(total,currentValue, index,arr)：必需。用于执行每个数组元素的函数。<ul><li>total：必需。初始值, 或者累计器累计回调的返回值。</li><li>currentValue：必需。当前元素。</li><li>currentIndex：可选。当前元素的索引。如果提供了<code>initialValue</code>，则起始索引号为0，否则从索引1起始。</li><li>arr：可选。调用reduce()的数组。</li></ul></li><li>initialValue：可选。传递给函数的初始值。如果没有提供初始值，则将使用数组中的第一个元素。</li></ul><p><strong>注意：</strong><br><code>reduce()</code> 对于空数组是不会执行回调函数的。</p><p><strong>示例：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> num</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> total <span class="token operator">+</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> ans <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>getSum<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 125</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对数组的各种操作就整理到这，如果读者没有找到自己想要的内容，可以尝试找找阮一峰的 <a href="https://es6.ruanyifeng.com/#docs/array">ECMAScript 6 入门 之数组的扩展</a>，或许能有所收获！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout() 与 setInterval() 的区别</title>
      <link href="/2021/11/15/settimeout-yu-setinterval-de-qu-bie/"/>
      <url>/2021/11/15/settimeout-yu-setinterval-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先要对 setTimeout() 和 setInterval() 有一个概念，学习了 JavaScript 我们知道：<strong>setTimeout() 是延时器，setInterval() 是定时器</strong>。setTimeout() 在于载入后延迟指定的时间后才会执行<strong>一次</strong>表达式，执行过后便会停止；setInterval() 在载入后每隔指定时间就会执行一次表达式，直到定时器或者窗口关闭。</p><p>对这两者有了初步印象后，我们开始逐个分析</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>setTimeout() 方法在指定的毫秒数后调用一次函数或计算表达式。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>var timeoutID = setTimeout(code/function, millisec)</code></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>code/funciton：必需。要调用的函数后要执行的 JavaScript 代码串或者函数。</li><li>millisec：必需。在执行代码前需等待的毫秒数。<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4>返回值 timeoutID 是一个正整数，表示定时器的编号。这个值可以传递给clearTimeout()来取消该定时器。<h3 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h3>setTimeout() <strong>只执行 code 一次</strong>。如果要<strong>多次调用</strong>，请<strong>使用 setInterval() 或者让 code 自身再次调用 setTimeout()</strong><h3 id="清除-setTimeout"><a href="#清除-setTimeout" class="headerlink" title="清除 setTimeout()"></a>清除 setTimeout()</h3><code>clearTimeout(timeoutID)</code><br>timeoutID 为调用 setTimeout() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout() 所设定的定时执行操作。<h3 id="统一示例"><a href="#统一示例" class="headerlink" title="统一示例"></a>统一示例</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">eg</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你好'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//使用方法名字执行方法</span><span class="token keyword">let</span> t1 <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>eg<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用字符串执行方法</span><span class="token keyword">let</span> t2 <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"eg()"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除定时器</span>window<span class="token punctuation">.</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3></li><li>用于延迟执行某方法或功能</li></ul><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>setInterval() 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>语法与 setTimeout() 相同：</p><p><code>var intervalID = setInterval(code/function, delay)</code></p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>code/funciton：必需。要调用的函数后要执行的 JavaScript 代码串或者函数。</li><li>millisec：必需。在执行代码前需等待的毫秒数。<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4>此返回值 intervalID 是一个非零数值，用来标识通过setInterval()创建的计时器，这个值可以用来作为clearInterval()的参数来清除对应的计时器 。<h3 id="提醒-1"><a href="#提醒-1" class="headerlink" title="提醒"></a>提醒</h3>setInterval() 会<strong>重复执行多次</strong>。如果想<strong>只执行一次</strong>，请<strong>使用 setTimeout()</strong><h3 id="清除-setInterval"><a href="#清除-setInterval" class="headerlink" title="清除 setInterval()"></a>清除 setInterval()</h3><code>clearInterval(intervalID)</code><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3></li><li>用于刷新表单，对于一些表单的实时指定时间刷新同步</li></ul><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>在项目中使用这两者的时候会发现，调用函数的时候时间间隔虽然几乎相同，但并不精确，这时候如果项目中用这两者做动态效果，可能会发现：当程序中同时出现其他各种事件处理程序时，动画会变得不够平滑。那为什么会出现这种情况？</p><p>这是由于 JavaScript 其实是运行在单线程环境中的，这就意味着定时器仅仅是计划代码在未来的某个时间执行，而具体执行时机是不能保证的。<br>打个比方：我设置了一个定时器，这时候这个定时器事件就会被添加到待执行事项中，如果在这个定时器事件之前没有其他事件排队等待执行的话，就可以立即执行定时器事件；但如果前面有很多且耗时很久的事件等待执行，那这个定时器事件就不得不推迟时间执行了，这样一来，就不能如时按照指定的时间运行代码了。<br>因为这样，才会导致 setTimeout 和 setInterval 执行的时间间隔不能精确。那么有读者可能会问，影响这个时间间隔的因素是什么？答案是运行这两个方法的宿主环境，不同的浏览器、不同系统、不同版本的测试环境都会对其造成影响，事实上 GitHub 上早已有人 issue 该问题，然而至今仍然处于 open 状态：<a href="https://link.zhihu.com/?target=https://github.com/nodejs/node-v0.x-archive/issues/8066">setInterval doesn’t comply with DOM-version</a>、<a href="https://link.zhihu.com/?target=https://github.com/nodejs/node/issues/7346">setInterval interval includes duration of callback</a>、<a href="https://link.zhihu.com/?target=https://github.com/nodejs/node/issues/7554">setInterval/setTimeout interval should not include duration of callback</a></p><p>后面这个问题如果解决了，笔者会再来更新的~</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>知道 setTimeout() 和 setInterval() 是怎么一回事之后，在项目中合理采用就好了，一般问题不大，可能面试的时候会问到更加深入的东西？笔者也不知道呢，毕竟暂无面试经历，但准备面试过程中应该也少不了这方面的知识点拓展，有备无患 Orz。</p><p>这篇文章有相关的使用案例，可供读者参考：</p><blockquote><p><a href="https://www.cnblogs.com/lynnmn/p/6222753.html">setTimeout和setInterval的区别以及如何写出效率高的倒计时</a></p></blockquote><p>如果有说得不对的地方，还烦请大佬们指正，笔者愿与大家一起探讨 (<em>^▽^</em>)~~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tell it to myself</title>
      <link href="/2021/11/08/tell-it-to-myself/"/>
      <url>/2021/11/08/tell-it-to-myself/</url>
      
        <content type="html"><![CDATA[<h2 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h2><p>实习项目从开始做到现在已经过去 10 个星期了，前 9 个星期一直在努力实现各种模块各种功能点，直到上个星期才开始准备记笔记（也就因此搭建了个人博客），搭了一两天后博客已经运行起来，然后开始写博客的期间又断断续续更新了一部分主题配置，一个星期也就过去 2/3 了，这个时候我其实有点沉不住气了，因为想着快点弄完这些鸡毛蒜皮的事才好去接着开发项目的其他功能，于是耐着性子修复了项目一小部分的 bug 后（此时就已经发现的 bug 还有挺多的，但我没有心情全部修复），终于在周末的时候向 @Dangosky 交任务了，在这次聊天中我认识到了一个基本但极为重要的事情……</p><h2 id="重点敲黑板"><a href="#重点敲黑板" class="headerlink" title="重点敲黑板"></a>重点敲黑板</h2><p>Dangosky 跟我说，<strong>做项目追求速度而不注重质量，这样的项目做出来是没有什么用处的</strong>。</p><p>这样说是有道理的，他说：</p><ul><li>初学者做项目最忌讳冒进，贪多嚼不烂</li><li>首先要明确一点，做项目第一目标是从中学习东西，第二目标是有个项目经历之后才好些简历</li><li>同一个项目，即使你一个月搞出来了，但很多 bug ，很多设计问题、很多 bad case 没考虑到，面试官一问，什么都没想到、很多都答不出来，这样的项目做得再快也没用的</li><li>相反，你一个项目即使做上半年，但你做得很有质量，很多方面都考虑到了，甚至还思考到了项目可以拓展的地方（比如实现国际化语言等等），面试官一问你这个项目有什么亮点或不足，你能够头头是道，让你讲个二十分钟你都讲不完，这两种情况是完全不一样的</li></ul><p>我就属于注重速度那一类，没有沉住气来着重项目质量，以及完全吸收从项目中学习到的东西，反而总是想着要搞快点搞快点，抓紧时间把项目给搞出来，以至于忽略了做这个项目的初心。但现在我明白了，做这个项目最重要的应该是从中学习到新知识、新技术等，把自己的项目经历丰富起来，不应该倾向于开发速度。</p><p>同时，在做项目的过程中，bug 是必不可少的，<strong>解决 bug 也是一种提升实力的方式</strong>。<br>Dangosky 说：</p><ul><li>初学阶段，卡 bug 本身就是一种学习了</li><li>只是这种学习方式很难受，因为一直卡在那个地方解决不了，难免心态不好自我怀疑，比不上你敲代码实现一个新功能来的有成就感</li><li>但卡 bug 是每个人学习的必经之路，是躲不掉的。在工作之后，一个团队中也会有几个人一直是在修 bug ，摆正心态、明确目标就好了</li></ul><p>就我亲身经历而言，一开始做项目的时候，我会卡在一个地方不知道怎么办，那种感觉就像无头苍蝇一样，面对代码无从下手，要么是不知道从哪里排查问题，要么排查的方向有误，导致浪费了很多的时间。但渐渐的，我掌握一些技巧和方法了，知道一个报错该去什么地方解决，之后很多问题根据差不多的思路也可以很快找到对应的解决方法。这些都是在解决 bug 之后积累出来的经验，所以对于 <strong>卡 bug 本身就是一种学习</strong> 这句话，我是举双手双脚赞成的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>知道了自己“右倾”、心态不对劲之后，接下来我要做的便是摆正好心态、明确自己的目标了，心中有量尺，之后做的事就会有分寸。</p><blockquote><p>以此篇记录我在做项目过程中遇到的思想误区，告诫自己以后莫要再犯同样的错误了！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目之登录/注册模块</title>
      <link href="/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/"/>
      <url>/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客：<a href="https://hcyety.github.io/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/">React-Ts 项目：在线编程笔试平台</a> 有说到，这个项目是前后端分离项目，也就是说，其实该项目相当于两个项目，分别专注前端和后端，如果要上传到 <code>github</code> ，那么就需要创建两个仓库来分别放置。博主已经将源码 push ，读者可以跳转查阅：<a href="https://github.com/HCYETY/Online-programming-platform">前端项目仓库</a> — <a href="https://github.com/HCYETY/Online-programming-platform_service">后端项目仓库</a></p><p>前端项目采用的技术栈是 <code>React</code> 。UI 的设计是上下布局，即头部导航栏、下面主体内容，其中使用了 antd4 的 <code>Card</code> 和 <code>Form</code> 组件，效果如图所示：<img src="https://z3.ax1x.com/2021/11/02/IkyIBQ.png" alt="登录"><img src="https://z3.ax1x.com/2021/11/02/Ik63gf.png" alt="注册"></p><blockquote><p>本来想实现的效果是翻转卡片，即点击“登录”或“注册”就能将卡片翻转，同时“登录”面带有标签，可以切换登录方式：邮箱登录和账号登录，但奈何一直找不到合适的解决方法，就使用了 antd 的 <strong>带标签页的卡片</strong>，如果读者知道如何解决这一问题，还望不吝赐教 ^_^</p></blockquote><p>后端项目采用的技术栈是 <code>NodeJs</code> ，使用的数据库是 <code>MYSQL</code> 。项目中运用了 <code>Koa</code> 和 <code>TypeORM</code> 框架来搭建 <code>Node</code> 服务和操作  <code>MYSQL</code> 数据库。</p><blockquote><p>项目所使用的技术栈读者已经清楚，我们继续往下看吧~~</p></blockquote><h2 id="注册模块（支持邮箱注册）"><a href="#注册模块（支持邮箱注册）" class="headerlink" title="注册模块（支持邮箱注册）"></a>注册模块（支持邮箱注册）</h2><h3 id="code-前思考"><a href="#code-前思考" class="headerlink" title="code 前思考"></a>code 前思考</h3><p>首先我们需要理清注册的逻辑，联想我们在一个网站上注册时，操作流程是怎么样的。我们可以很快知道，通常有两种方式，一种是手机号注册，一种是邮箱注册。</p><ol><li><p>手机号注册<br><img src="https://z3.ax1x.com/2021/11/03/IAj9Rx.jpg" alt="常见手机注册"></p></li><li><p>邮箱注册<br><img src="https://z3.ax1x.com/2021/11/03/IAXWqg.jpg" alt="常见邮箱注册"></p></li></ol><blockquote><p>注册的方式有很多种，除了手机邮箱注册，还有用户名/xx号注册、第三方注册等，具体想选择哪种方式实现注册，读者可以自行选择，下面我们还需要来看看如何实现前后端的连接，以跑通整个项目。</p></blockquote><blockquote><p>情况说明：博主选择的方式是邮箱注册。</p></blockquote><h3 id="逻辑思考"><a href="#逻辑思考" class="headerlink" title="逻辑思考"></a>逻辑思考</h3><ol><li>用户在前端界面填写表单信息，点击“获取验证码”按钮后，会【发送请求】给后端</li><li>后端【接收前端传来的请求】后，会随机生成一个包含大小写字母和数字的 6 位数验证码，并将该验证码存储在数据库中，同时【响应数据】（这里指验证码）给前端。</li><li>前端【接收后端响应体】（这里指后端传过来的验证码）后，必须填入表单中才能提交（表单组件可以在 rule 里设定 required ）。</li><li>点击“提交”后，这时前端发送的请求体中包含了表单中的所有数据，同样将其发送给后端。后端获取请求体中的所有信息，根据邮箱账号从数据库中查询是否已经存储了该用户，若查找不到则说明无人使用该邮箱注册过，可以允许注册，将邮箱和密码等相关信息一并存进数据库中；否则直接响应数据，告知前端该用户已经注册。前端根据后端响应的信息进行对应的操作，如注册成功，可以跳转到登录页面进行登录，否则弹出警告，告知用户注册信息填写有误。</li></ol><blockquote><p>说到这里，读者应该懂得了将前后端项目串联起来的一系列逻辑，概括起来便是前端调用后端接口【发送请求】，后端设定接口给前端调用【接收请求】，这样一来前后端便可以互连跑通服务了。</p></blockquote><blockquote><p>但问题来了，“你说了这么多，我还是不知道该怎么在前端调用后端接口，后端又如何接收到前端传来的请求”？别急，博主只是先抛砖引玉，先给大家捋顺跑通前后端服务的逻辑，心里好有个底。下面我们继续往下</p></blockquote><ol start="5"><li>前端发送请求的方式有多种，如 fetch、axios 等，这里使用的是 axios ，下面自定义封装的 axios 函数，仅供大家参考：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录下/src/api/index.ts</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span><span class="token comment">// 注意这个路径，http://localhost:8080 是后端服务的地址，/api 是请求的固定格式，后面调用该函数的时候还会再传入一个参数 /xxx ，因此后端要想接收前端请求，就必须配置接口路径成 前端服务的地址/api/xxx ，这样前后端项目才能跑通【不理解的话后面代码还会有注释】</span><span class="token keyword">const</span> <span class="token constant">REQUESTIP</span><span class="token operator">:</span> string <span class="token operator">=</span> <span class="token string">"http://localhost:8080/api"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span>method<span class="token operator">:</span> <span class="token string">'get'</span> <span class="token operator">|</span> <span class="token string">'post'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">url<span class="token operator">:</span> string<span class="token punctuation">,</span> params<span class="token operator">?</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> data <span class="token operator">=</span> method <span class="token operator">===</span> <span class="token string">'get'</span> <span class="token operator">?</span> <span class="token punctuation">&#123;</span>      params    <span class="token punctuation">&#125;</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      data<span class="token operator">:</span> params    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 调用函数时会传入 url （相当于上面说的xxx），在这里进行拼接，就成了前端调用后端接口的完整 url 了：后端服务地址/api/xxx</span>    url <span class="token operator">=</span> <span class="token constant">REQUESTIP</span> <span class="token operator">+</span> url<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        url<span class="token punctuation">,</span>        method<span class="token punctuation">,</span>        <span class="token operator">...</span>data<span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">const</span> get <span class="token operator">=</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> post <span class="token operator">=</span> <span class="token function">generateHttpApi</span><span class="token punctuation">(</span><span class="token string">'post'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>调用 axios 封装函数的时候：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录/src/api/modules/interface.ts</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> post <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'根目录/src/api/index'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testRegister</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token operator">:</span> <span class="token punctuation">&#123;</span> email<span class="token operator">:</span> string<span class="token punctuation">;</span> cypher<span class="token operator">:</span> string<span class="token punctuation">;</span> captcha<span class="token operator">:</span> string<span class="token punctuation">;</span> identity<span class="token operator">:</span> number<span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 此时前端请求的整个路径为 http://localhost:8080/api/register，那么假设前端项目地址为 http://localhost:3000 ，后端就需要定义接口路径为 http://localhost:3000/api/register</span>  <span class="token keyword">return</span> <span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/register'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 文件结构：根目录/src/pages/login/index.tsx</span><span class="token comment">// 这里结构其实不是很好，因为注册和登录是写在一块的，没有分开来。读者清楚是在注册事件下发送 axios 请求的就好</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> testRegister <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'根目录/src/api/modules/interface'</span><span class="token punctuation">;</span>  <span class="token comment">// 点击“注册”按钮触发的函数：</span><span class="token function-variable function">submitRegister</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">values<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 表单的值</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> account<span class="token punctuation">,</span> password<span class="token punctuation">,</span> identity<span class="token punctuation">,</span> email<span class="token punctuation">,</span> cypher<span class="token punctuation">,</span> captcha <span class="token punctuation">&#125;</span> <span class="token operator">=</span> values<span class="token punctuation">;</span>  <span class="token comment">// 请求参数</span>  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> email<span class="token punctuation">,</span> cypher<span class="token punctuation">,</span> captcha<span class="token punctuation">,</span> identity <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// ！发送请求并获取返回值</span>  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">testRegister</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注册成功</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在当前页跳转至登录界面</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> noTitleKey<span class="token operator">:</span> <span class="token string">'login'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    message<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>然后是在后端定义接口。博主的后端项目使用了 <code>Koa</code> 框架，因此可以调用它的 API :</li></ol><blockquote><p>注意：如果是本地项目要解决跨域，Koa 可以使用 koa2-cors 直接解决；但如果是线上项目的话，还需要另外的配置，网上有多种处理跨域的解决方法，博主采用的方法是配置 nginx 反向代理，具体操作可以跳转到另一篇博客：<a href="https://hcyety.github.io/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/">前后端分离项目线上部署</a>，里面有配置 nginx 的具体步骤，在这里不加叙述。</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 下面 code 仅供参考，大致是这么一个模式</span><span class="token keyword">import</span> Koa <span class="token keyword">from</span> <span class="token string">'koa'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'koa-router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> bodyParser <span class="token keyword">from</span> <span class="token string">'koa-bodyparser'</span><span class="token punctuation">;</span>        <span class="token comment">// 处理 post 请求，有了这个插件才能获取 post 参数【通常前端的请求方式是 post 】</span><span class="token keyword">import</span> cors <span class="token keyword">from</span> <span class="token string">'koa2-cors'</span><span class="token punctuation">;</span> <span class="token comment">// 处理跨域问题</span><span class="token keyword">import</span> register <span class="token keyword">from</span> <span class="token string">'./middleware/register'</span><span class="token punctuation">;</span>   <span class="token comment">// 导入注册的 .ts 文件，用于处理注册事件【通常不放在入口文件里，而是单独抽出来】</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cors</span><span class="token punctuation">(</span>corsOptions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 处理 post 请求的参数。</span><span class="token comment">// 注意这个插件的位置，必须要放在匹配接口之前！！！</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">bodyParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 匹配接口，这里的路径和前端请求路径中端口号后面那部分是保持一致的</span>router<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/api/register'</span><span class="token punctuation">,</span> register<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 组装匹配好的路由，返回一个合并好的中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里启动的后端服务是 8080 端口</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'网站服务器启动成功，请访问 http://localhost:8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>说一句：定义好了后端接口，可以查阅 <a href="https://cloud.tencent.com/developer/article/1876810">postman 使用教程</a>，在 <a href="https://www.postman.com/downloads/">postman 官网</a> 下载 <code>postman</code> ，方便测试接口是否被成功调用，推荐使用！</p></blockquote><h2 id="登录模块（支持邮箱登录）"><a href="#登录模块（支持邮箱登录）" class="headerlink" title="登录模块（支持邮箱登录）"></a>登录模块（支持邮箱登录）</h2><ol><li>跑通前后端服务的逻辑同注册一致，也是【前端发送请求】–【后端接收请求】–【后端响应请求】 –【前端接收响应】 </li></ol><blockquote><p>然而这样简单地实现登录功能，用户是可能通过控制台篡改后端的响应数据的，进而实现登录跳转，这里采用后端 session 身份验证进行防范。同时前端需实现登录拦截，防止用户未经登录便通过 url 跳过登录验证。</p></blockquote><ol start="2"><li>所谓 session 身份验证，打个比方就是“你第一次来的时候我发给你一张身份证，但只是一张写着身份证号码的纸片。以后你每次来办事，我根据这张身份证去后台查一下你的 id 是不是有效”。  </li></ol><p>对应到登录功能，就是每次用户登录的时候，后端获取到用户邮箱，根据这个邮箱查找数据库中存储的该用户的信息，若查找不到说明该用户未注册；若查找得到则说明该用户已注册成功，可以往下匹配密码，若密码错误，则不能登录，也就不用“发放身份证”了；若密码正确，则“可以发放带有身份证号码的身份证”–生成 session 并存进 cookie 中响应给前端。这样用户就算篡改后端响应数据，要登录的时候 session 还是会发生更改，不会与用户篡改后的数据相匹配；同时如果用户在未登录的状态下更改 url ，也会触发登录拦截，后端会验证登录状态。</p><blockquote><p>这个 session 是一个长度为 20 左右的包含数字和大小写字母的 session 随机数，将这个随机数①存进该用户的信息中，以便在维护登录状态时可以根据用户账号获取；②生成一个 cookie ，将 session 存进该 cookie 中。  </p><p>那么问题又来了，session 可以通过 JS 函数 return 一个值得到，但这个 cookie 该如何生成？ session 又如何存进 cookie 中？</p></blockquote><p>在 Koa 中，这两个问题可以一并解决：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 文件结构：根目录/src/middleware/login.ts</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token operator">:</span>Context</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// generateMixed() 是封装的 JS 函数，用于生成随机数</span>  <span class="token keyword">const</span> session <span class="token operator">=</span> <span class="token function">generateMixed</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置 cookie </span>  ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>    <span class="token string">'session'</span><span class="token punctuation">,</span> session<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> httpOnly<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> maxAge<span class="token operator">:</span> <span class="token number">3600000</span> <span class="token punctuation">&#125;</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在前端封装 axios 函数的地方加上配置 <code>axios.defaults.withCredentials = true;</code> 之后，就会在前端每次向后端请求数据时，请求头中自动带上 cookie ，后端便可以获取到这个 cookie 对用户身份进行验证：如果与数据库中该用户的 session 一致，则说明用户处于登录状态，否则用户未登录。可以设一个字段标识登录状态，返回给前端，以便前端判断用户是否登录成功。</p><ol start="3"><li>前端在路由页面发送登录请求（参数为 cookie ），如果后端接收到了 cookie ，并在数据库中找到 session 为 cookie 的用户信息，说明用户处于登录状态，否则处于未登录状态。对于未登录的用户，重定向到登录页面即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
            <tag> 注册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Ts 项目：在线编程笔试平台</title>
      <link href="/2021/11/02/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/"/>
      <url>/2021/11/02/react-ts-xiang-mu-zai-xian-bian-cheng-bi-shi-ping-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客说到线上部署项目到服务器，博主说的就是这个 React-Ts 项目啦，它是博主为将来找实习准备的，用到的技术点有好一些是边学边做的，如果有不同见解的地方还请读者不吝赐教。</p><blockquote><p>需要事先说明的是，关于这个项目的博客，博主并不打算讲解代码实现，每个人的项目用到的技术栈不尽相同，但有一点可以确定，就是项目功能点的实现逻辑是大致相同的，故博主会更多地讲解各模块/功能点的逻辑实现 ^_^</p></blockquote><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>该项目是一个在线编程笔试平台。<br>主要功能是面试官①编辑（可新增、修改、删除）试卷和试题【一张试卷有多道试题】；②查看候选人编程结果并给予评分和备注等信息。候选人①在线完成代码编写并提交；②根据面试官设定的查看权限，决定能否查看已提交或已结束的试题。<br>该项目包含了前端和后端两种技术栈，前端采用的是 React ，后端采用的是 NodeJs ，整个项目为前后端分离项目。</p><h2 id="项目任务拆解"><a href="#项目任务拆解" class="headerlink" title="项目任务拆解"></a>项目任务拆解</h2><ol><li>登录/注册模块</li></ol><ul><li>支持邮箱登录和注册</li><li>支持退出登录</li></ul><ol start="2"><li>面试题模块</li></ol><ul><li>面试官可填写试卷和面试题</li><li>支持新建、修改、删除试卷和面试题目</li><li>支持邀请多个候选人编程</li><li>面试题目支持富文本格式</li></ul><ol start="3"><li>在线编程模块</li></ol><ul><li>候选人可在线编写代码</li><li>代码支持多种语言高亮</li><li>候选人侧可提交最终编程代码</li><li>面试官侧刷新能看到最终代码</li></ul><ol start="4"><li>在线留言模块</li></ol><ul><li>候选人可以通过文字给面试官留言</li><li>面试官可以回复</li><li>留言内容长期保存</li><li>留言模块自动刷新</li></ul><ol start="5"><li>在线编程模块支持自动刷新</li></ol><ul><li>候选人侧代码支持自动保存</li><li>面试官侧代码自动刷新</li></ul><ol start="6"><li>在线留言模块改成实时文字聊天</li></ol><ul><li>候选人和面试官可实时文字聊天</li><li>其他获得链接的人都可参与文字聊天</li></ul><ol start="7"><li>在线语音聊天模块</li></ol><ul><li>候选人和面试官可实时语音聊天</li></ul><ol start="8"><li>在线编程模块支持运行JS代码</li></ol><ul><li>候选人和面试官可在线运行 JS 代码并查看输出</li></ul><ol start="9"><li> 在线编程模块支持协同编辑</li></ol><ul><li>候选人和面试官可实时协作编程<h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2></li><li><input checked="" disabled="" type="checkbox"> 2021/09/04：实现登录/注册的静态页面</li><li><input checked="" disabled="" type="checkbox"> 2021/09/19：实现登录/注册逻辑（包括账号密码登录、登录拦截，session 身份验证）</li><li><input checked="" disabled="" type="checkbox"> 2021/09/29：初步部署前后端项目到阿里云服务器</li><li><input checked="" disabled="" type="checkbox"> 2021/10/04：购买域名并实现自动化部署项目</li><li><input checked="" disabled="" type="checkbox"> 2021/10/05：支持使用邮箱 登录和注册（删除了账号密码登录、注册的方式）</li><li><input checked="" disabled="" type="checkbox"> 2021/10/09：支持新建/删除试卷，在“新建试卷”里新建/修改/删除试题，发送邮件至候选人邮箱</li><li><input checked="" disabled="" type="checkbox"> 2021/10/23：初步完成面试题模块（包含“修改试卷”）</li><li><input checked="" disabled="" type="checkbox"> 2021/10/30：初步完成在线编程模块</li><li><input checked="" disabled="" type="checkbox"> 2021/10/31：搭建个人博客</li><li><input checked="" disabled="" type="checkbox"> 2021/11/02：记录项目从开始到现在的一系列笔记</li></ul><h2 id="项目笔记"><a href="#项目笔记" class="headerlink" title="项目笔记"></a>项目笔记</h2><ol><li><a href="https://hcyety.github.io/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/">ERROR 之部署服务器篇</a></li><li><a href="https://hcyety.github.io/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/">前后端分离项目线上部署</a></li><li><a href="https://hcyety.github.io/2021/11/02/xiang-mu-zhi-deng-lu-zhu-ce-mo-kuai/">项目之登录/注册模块</a></li></ol><h2 id="本文还在持续更新中……"><a href="#本文还在持续更新中……" class="headerlink" title="本文还在持续更新中……"></a>本文还在持续更新中……</h2>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Ts </tag>
            
            <tag> NodeJs </tag>
            
            <tag> TypeORM </tag>
            
            <tag> Koa </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离项目线上部署</title>
      <link href="/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/"/>
      <url>/2021/11/01/qian-hou-duan-fen-chi-xiang-mu-xian-shang-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>将项目部署至线上，使得任何用户在不同条件下也能够访问。那么首先需要一个服务器，网上有很多教程，能够教会大家如何拥有属于自己的服务器，这里不再赘述。本人购买的是阿里云的linux/CentOs7.7服务器（据说 21 年底，CentOs 官方将不再维护 CentOs8了，大家看看要配哪个系统好吧，博主之前不知情，选了 CentOs8 ，后来因为某种特殊原因决定重换系统，于是降低版本为 CentOs7）。 </li><li>当大家拥有自己的服务器后，就需要配置各种环境以支持项目能够顺利运行，这也是为什么开发者会说“这个项目在我的机器上能跑”的原了，因为“我的机器上有相关配置，你的机器上怎晓得有没有”。网上虽然有相关的资料，但杂多繁乱，本人当初因为配置环境浪费了很多时间，这里贴下 @b站up主CodeSheep 的 pdf ，真是一个很好的配置说明，一条龙服务，很快就能配置大部分必备的环境<blockquote><p>链接：<a href="https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ">https://pan.baidu.com/s/1yKVkabO-N-MCx4UwRbbKcQ</a><br>提取码：h464 </p></blockquote></li></ol><p><strong>下面将会使用基础和进阶的方法部署项目，先说比较麻烦的手动部署流程，毕竟事情要一步一步来，从易到难嘛。</strong></p><h2 id="前端的手动化部署"><a href="#前端的手动化部署" class="headerlink" title="前端的手动化部署"></a>前端的手动化部署</h2><p>这里使用了 webpack ，由于本文重点不在于如何使用 webpack 配置项目，因此不详述，默认诸位看官已经学会相关知识点。</p><ol><li>首先要将本地项目打包成 dist 包，这点通过 webpack 配置可以完成。</li><li>打开 Xshell 工具，在 nginx 已经配合好的前提下，修改 nginx 的配置文件：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 找到【 nginx 的安装目录下的 conf】，修改 conf 下的 nginx.conf 。</span><span class="token comment">// 举例：我的安装路径是 /usr/local/nginx ，所以 vim /usr/local/nginx/conf/nginx.conf</span><span class="token comment">// 进到文件里面后，按 i 可以进入编辑模式修改文件，修改好后按 esc 可以退出编辑模式，然后输入 :wq 保存并退出文件</span><span class="token comment">// 修改配置如下：</span><span class="token comment">// 1. 在第一行加上 user root;</span><span class="token comment">// 2. 找到 server&#123; location / &#123;&#125; &#125;，修改如下</span>server <span class="token punctuation">&#123;</span>  listen       <span class="token number">80</span><span class="token punctuation">;</span>  server_name  localhost<span class="token punctuation">;</span>  #charset koi8<span class="token operator">-</span>r<span class="token punctuation">;</span>  #access_log  logs<span class="token operator">/</span>host<span class="token punctuation">.</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span>  <span class="token comment">// 这里修改</span>  location <span class="token operator">/</span> <span class="token punctuation">&#123;</span>    root   <span class="token punctuation">&#123;</span> nginx 的安装目录<span class="token operator">/</span>html<span class="token operator">/</span>xxx<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// eg. root   /usr/local/nginx/html/dist，dist 为打包后的前端项目;</span>    index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 配置好 nginx.conf 后，保存退出，重启 nginx</span><span class="token comment">// 重启命令为 &#123; nginx 的安装路径/sbin/nginx -s reload &#125;，举例：/usr/local/nginx/sbin/nginx -s reload</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>打开 Xftp 工具，找到 { nginx 的安装路径/html/ }，例如 /usr/local/nginx/html/ ，将 dist 包上传至 html 目录下。访问 ip 地址就可以看到前端项目的静态界面了<blockquote><p>前端项目的部署相对来说简单一些，只要将打包后的文件夹上传到服务器即可（配置好 nginx 的前提下）。下面看下后端项目的部署</p></blockquote><h2 id="后端的手动化部署"><a href="#后端的手动化部署" class="headerlink" title="后端的手动化部署"></a>后端的手动化部署</h2></li><li>配置好 Tomcat ，相关教程看 上文3.2 的 pdf   </li><li>在 Tomcat 的安装目录下新建一个文件夹，用来存放后端项目，这里命名为 myApp 。打开 Xftp 工具，选中要上传的后端文件，拖拽实现上传  </li><li>打开 Xshell 工具，用命令行进入 myApp ，安装项目所需的依赖 <code>npm install</code> 。用 pm2 监控项目，先全局安装 pm2 <code>npm install pm2 -g</code> ，然后用 pm2 启动项目入口文件 <code>pm2 start &#123;入口文件&#125; </code> 。到这里，后端项目的部署也完成啦，咕咕咕~<blockquote><p>到这里，其实本应该能成功启动前后端项目，并能够跑通服务，但绝大多数情况下总是事与愿违的，似乎老天爷不会让事情这么顺利，总要让我们经历一番磨练，所谓“天将降大任于斯人也，必先苦其心志，劳其筋骨是也”，于是总会出现各种奇奇怪怪的 bug 。博主也遇到了，一度很伤脑筋，所以后来终于解决了，博主的上一篇博客：<a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a> 记录了博主遇到的一些困难，说不定与读者相同，可以借鉴参考其解决方法，如果能顺利帮助到大家就再好不过了！</p></blockquote></li></ol><blockquote><p>如果读者已经顺利完成了项目的非自动化部署，相信能够感受到诸多的不便之处，下面博主会为大家介绍自动化部署前后端分离项目的流程，最终的效果便是在本地编辑器的终端运行两次命令：<code>npm run deploy 服务器的主机 服务器的密码</code> ，便能够分别实现前后端分离这两个项目从打包到上传服务器再到启动项目的一条龙服务，希望对大家有所帮助。</p></blockquote><h2 id="前端的自动化部署"><a href="#前端的自动化部署" class="headerlink" title="前端的自动化部署"></a>前端的自动化部署</h2><p>首先我们需要搞清楚前端项目的一系列部署流程，那便是 <strong>打包–登录服务器–上传打包文件</strong> ，那么按照这个思路，我们来具体捋清楚实现过程：</p><ol><li>逻辑思考</li></ol><ul><li>①运行脚本命令；</li><li>②然后脚本读取配置文件（包含服务器host、port、web目录及本地目录等信息）；</li><li>③<strong>打包生成 dist 包</strong> – <code>npm run build</code>；</li><li>④<strong>使用 scp2 连接服务器</strong>；</li><li>⑤<strong>将本地打包的 dist 上传</strong>至 <code>/usr/local/nginx/html/</code> ；</li><li>⑥<strong>获取脚本命令的自定义参数</strong>，这里的参数为服务器主机和密码，并赋值给服务器配置文件（第④点的目的是防止将服务器的主机和密码泄露在项目中）。  </li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack --config webpack&#x2F;webpack.prod.js&quot;, &#x2F;&#x2F;博主这里的配置是这样的，可能跟大家有点出入  &quot;deploy&quot;: &quot;npm run build &amp;&amp; node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 看到上面的 deploy 中的路径，我们可以知道需要在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js ，这个文件是为了使用 scp2 连接服务器，因此里面还放有服务器的一些相关配置。现在开始编写 index.js ：&#x2F;&#x2F; 注：scp2 的官网有相关 API 的使用方法，需要提醒的是文件上传的路径需要特别注意，因为不同的工具，写法不同，最终的效果也是有所差别的，例如有些工具上传文件时如果发现服务器该路径下没有对应文件，会自动生成文件夹，但有些工具却不会；同时，上传的文件路径后面带不带 “&#x2F;” ，也是会有不同的效果的，读者需要稍微留意一下。&#x2F;&#x2F; 1.引入 scp2 ，用于连接服务器const client &#x3D; require(&#39;scp2&#39;);&#x2F;&#x2F; 2.服务器的配置选项const server &#x3D; &#123;  host: &#39;&#39;, &#x2F;&#x2F; ip 地址  port: 22, &#x2F;&#x2F; 端口号  username: &#39;root&#39;, &#x2F;&#x2F; 用户名  password: &#39;&#39;, &#x2F;&#x2F; 密码  path: &#39;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;dist&#39;  &#x2F;&#x2F; 存放项目的路径&#125;&#x2F;&#x2F; 4.用解构赋值获取脚本命令后面的两个参数：主机和密码const [ , , host, password] &#x3D; process.argv;server.host &#x3D; host;server.password &#x3D; password;&#x2F;&#x2F; 3.连接服务器并上传 dist 包到服务器的指定目录 pathclient.scp(&#39;dist&#x2F;&#39;, &#123;  port: server.port,  host: server.host,  username: server.username,  password: server.password,  path: server.path&#125;, function(err) &#123;  if (err) &#123;    console.log(&#39;文件上传失败&#39;, err)  &#125; else &#123;    console.log(&#39;文件上传成功&#39;);  &#125;&#125;)&#x2F;&#x2F; 之后执行【 npm run deploy 服务器主机 服务器密码 】便可实现前端项目的自动化部署了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后端的自动化部署"><a href="#后端的自动化部署" class="headerlink" title="后端的自动化部署"></a>后端的自动化部署</h2>与前端项目的自动化部署一样，我们也需要搞清楚后端项目的一系列部署流程，也就是 <strong>用一个文件夹单独存放需要上传的文件–登录服务器–上传文件–启动项目</strong> ，我们同样来看看具体实现：</li><li>逻辑思考</li></ol><ul><li>①<strong>手动将需要上传的文件复制到一个新建文件夹里，这个文件夹博主命名为 oppService</strong>；</li><li>②运行脚本命令；</li><li>③然后脚本读取配置文件–包含服务器host、port 和 oppService 目录以及 deploy.sh 脚本等信息；</li><li>④<strong>调用 node-ssh API 连接服务器</strong>；</li><li>⑤将 oppService <strong>文件夹上传至服务器指定目录</strong>；</li><li>⑥启动项目的方式博主是在服务器上运行自己编写的 .sh 脚本，里面编写的是项目上传之后服务器要做的后续命令 – 进入服务器上的 oppService 文件夹里以<strong>执行 deploy.sh 脚本</strong>；</li><li>⑦<strong>获取 npm scripts 命令的自定义参数</strong></li></ul><ol start="2"><li>逻辑实现<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 同样在 package.json 文件的 scripts 字段定义脚本命令 &quot;deploy&quot;&quot;scripts&quot;: &#123;  &quot;deploy&quot;: &quot;node .&#x2F;deploy&#x2F;index.js&quot;&#125;&#x2F;&#x2F; 在项目根目录下新建文件夹 deploy ，并在 deploy 下新建文件 index.js 。开始编写 index.js ：&#x2F;&#x2F; 1.引入 node-ssh 模块 ，准备调用内置 API&#x2F;&#x2F; 这里有个小问题，貌似官方有个 bug 没解决，不能直接 const node_ssh &#x3D; require(&#39;node-ssh&#39;); ，而是得改成下面的形式去导入const node_ssh &#x3D; require(&#39;node-ssh&#39;).NodeSSH;const ssh &#x3D; new node_ssh();&#x2F;&#x2F; 6.用解构赋值获取脚本命令后面的两个参数：主机和密码，并存入 config 中const [ , , host, password] &#x3D; process.argv;&#x2F;&#x2F; 2.服务器的配置选项const config &#x3D; &#123;  path: &#123;    localPath: &#39;oppService&#x2F;&#39;,    romotePath: &#39;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.71&#x2F;Online-programming-platform_service&#39;,  &#125;,  romote: &#123;    host: &#39;&#39;,    port: 22,    username: &#39;root&#39;,    password: &#39;&#39;  &#125;&#125;function uploadFile() &#123;  &#x2F;&#x2F; 3.连接服务器  ssh.connect(config.romote)  .then(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 4.上传 dist 包到服务器的指定目录 path    ssh.putDirectory(config.path.localPath, config.path.romotePath)    .then(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 5.执行脚本，完成文件上传后服务器的后备工作      ssh.execCommand(&#39;sh deploy.sh&#39;, &#123; cwd: config.path.romotePath &#125;)      .then((res) &#x3D;&gt; &#123;        if (!res.stderr) &#123;          process.exit(0);        &#125;      &#125;)    &#125;).catch(err &#x3D;&gt; &#123;      console.log(err)    &#125;)  &#125;).catch(err &#x3D;&gt; &#123;    console.log(&#39;服务器连接失败！！&#39;)  &#125;)&#125;uploadFile();&#x2F;&#x2F; 编写 deploy.sh 脚本#!&#x2F;bin&#x2F;bash# ①先关闭之前的服务，安装依赖之后再重启pm2 stop src&#x2F;app.ts# ②查看文件中是否已经包含 node_modules ，如果有则先删除file&#x3D;&#39;node_modules&#39;if [ -e $file ]; then  rm -rf $file  npm cache clean --forcefi# ③重新安装依赖cnpm install# ④查看8080端口是否被占用，有则 kill ，防止项目无法开启port&#x3D;8080pid&#x3D;$(netstat -nlp | grep :$port | awk &#39;&#123;print $7&#125;&#39; | awk -F&quot;&#x2F;&quot; &#39;&#123; print $1 &#125;&#39;)if [ -n &quot;$pid&quot; ]; then  kill -9 $pid;fi# ⑤重新启动 pm2pm2 start .&#x2F;src&#x2F;app.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>到这里，前后端分离项目的自动化部署就已经结束了，如果有遇到什么 bug ，也可以看看我的上一篇博客 <a href="https://hcyety.github.io/2021/10/31/ERROR-%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/">ERROR 之部署服务器篇</a>，或许能够带来一点点帮助。<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2>这样一来，项目部署的效率瞬间就提上来了，一条命令就搞定一切，但博主觉得，其实还有优化空间，例如后端项目需要事先将要上传的文件抽离出来，那我们每次编写完代码之后都得把文件更新一遍，不是很方便。这个问题就等后续再完善吧，毕竟在部署这里耽误的时间也差不多了(=￣ω￣=)。如果读者觉得有什么好的解决方案或者是其他可以优化的地方，也可以在评论区提出来哩，先谢过诸位啦~<blockquote><p>后续等有空了会回头来完善的哈</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2>从对服务器一窍不通，到掌握线上项目的部署，再到命令行的熟练操作，以及对解决问题能力的锻炼，这些都是博主在完成这个前后端分离项目线上部署带来的好处，毫无疑问收获是颇丰的。但实现的过程却并不轻松，有时候一个 bug 一卡就是两三天（终究还是能力不够吧 T^T），浪费了很多时间，但坚持总会有作用的，至少排查问题的能力或多或少能有所提高，真心希望读者能顺利完成项目的部署，直接通关【妖魔鬼怪（bug）快离开，妖魔鬼怪（bug）快离开】。<blockquote><p>以上 ^_^</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
            <tag> 线上部署 </tag>
            
            <tag> scp2 </tag>
            
            <tag> node-ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR 之部署服务器篇</title>
      <link href="/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/"/>
      <url>/2021/10/31/error-zhi-bu-shu-fu-wu-qi-pian/</url>
      
        <content type="html"><![CDATA[<ol><li>POST <a href="http://localhost:3000/login">http://localhost:3000/login</a> 404 (Not Found)?</li></ol><p>有多种原因：①前端调用后端接口失败，通常是因为接口的路径匹配错误；②后端没有响应数据给前端；前端接收数据的格式与后端返回数据的格式不相符。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_44163269/article/details/105442612">vue项目 前端 POST(GET) http://127.0.0.1xxx 404(Not Found)错误 （多种误区解决）</a></p></blockquote><ol start="2"><li>在服务器运行<code>npm run dev</code>报错：SyntaxError: Cannot use import statement outside a module？  </li></ol><p>这提示一般是node下无法使用import。</p><blockquote><p><a href="https://blog.csdn.net/weixin_43094085/article/details/114832738">解决方法参考这篇文章</a></p></blockquote><ol start="3"><li>在服务器上启动 NodeJs+ts 项目时报错之一：TS错误:⨯无法编译TypeScript(Error: TSError: ⨯ Unable to compile TypeScript)</li></ol><p>解决：从 package.json 中删除 ts-node 和 typescript 。然后：</p><pre class="line-numbers language-none"><code class="language-none">npm install ts-node --save-devnpm install typescript -g npm install typescript --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在服务器上启动 NodeJs + Ts 项目时报错之二：Can’t run my Node.js Typescript project TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension “.ts” for /app/src/App.ts</li></ol><p>情况说明：博主启动项目的命令是 <code>npm start</code> ，项目 <code>package.json</code> 文件中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node src/app.ts</code> 。不幸的是，由于项目中既有 ES6 模块又有 CommonJS 模块，因此不能按照网上的教程只在 <code>package.json</code> 中添加 <code>&quot;type&quot;: &quot;module</code> 或者 只在 <code>tsconfig.json</code> 中添加 <code>&quot;type&quot;: &quot;CommonJS&quot;</code> ，因为如果这样的话，项目运行后还是会报如下的错误：</p><pre class="line-numbers language-none"><code class="language-none">import Koa from &#39;koa&#39;;^^^^^^SyntaxError: Cannot use import statement outside a module<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：修改 <code>package.json</code> 中 <code>scripts</code> 字段下 <code>start</code> 的代码为 <code>node --experimental-modules --loader ts-node/esm &#123; 项目入口文件 &#125;</code> </p><ol start="5"><li>服务器用 pm2 启动项目失败：Error: Cannot find module ‘/Users/wyb/.nvm/versions/io.js/v3.0.0/lib/node_modules/pm2/lib/ProcessContainerFork.js’</li></ol><p>情况说明：笔者的服务器确定是有安装了 pm2 的，使用 <code>pm2 -v</code> 也可以正常查询到版本号。然而此前 NodeJs 因为我误操作卸载重装了，虽然 pm2 也重新安装了一遍，但根目录下残留的文件路径指向的是以前的 pm2 ，因此只要将根目录下的 pm2 删除即可。</p><p>解决：<code>rm -rf ~/.pm2</code>  </p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/36690442/error-cannot-find-module-users-wyb-nvm-versions-io-js-v3-0-0-lib-node-module">overflow 回答</a></p></blockquote><ol start="6"><li>启动 pm2 报错：Process or Namespace ./src/app not found<pre class="line-numbers language-none"><code class="language-none">[PM2][ERROR] Process or Namespace .&#x2F;src&#x2F;app.ts not found[PM2][ERROR] Interpreter &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node is NOT AVAILABLE in PATH. (type &#39;which &#x2F;www&#x2F;server&#x2F;nvm&#x2F;versions&#x2F;node&#x2F;v14.17.6&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;.bin&#x2F;ts-node&#39; to double check.)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>排查流程：正常下，可以先 <code>pm2 -v</code> 查看是否已经安装 pm2 ，如果不能显示版本信息，有两种情况，一种是没有安装，那么运行 <code>npm install pm2 -g</code> ；如果确定安装过了，则可以试试建立软链接：<code>ln -s &#123; 安装 pm2 的绝对路径 &#125; /usr/local/bin/</code> 。如果还不能解决，就再往下看看。</li></ol><p>先看第二个报错，情况①博主的服务器安装了宝塔面板，并在面板里安装了 pm2 管理器，导致与服务器的 pm2 冲突。于是把宝塔面板中的 pm2 管理器卸载，就没有这个报错了。②用 xshell 工具执行这条命令：<code>pm2 start src/app.ts --interpreter ./node_modules/.bin/ts-node</code> 即可。</p><ol start="7"><li><p>将项目中的脚本上传至服务器并执行时报错：npm: command not found？</p><pre class="line-numbers language-none"><code class="language-none">deploy.sh: line 2: npm: command not found&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory&#x2F;usr&#x2F;bin&#x2F;env: node: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据网上的解决方法，正解本来应该是 用绝对路径设置软链 ，但博主的情况很特殊，是由于 /usr/bin/env 命令被修改，导致找不到 node ，这也是在我多方尝试无果之后向阿里提交工单，大佬给出的回复。<br>大佬的解决方法便是从版本相同的主机 copy 一份 /usr/bin/env 命令到我本机上，这才恢复正常。</p><blockquote><p>注：在服务器上的操作大家一定要慎重，误删文件可能会导致各种很难解决的 bug ，这已经是我第二次遇到特殊情况了。</p></blockquote></li><li><p>端口被占用？</p></li></ol><ul><li>查看端口使用情况：<code>netstat -ntlp</code></li><li>杀掉进程：<code>kill （对应端口的PID）</code><blockquote><p>参考资料：<a href="http://blog.csdn.net/ljfphp/article/details/78666376">【转】linux下杀死进程（kill）的N种方法</a></p></blockquote></li></ul><ol start="9"><li>无法访问阿里云ip地址？</li></ol><p>解决方法：<a href="https://www.cnblogs.com/ghzjm/p/10677599.html">linux服务器安装nginx及使用</a></p><blockquote><p>排查1：<a href="https://blog.csdn.net/sinat_25957705/article/details/80641077">阿里云服务器 nginx公网IP无法访问浏览器</a><br>排查2：<a href="https://blog.csdn.net/Adime_J/article/details/109155234">linux服务器部署完成之后访问不到—–总结篇</a></p></blockquote><blockquote><ol><li>ping ip成功只能说明主机可以到达，端口还是有可能不可到达的。端口不可到达可能是由于HTTP 服务器未启动或者监听在其他端口入8080上了；还有一个可能是防火墙没开放80端口的访问权限。</li></ol></blockquote><blockquote><p>排查过程中遇到的问题：</p><ol><li>curl: (7) Failed to connect to 120.79.193.126 port 80: Connection refused<br><a href="https://www.cnblogs.com/jukaiit/p/8994448.html">Xshell 链接 Could not connect to ‘192.168.80.129’ (port 22): Connection failed</a><br>在Linux6中查看及设置开机自启信息是使用chkconfig命令，Linux7中此命令已经被替代。虽然Linux7中已经不再使用chkconfig命令来管理服务是否开机自启，但是此命令仍旧可用，但是输出信息提示我们使用chkconfig命令的输出只是呗SysV所管理的服务，不包括systemd管理的服务，所以如果想在CentOS7中查看systemd管理的服务需要使用以下命令：<a href="https://blog.csdn.net/qq_38295166/article/details/79828482">CentOS 7设置ssh服务自动启动</a></li></ol></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_38705903/article/details/101911553">或许有用？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Begin: myfist blog</title>
      <link href="/2021/10/31/begin-myfist-blog/"/>
      <url>/2021/10/31/begin-myfist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做 React-Ts 项目，两个月了，有了这个项目该有的雏形。就在昨天，我实现好了项目 40% 的功能，心里放松了一下，突然觉得有点累了，不是说真的那种累，而是因为 我从这个项目本身学到了很多东西，不仅有知识点的深入理解，还有处理问题的能力、思维逻辑的锻炼等等，得到的好处很多，此前一直投身于项目功能点的实现，还没机会消化，突然松了口气，顿觉身上积攒了很多东西，我觉得是时候该静下心来，沉淀我这两个月来所学到的东西，于是我着手搭建个人博客，准备记录自己的所学所感……</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>大二在读生一枚，我喜欢前端世界，对于前端技术我怀有十分的兴趣，网络上所见到的各种好看、奇特的效果，一想到都是通过代码实现的，我就觉得十分神奇，我之前认为，代码和那些好看的特效是不沾边的东西，没想到那些是用我不知道的方式实现的。对于前端技术的原理，我也感觉十分神奇，让我知道了代码世界里想当然是不对的，如果这样便往往会犯错。当然，后端的世界也不赖，虽然不像前端那样可视化，但有时对数据的处理能够返回预期效果，成就感也十足。这样，我想成为一名前端工程师，努力的话，争取全栈。</p><p>电脑是我日常生活中不能缺少的一件必需品，但生活不能只有电脑，我也喜欢打羽毛球、乒乓球、游泳、聚会（仅限于我在意的人），诗和远方亦是我向往的生活。但我知道心中虽有所往，但那不是想有就有的，诗和远方 都挺贵，目前我所能做的，便是提升我的硬实力，总得拿到长途旅行的门票吧^_^</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>用了一天时间搭建了个人博客，是我喜欢的主题，既然有这么方便好看的工具为我们铺好了红毯，我难道不应该兢兢业业地写好文章、做好博客吗（<em>^▽^</em>）</p><p>我决定先把项目放一边，一个星期，就一个星期，我得总结归纳，好好沉淀一下，学到的 很多很快，如果不及时记录，估计又得还回去了，所谓好记性不如烂笔头，这句话既然能成为谚语，肯定是有它的过人之处的 (￣ェ￣;)。一个星期过后，我再重新扬帆起航吧，再花一个半月左右的时间，应该能把这个项目完全搞定，总计三个半月，应该还可以接受吧（好吧，我觉得有点久了，争取三个月搞定）。那么这一个星期，我就要从头回顾一下我的项目了，这个过程说不定还可以解决掉历史残留问题，总之，要加油了！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上文有说到，搭建个人博客的初衷是沉淀所学所感，因此我对这个博客的定义首先是一个技术博客，我希望它能成为一个有含金量的技术文章存放地；其次是我本人的心灵树洞，我也期望它能成为我倾诉心声的所在，毕竟我是一个有时不太爱说话的人…..</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
