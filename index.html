<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>hcyety&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="诗和远方，我向往的；自在独行，我渴望的">
<meta property="og:type" content="website">
<meta property="og:title" content="hcyety&#39;s blog">
<meta property="og:url" content="https://hcyety.github.io/index.html">
<meta property="og:site_name" content="hcyety&#39;s blog">
<meta property="og:description" content="诗和远方，我向往的；自在独行，我渴望的">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hcyety">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="hcyety&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 5.4.0"></head>

 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">玩转开发工具</a></li>
                        
                            <li><a  href="/categories/digital">玩转数码</a></li>
                        
                            <li><a  href="/categories/algorithm">算法学习</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/xxxxx" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Koa/" style="font-size: 10px;">Koa</a> <a href="/tags/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 15px;">Linux 服务器</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/NodeJs/" style="font-size: 10px;">NodeJs</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/TCP/" style="font-size: 12.5px;">TCP</a> <a href="/tags/Ts/" style="font-size: 10px;">Ts</a> <a href="/tags/node-ssh/" style="font-size: 10px;">node-ssh</a> <a href="/tags/scp2/" style="font-size: 10px;">scp2</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 10px;">八股文</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 12.5px;">前端</a> <a href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/" style="font-size: 10px;">命令行</a> <a href="/tags/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">实习面试</a> <a href="/tags/%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">开发调试技巧</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E6%96%87/" style="font-size: 17.5px;">技术文</a> <a href="/tags/%E6%B3%A8%E5%86%8C/" style="font-size: 10px;">注册</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A7%E5%88%B6%E5%8F%B0/" style="font-size: 10px;">浏览器控制台</a> <a href="/tags/%E7%99%BB%E5%BD%95/" style="font-size: 10px;">登录</a> <a href="/tags/%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">线上部署</a> <a href="/tags/%E8%BF%90%E8%BE%93%E5%B1%82/" style="font-size: 12.5px;">运输层</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 12.5px;">随笔</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 20px;">面试</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱动漫,爱游戏,爱编程,爱运动,爱的太多了!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">玩转开发工具</a></li>
                
                    <li><a href="/categories/digital">玩转数码</a></li>
                
                    <li><a href="/categories/algorithm">算法学习</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/xxxxx" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-备战前端实习面试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/03/13/bei-zhan-qian-duan-shi-xi-mian-shi/" class="article-date">
      <time datetime="2022-03-13T08:20:04.000Z" itemprop="datePublished">2022-03-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/03/13/bei-zhan-qian-duan-shi-xi-mian-shi/">备战大厂前端实习</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>公式：为解决 xx 问题，使用 xx 技术实现了 xx ，达到了怎样的效果。</p>
<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官您好，我是羊芳震，是广东东软学院的一名计算机本科生，目前大二在读：</p>
<ul>
<li>主要的技术栈是 React ，了解 Node.js 开发的知识，有良好的代码规范意识，</li>
<li>开发过一个前后端分离项目并完成线上部署；使用 hexo 搭建过个人博客，平时会进行技术输出</li>
<li>我对前端有十分的热情，渴望去探索前端更多新奇且有趣的世界。我憧憬在这个领域有所建树，希望能够独立打造自己的组件库，利用自己所学开发出优秀的产品，用产品改善和丰富人们的生活！<br>会什么东西，做过什么东西，有什么想法，对前端的掌握能力</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-备战前端实习面试之JavaScript篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-javascript-pian/" class="article-date">
      <time datetime="2022-03-08T14:34:30.000Z" itemprop="datePublished">2022-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-javascript-pian/">备战大厂前端实习之浏览器篇</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="什么是-xss-攻击"><a href="#什么是-xss-攻击" class="headerlink" title="什么是 xss 攻击"></a>什么是 xss 攻击</h3><p>xss 攻击指的是<strong>跨站脚本攻击</strong>，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使其在用户的浏览器上运行，从而盗取用户的信息，如 cookie 等。</p>
<p>xss 攻击的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，但浏览器没有能力区分这些恶意代码，只能无条件执行。</p>
<p>xss 攻击可以分为反射型、存储型、DOM 型：</p>
<ul>
<li>反射型指的是攻击者诱导用户访问带有恶意代码的 url ，服务端接收数据后处理，将带有恶意代码的数据发送回浏览器，浏览器解析这段带有 xss 代码的数据后会将其当做脚本执行，以此完成 xss 攻击。</li>
<li>存储型指的是恶意脚本会存储在服务器上，当浏览器请求数据时，这段恶意脚本会从服务器传回并执行。</li>
<li>DOM 型指的是攻击者修改网页的 DOM 节点而形成的 xss 攻击。</li>
</ul>
<p>反射型 xss 与存储型 xss 的区别：</p>
<ul>
<li>反射型作用范围小，仅局限于单体攻击对象；而存储型则是作用于操作到数据库的所有用户。</li>
<li>反射型的恶意代码存在 url 里，而存储型的恶意代码存储在数据库里。</li>
</ul>
<p>DOM xss 与前两种 xss 的区别：</p>
<ul>
<li>DOM 型 xss 攻击中，取出和执行恶意代码都由浏览器完成，属于前端 JavaScript 自身的安全漏洞；而其他两种 xss 攻击都是属于服务端的安全漏洞。</li>
</ul>
<h2 id="如何防御-xss-攻击："><a href="#如何防御-xss-攻击：" class="headerlink" title="如何防御 xss 攻击："></a>如何防御 xss 攻击：</h2><h3 id="什么是-csrf-攻击"><a href="#什么是-csrf-攻击" class="headerlink" title="什么是 csrf 攻击"></a>什么是 csrf 攻击</h3><p>csrf 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求，如果用户在被攻击网站中保存了登录状态，攻击者就可以利用这个登录状态绕过后台的用户验证，伪装成用户执行操作。</p>
<p>常见的 csrf 攻击有三种：</p>
<ul>
<li>GET 类型的 csrf 攻击：比如在网站中的一个 img 标签里构建一个请求，在用户打开这个网页时就会自动提交。</li>
<li>POST 类型的 csrf 攻击：比如构建一个表单，然后隐藏它，在用户进入页面时，就会自动提交这个表单。</li>
<li>链接类型的 csrf 攻击：比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
<h2 id="如何防御-csrf-攻击："><a href="#如何防御-csrf-攻击：" class="headerlink" title="如何防御 csrf 攻击："></a>如何防御 csrf 攻击：</h2><h3 id="什么是网络劫持"><a href="#什么是网络劫持" class="headerlink" title="什么是网络劫持"></a>什么是网络劫持</h3><p>网络劫持分为两种：<br>（1）DNS 劫持：（输入京东被强制跳转到淘宝就属于 DNS 劫持）</p>
<ul>
<li>DNS 强制解析：通过修改运营商的本地 DNS 记录，来引导用户流量到缓存服务器</li>
<li>302跳转的方式：通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的<br>（2）HTTP 劫持：</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p>所谓同源，就是指协议、域名、端口都要相同，只要有其中一个不同就会产生跨域。</p>
<h3 id="为什么会有同源策略"><a href="#为什么会有同源策略" class="headerlink" title="为什么会有同源策略"></a>为什么会有同源策略</h3><ul>
<li>为了防止恶意网页可以获取其他网站的本地数据。</li>
<li>为了防止恶意网站在自己网站有访问其他网站的权利，以免通过 cookie 免登，拿到数据。<h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3>跨域指浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。</li>
</ul>
<p>注意：跨域并不是请求发不出去，服务端也能收到请求并正常返回结果，只是结果被浏览器拦截了。</p>
<h3 id="解决跨域的九种方法"><a href="#解决跨域的九种方法" class="headerlink" title="解决跨域的九种方法"></a>解决跨域的九种方法</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p><strong>原理：</strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据， JSONP 请求一定需要对方的服务器做支持才可以</p>
<p><strong>优缺点：</strong>JSONP 简单且兼容性好，可用于解决主流浏览器的跨域数据访问的问题；但仅支持 get 方法，因为 script 脚本的请求方式是 GET。</p>
<p><strong>实现流程：</strong></p>
<ul>
<li>创建一个 <code>&lt;script&gt;</code> 并载入页面中，src 是跨域的 api 接口地址，但后面需要带上一个标记有回调函数的请求参数，如 <code>http://10.92.191.223:3000/test/?callback=handleCallback</code>。后端接受到请求后需要进行特殊的处理，将回调函数名和数据拼接成一个函数调用的形式返回给前端，如 <code>handleCallback(&#123;&quot;status&quot;: &quot;success&quot;, &quot;message&quot;: &quot;跨域成功&quot;&#125;)</code>。因为是 script 脚本，所以前端请求到这个脚本后会立即执行这个脚本内容，即调用这个回调函数。<!-- - 声明一个回调函数，其函数名（如 show ）当做参数值，</li>
<li>创建一个 <code>&lt;script&gt;</code> 标签，把要跨域的 api 数据接口地址赋值给 script 的 src 属性，同时还要在这个地址中向服务器传递该函数名（如 <code>?callback=show</code> ）</li>
<li>将创建的回调函数传递给跨域请求数据的服务器</li>
<li>服务器收到请求后进行处理：把传递进来的函数名和要响应回去的数据拼接成一个字符串</li>
<li>服务器把准备的数据通通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数，对返回的数据进行操作 –&gt;</li>
</ul>
<p><strong>代码实现：</strong></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  window<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>
      <span class="token function">callback</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">delete</span> window<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    url <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">?callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>fn<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    url <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>fn<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><h4 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h4><h4 id="node-中间件"><a href="#node-中间件" class="headerlink" title="node 中间件"></a>node 中间件</h4><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><h4 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h2 id="进程和线程，以及两者的区别"><a href="#进程和线程，以及两者的区别" class="headerlink" title="进程和线程，以及两者的区别"></a>进程和线程，以及两者的区别</h2><p>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</p>
<p>线程是进程中的更小单位，描述了执行一段指令所需的时间。</p>
<p>区别：</p>
<ul>
<li>进程可以看做是独立应用，但线程不行</li>
<li>资源：进程是 CPU 资源分配</li>
</ul>
<h2 id="减少回流与重绘的方法"><a href="#减少回流与重绘的方法" class="headerlink" title="减少回流与重绘的方法"></a>减少回流与重绘的方法</h2><ul>
<li>避免频繁的操作 DOM ，可以创建一个文档片段，在它上面应用所有 DOM 操作，最后再把它添加到文档中</li>
<li>如果非得操作 DOM ，尽量在低层级的 DOM 节点进行操作</li>
<li>将 DOM 的多个读操作（写操作）放在一起，而不是读写操作穿插着写。</li>
<li>使用 CSS 表达式</li>
<li>不要频繁修改元素的样式，对于静态页面，可以修改类名，而不是样式</li>
<li>使用 absolute 或 fixed ，使元素脱离文档流</li>
<li>将元素设置 display: none ，操作结束后再把它显示出来</li>
</ul>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h2 id="编程题：有一个数组-idArr-，长度是-100；-现在要调用一个接口-fetch-去查询每个数组元素-id"><a href="#编程题：有一个数组-idArr-，长度是-100；-现在要调用一个接口-fetch-去查询每个数组元素-id" class="headerlink" title="编程题：有一个数组 idArr ，长度是 100； 现在要调用一个接口 fetch 去查询每个数组元素 id"></a>编程题：有一个数组 idArr ，长度是 100； 现在要调用一个接口 fetch 去查询每个数组元素 id</h2><p>对应的 name；要求要分批调用，每批最多只能查询 10 个，以此实现一个 batch 函数；<br>进阶1：怎么判断批量操作是否都成功了，还是有的失败了；<br>进阶2：实现能找到查询失败的数据，并重新批量发接口重试 </p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> idArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>
  id<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
  id<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
  id<span class="token operator">:</span> <span class="token string">'100'</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function-variable function">fetch</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">params<span class="token operator">:</span> <span class="token punctuation">&#123;</span>id<span class="token operator">:</span> string<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> Promise<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span>id<span class="token operator">:</span> string<span class="token punctuation">;</span> name<span class="token operator">:</span> string<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span>

<span class="token keyword">const</span> batch <span class="token operator">=</span> <span class="token punctuation">(</span>idArr<span class="token operator">:</span> <span class="token punctuation">&#123;</span>id<span class="token operator">:</span> string<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Promise<span class="token operator">&lt;</span><span class="token punctuation">&#123;</span>id<span class="token operator">:</span> string<span class="token punctuation">;</span> name<span class="token operator">:</span> string<span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-备战前端实习面试之CSS篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-css-pian/" class="article-date">
      <time datetime="2022-03-08T14:34:03.000Z" itemprop="datePublished">2022-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-css-pian/">备战大厂前端实习之CSS篇</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="浮动的脱离文档流和绝对定位的脱离文档流是一样的吗"><a href="#浮动的脱离文档流和绝对定位的脱离文档流是一样的吗" class="headerlink" title="浮动的脱离文档流和绝对定位的脱离文档流是一样的吗"></a>浮动的脱离文档流和绝对定位的脱离文档流是一样的吗</h2><p>对于使用 <code>float: left</code> 而浮动的元素，其他盒子会无视它，从浏览器左上角开始布局，而盒子内的文本依旧会为浮动元素让出位置。<br>正由于文本不会被浮动的元素覆盖，因此就出现了所谓的“文字环绕”现象，即文字绕着浮动的元素布局。</p>
<p>使用绝对定义的元素，其他盒子也会忽略它，但其它盒子内的文本不同于浮动的脱离文档流，而是会忽略浮动的元素，也从左上角开始布局。</p>
<h2 id="为什么css-选择器的查找是从右往左的"><a href="#为什么css-选择器的查找是从右往左的" class="headerlink" title="为什么css 选择器的查找是从右往左的"></a>为什么css 选择器的查找是从右往左的</h2><p>我们知道 DOM 树和 CSSOM 树会合并成 render 树，这个操作实际上就是需要将 css 附着到 DOM 树上，因此需要根据选择器提供的信息对 DOM 树进行遍历，才能将样式成功附着到对应的 DOM 元素上。</p>
<p>如果我们有这样一段 DOM 树：</p>
<pre class="line-numbers language-none"><code class="language-none">        .main
      &#x2F;       \
  section      aside
  &#x2F; \         &#x2F;   \
h1  .content .desc a
      &#x2F;			  &#x2F;
    p				 p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并定义一段 css：<code>.main .desc p&#123;&#125;</code> ，如果浏览器是从左往右解析 css 选择器：</p>
<ul>
<li>遍历 DOM 树</li>
<li>.main -&gt; .section -&gt; h1 ，发现没有找到指定的 css ，则回溯</li>
<li>.main -&gt; section -&gt; .content -&gt; p ，发现也没有，回溯</li>
<li>.main -&gt; aside -&gt; .desc ，终于成功找到了</li>
</ul>
<p>从左往右解析就是这么麻烦，但如果是从右往左的话，就可以直接找到指定的 css 样式，这样就有效减少了回溯次数，提升了css 解析的性能。</p>
<h2 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h2><h2 id="link-和-import-的区别"><a href="#link-和-import-的区别" class="headerlink" title="link 和 @import 的区别"></a>link 和 @import 的区别</h2><p>两者都是外部引用 css 的方式，区别如下：</p>
<ul>
<li>link 是 XHTML 标签，无兼容问题；@import 是在 css2.1 时提出的，低版本的浏览器不支持；</li>
<li>link 引入 css 时，在页面载入时同时加载；@import 需要在页面完全载入以后再加载；</li>
<li>link 支持使用 JavaScript 去控制 DOM 修改样式，@import不支持；</li>
<li>link 是 XHTML 标签，除了加载 css 外，还可以定义 rss 等其他事务，@import只属于 css 范畴，只能加载 css</li>
</ul>
<h2 id="display-none-与-visibility-hidden-的区别"><a href="#display-none-与-visibility-hidden-的区别" class="headerlink" title="display:none 与 visibility:hidden 的区别"></a>display:none 与 visibility:hidden 的区别</h2><p>这两个属性都是让元素隐藏，不可见。<br>区别如下：</p>
<ul>
<li>在渲染树中<ul>
<li><code>display:none</code> 会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li>
<li><code>visibility:hidden</code> 不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li>
</ul>
</li>
<li>是否是继承属性<ul>
<li><code>display:none</code> 是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li>
<li><code>visibility:hidden</code> 是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置 <code>visibility:visible</code> 可以让子孙节点显示；</li>
</ul>
</li>
<li>修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改 <code>visibility</code> 属性只会造成本元素的重绘；</li>
<li>如果使用读屏器，设置为 <code>display:none</code> 的内容不会被读取，设置为 <code>visibility:hidden</code> 的内容会被读取。</li>
</ul>
<h2 id="伪元素和伪类的区别和作用"><a href="#伪元素和伪类的区别和作用" class="headerlink" title="伪元素和伪类的区别和作用"></a>伪元素和伪类的区别和作用</h2><p>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p>
<p>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。</p>
<p>总结： 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p>
<h2 id="替换元素的概念及计算规则"><a href="#替换元素的概念及计算规则" class="headerlink" title="替换元素的概念及计算规则"></a>替换元素的概念及计算规则</h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p>
<p>替换元素除了内容可替换这一特性以外，还有以下特性：</p>
<ul>
<li>内容的外观不受页面上的CSS的影响：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li>
<li>有自己的尺寸：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素</li>
<li>在很多CSS属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li>
<li>所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li>
</ul>
<p>替换元素的尺寸从内而外分为三类：</p>
<ul>
<li>固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li>
<li>HTML尺寸： 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li>
<li>CSS尺寸： 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li>
</ul>
<p>这三层结构的计算规则具体如下：<br>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。<br>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。<br>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。<br>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。<br>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。<br>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h2 id="常见的图片格式及使用场景"><a href="#常见的图片格式及使用场景" class="headerlink" title="常见的图片格式及使用场景"></a>常见的图片格式及使用场景</h2><p>（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。<br>（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。<br>（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。<br>（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。<br>（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。<br>（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。<br>（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p>
<ul>
<li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li>
<li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li>
<li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>
</ul>
<h2 id="对-CSSSprites-的理解"><a href="#对-CSSSprites-的理解" class="headerlink" title="对 CSSSprites 的理解"></a>对 CSSSprites 的理解</h2><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p>
<p>优点：</p>
<ul>
<li>利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；</li>
<li>CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li>
<li>CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。</li>
<li>维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。</li>
</ul>
<h2 id="css-优化和提高性能的方法有哪些"><a href="#css-优化和提高性能的方法有哪些" class="headerlink" title="css 优化和提高性能的方法有哪些"></a>css 优化和提高性能的方法有哪些</h2><p>加载性能：</p>
<ul>
<li>打包压缩 css ，减小文件体积</li>
<li>不要连写，执行效率会提高</li>
<li>使用 link 而不使用 @import ，前者在页面加载时一起加载，而后者是等待页面加载完之后再进行加载</li>
</ul>
<p>选择器性能：</p>
<ul>
<li>css 选择符是从右到左进行匹配的，尽可能降低选择器的深度</li>
<li>避免使用通配规则，如 <code>*&#123;&#125;</code></li>
<li>不要添加太多的选择器</li>
<li>避免使用属性选择器，而是用 class</li>
<li>了解哪些属性是可以通过继承而来的，避免对这些属性重复指定规则</li>
</ul>
<p>渲染性能：</p>
<ul>
<li>慎重使用高性能属性：浮动、定位。</li>
<li>尽量减少页面重排、重绘。</li>
<li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li>
<li>属性值为0时，不加单位。</li>
<li>属性值为浮动小数0.**，可以省略小数点之前的0。</li>
<li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li>
<li>不使用@import前缀，它会影响css的加载速度。</li>
<li>选择器优化嵌套，尽量避免层级过深。</li>
<li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li>
<li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li>
<li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li>
</ul>
<p>可维护性、健壮性：</p>
<ul>
<li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li>
<li>样式与内容分离：将css代码定义到外部css中。</li>
</ul>
<h2 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h2><ul>
<li>有空格时会有间隙，可以删除空格解决；</li>
<li>使用 <code>font-size</code> 时，可通过设置 <code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li>
<li><code>margin</code> 正值时，可以让 <code>margin</code> 使用负值解决；</li>
</ul>
<h2 id="单行、多行文本溢出隐藏"><a href="#单行、多行文本溢出隐藏" class="headerlink" title="单行、多行文本溢出隐藏"></a>单行、多行文本溢出隐藏</h2><ul>
<li><p>单行文本溢出</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> hiddle<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
<span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>多行文本溢出</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> hiddle<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
<span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>
<span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>
<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> 3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。</p>
<h2 id="z-index属性在什么情况下会失效"><a href="#z-index属性在什么情况下会失效" class="headerlink" title="z-index属性在什么情况下会失效"></a>z-index属性在什么情况下会失效</h2><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。<strong>z-index元素的position属性需要是relative，absolute或是fixed</strong>。</p>
<p>z-index属性在下列情况下会失效：</p>
<ul>
<li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-备战大厂前端实习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/03/08/bei-zhan-da-han-qian-duan-shi-xi/" class="article-date">
      <time datetime="2022-03-08T14:34:03.000Z" itemprop="datePublished">2022-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/03/08/bei-zhan-da-han-qian-duan-shi-xi/">备战大厂前端实习之代码输出结果篇</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
Foo<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
 
<span class="token comment">//请写出以下输出结果：</span>
Foo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Foo<span class="token punctuation">.</span>getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>分析函数表达式和函数声明的提升层级：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//oaoafly</span>
<span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'wscat'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'oaoafly'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这道题涉及到变量提升的机制。函数声明和函数表达式都会被提升，那么是函数声明覆盖函数表达式？还是函数表达式覆盖函数声明？很多人知道是函数表达式覆盖函数声明，但其实这里是有一个条件的：当 js 代码执行到函数表达式时，它才能覆盖函数声明，否则只会提升函数声明（没有函数表达式什么事了）。<br>现在再来看这道题，一开始会提升函数声明，上面的代码可以看成（由于未执行到函数表达式，因此不能提升）：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'oaoafly'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//oaoafly</span>
<span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'wscat'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以第一个 <code>getName()</code> 输出 <code>oaoafly</code> 。当执行到函数表达式后，覆盖函数声明，于是变成</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'wscat'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//oaoafly</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此后两个 <code>getName()</code> 都是输出 <code>wscat</code> 。</p>
<p>下面继续看这道题，也是同样的道理：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> getName <span class="token comment">//变量被提升，此时为undefined</span>

<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了</span>
<span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'wscat'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> <span class="token comment">//函数表达式此时才开始覆盖函数声明的定义</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'oaoafly'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//wscat 这里就执行了函数表达式的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>难度升级：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
			getName<span class="token operator">:</span> getName <span class="token comment">//这个就是第六问中涉及的构造函数的返回值问题</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级</span>
	<span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">&#125;</span>
Foo<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token comment">//答案：</span>
Foo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//4</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1</span>
<span class="token keyword">new</span> <span class="token class-name">Foo<span class="token punctuation">.</span>getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//3</span>
<span class="token comment">//多了一问</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//3 1</span>
<span class="token keyword">new</span> <span class="token class-name">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-备战前端实习面试之HTML篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-html-pian/" class="article-date">
      <time datetime="2022-03-08T14:33:50.000Z" itemprop="datePublished">2022-03-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/03/08/bei-zhan-qian-duan-shi-xi-mian-shi-zhi-html-pian/">备战前端实习面试之HTML篇</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>前端面试题系列小抄：<br>【1】<a href="">备战前端实习面试之HTML篇</a><br>【2】<a href="">备战前端实习面试之CSS篇</a><br>【3】<a href="">备战前端实习面试之JavaScript篇</a><br>【4】<a href="">备战前端实习面试之React篇</a><br>【5】<a href="">备战前端实习面试之Node.js篇</a><br>【6】<a href="">备战前端实习面试之浏览器原理篇</a><br>【8】<a href="">备战前端实习面试之性能优化篇</a><br>【7】<a href="">备战前端实习面试之计算机网络篇</a><br>【9】<a href="">备战前端实习面试之手写代码篇</a><br>【9】<a href="">备战前端实习面试之代码输出结果篇</a></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="html-常用的标签"><a href="#html-常用的标签" class="headerlink" title="html 常用的标签"></a>html 常用的标签</h2><p><code>h</code> <code>p</code> <code>hr</code> <code>br</code> <code>div</code> <code>span</code> <code>ul li</code> <code>ol li</code> <code>img</code> <code>a</code> <code>input</code> <code>label</code> <code>textarea</code> <code>select</code> <code>form</code> <code>head</code> <code>nav</code> <code>footer</code> <code>article</code> <code>section</code> <code>aside</code> <code>audio</code> <code>video</code>  </p>
<h2 id="html-新特性"><a href="#html-新特性" class="headerlink" title="html 新特性"></a>html 新特性</h2><ol>
<li>语义化标签<br><code>header</code>、<code>footer</code>、<code>nav</code>、<code>article</code>、<code>aside</code>、<code>section</code>、<code>meau</code>、<code>template</code></li>
<li>新增媒体元素：<code>audio</code>、<code>video</code></li>
<li>用于绘画的 canvas 属性</li>
<li>新增本地存储方式：<code>sessionStorage</code>、 <code>localStorage</code></li>
<li>新的技术：<code>webworker</code>、<code>websocket</code></li>
<li>新增表单控件：<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li>
</ol>
<h2 id="对语义化的理解"><a href="#对语义化的理解" class="headerlink" title="对语义化的理解"></a>对语义化的理解</h2><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。</p>
<p><strong>好处：</strong></p>
<ul>
<li>对开发者友好，让人容易理解，利于代码可读性</li>
<li>对机器友好，让搜索引擎更容易读懂，利于 SEO</li>
</ul>
<h2 id="说说-web-worker"><a href="#说说-web-worker" class="headerlink" title="说说 web worker"></a>说说 web worker</h2><p><code>web worker</code> 的作用是为 JavaScript 创造多线程环境，允许主线程创建 <code>Worker 线程</code>，然后将一些任务分配给其运行。</p>
<p>在主线程运行的同时，Worker 线程在后台运行，两者互不干扰，等到 Worker 线程完成任务后就将结果返回给主线程。这样的好处是：一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程就会很流畅，不会被阻塞或拖慢（通过 <code>postMessage</code> 将结果传回到主线程即可）。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 <code>Worker</code> 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>这里有几个注意点：</p>
<ol>
<li>同源限制<br>分配给 Worker 线程的脚本文件，必须和主线程脚本文件同源。</li>
<li>通信联系<br>Worker 线程和主线程不在同一个上下文环境，不能直接通信，必须通过消息完成。</li>
<li>DOM 限制<br>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 <code>document</code>、<code>window</code>、<code>parent</code> 这些对象。但是 Worker 线程可以使用 <code>navigator</code> 对象和 <code>location</code> 对象。</li>
<li>脚本限制<br>Worker 线程不能执行 <code>alert()</code> 方法和 <code>confirm()</code> 方法，但可以使用 <code>XMLHttpRequest</code> 对象发出 <code>AJAX</code> 请求。</li>
<li>文件限制<br>Worker 线程无法读取本地文件，即不能打开本机的文件系统，它所加载的脚本，必须来自于网络。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/07/web-worker.html">阮一峰：Web Worker 使用教程</a></p>
</blockquote>
<h2 id="DOCTYPE的作用？严格模式和混杂模式的区别？"><a href="#DOCTYPE的作用？严格模式和混杂模式的区别？" class="headerlink" title="DOCTYPE的作用？严格模式和混杂模式的区别？"></a>DOCTYPE的作用？严格模式和混杂模式的区别？</h2><p><code>!DOCTYPE</code> 告诉浏览器以 <code>HTML5</code> 标准解析页面，如果不写，则进入混杂模式</p>
<ul>
<li>严格模式（标准模式）：以 w3c 标准解析代码</li>
<li>混杂模式（怪异模式）：浏览器用自己的方式解析代码，混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作</li>
</ul>
<h2 id="常⽤的-meta-标签有哪些"><a href="#常⽤的-meta-标签有哪些" class="headerlink" title="常⽤的 meta 标签有哪些"></a>常⽤的 meta 标签有哪些</h2><p>meta 标签由 name 和 content 属性定义，用来描述网页文档的属性。<br>|属性|描述|值|例子|<br>|:–:|:–:|:–:|:–|<br>|charset|HTML文档的编码类型|utf-8<br>gb2312|<code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code>|<br>|keywords|页面关键词|自定义|<code>&lt;meta name=&quot;keywords&quot; content=&quot;关键词&quot; /&gt;</code>|<br>|description|页面描述|自定义|<code>&lt;meta name=&quot;description&quot; content=&quot;页面描述内容&quot; /&gt;</code>|<br>|refresh|页面重定向和刷新|自定义|<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</code>|<br>|viewport|适配移动端，可以控制视口的大小和比例|width viewport ：宽度(数值/device-width)<br>height viewport ：高度(数值/device-height)<br>initial-scale ：初始缩放比例<br>maximum-scale ：最大缩放比例<br>minimum-scale ：最小缩放比例<br>user-scalable ：是否允许用户缩放(yes/no）|<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code>|<br>|robots|搜索引擎索引方式|all：文件将被检索，且页面上的链接可以被查询；<br>none：文件将不被检索，且页面上的链接不可以被查询；<br>index：文件将被检索；<br>follow：页面上的链接可以被查询；<br>noindex：文件将不被检索；<br>nofollow：页面上的链接不可以被查询。|<code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</code>|</p>
<h2 id="iframe-有那些优点和缺点"><a href="#iframe-有那些优点和缺点" class="headerlink" title="iframe 有那些优点和缺点"></a>iframe 有那些优点和缺点</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。<br>优点：</p>
<ul>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ul>
<p>缺点：</p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ul>
<h2 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别"></a>defer 和 async 的区别</h2><p>defer 和 async 都是 script 标签的属性。</p>
<p><strong>defer：</strong></p>
<ul>
<li>在 script 标签添加 defer 属性，就可以让这个 script 外联的 js 变成异步加载。当 html 解析过程中碰到这个 script ，就会开辟一个新线程来下载脚本（这个脚本的下载和 html 的解析是同步的），当脚本下载完毕后不会立即执行，而是等待 html 解析完毕后才开始执行。</li>
<li>所有 defer 的 js 代码都保证按顺序执行。</li>
</ul>
<p><strong>async：</strong></p>
<ul>
<li>在 script 标签添加 async 属性后，html 解析过程中碰到这个 script ，也会开辟新线程来同步下载脚本，下载完毕后会立即执行脚本，并中断 html 解析流程，等到脚本执行完之后再接着解析 html 。</li>
<li>async 的 js 代码不能保证按顺序执行，而是谁先下载完就先执行哪个脚本。</li>
</ul>
<h2 id="HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="HTML5的离线储存怎么使用，它的工作原理是什么"></a>HTML5的离线储存怎么使用，它的工作原理是什么</h2><p>离线存储指的是：在用户没有连接网络时，可以正常访问站点或应用，当连接上网络后，更新用户机器上的缓存文件。</p>
<p>原理：html5 的离线缓存是基于一个新建的 <code>.appcache</code> 文件的缓存机制，即通过这个文件上的解析清单 离线缓存资源。之后当网络在离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>使用方法：</p>
<ol>
<li>创建一个和 html 同名的 <code>.manifest</code> 文件，然后在页面头部插入 <code>manifest</code> 属性：<code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></li>
<li>在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：<pre class="line-numbers language-none"><code class="language-none">CACHE:
  js&#x2F;app.js
  css&#x2F;style.css
NETWORK:
  resourse&#x2F;logo.png
FALLBACK:
  &#x2F; &#x2F;offline.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<ul>
<li>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>
<li>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>
<li>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>
</ul>
<ol start="3">
<li>在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</li>
</ol>
<p>更新缓存的3种方案：</p>
<ul>
<li>更新 manifest 文件</li>
<li>通过 javascript 操作</li>
<li>清除浏览器缓存</li>
</ul>
<p>注意事项：<br>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。<br>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。<br>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。<br>（4）FALLBACK 中的资源必须和 manifest 文件同源。<br>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。<br>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h2 id="浏览器是如何对-HTML5-的离线储存资源进行管理和加载"><a href="#浏览器是如何对-HTML5-的离线储存资源进行管理和加载" class="headerlink" title="浏览器是如何对 HTML5 的离线储存资源进行管理和加载"></a>浏览器是如何对 HTML5 的离线储存资源进行管理和加载</h2><ul>
<li>在线情况下，浏览器发现 html 头部有 <code>manifest</code> 属性，它会请求 <code>.manifest</code> 文件，<strong>如果是第一次访问页面</strong>，那么浏览器就会根据 <code>.manifest</code> 文件的内容下载相应的资源并进行离线存储；<strong>如果已经访问过页面并进行过离线存储</strong>，那么浏览器会使用离线的资源加载页面，然后对比新旧 <code>.manifest</code> 文件，若文件发生改变就会重新下载文件中的资源并进行存储。</li>
<li>离线情况下，浏览器会直接使用离线存储的资源加载页面。</li>
</ul>
<h2 id="行内元素、块级元素，以及两者的区别"><a href="#行内元素、块级元素，以及两者的区别" class="headerlink" title="行内元素、块级元素，以及两者的区别"></a>行内元素、块级元素，以及两者的区别</h2><ol>
<li>行内元素有：<code>a</code>、 <code>br</code>、 <code>cite</code>、 <code>em</code>、 <code>i</code>、 <code>img</code>、 <code>input</code>、 <code>label</code>、 <code>select</code>、 <code>span</code>、 <code>strong</code>、 <code>sub</code>、 <code>sup</code>、 <code>textarea</code></li>
<li>块级元素有：<code>div</code>、<code>p</code>、<code>form</code>、<code>ul</code>、<code>ol</code>、<code>dl</code>、<code>h</code>、<code>hr</code>、<code>table</code>、<code>menu</code>、</li>
<li>区别：</li>
</ol>
<ul>
<li>块级元素独占一行，行内元素不会</li>
<li>块级元素可以设置宽高，行内元素不能</li>
<li>块级元素可以包含行内元素和块级元素，行内元素不能包含块级元素。</li>
<li>块级元素可以设置 <code>margin</code> 和 <code>padding</code> ，行内元素的水平方向的 <code>padding-left</code>、<code>padding-right</code>、<code>margin-left</code>、<code>margin-right</code> 都产生边距效果，但是竖直方向的 <code>padding-top</code>、<code>padding-bottom</code>、<code>margin-top</code>、<code>margin-bottom</code> 都不会产生边距效果。（水平方向有效，竖直方向无效）<blockquote>
<p>若是设置为行内块级元素，它也不能独占一行，但能设置宽高</p>
</blockquote>
</li>
</ul>
<h2 id="渐进增强、优雅降级，以及两者的区别"><a href="#渐进增强、优雅降级，以及两者的区别" class="headerlink" title="渐进增强、优雅降级，以及两者的区别"></a>渐进增强、优雅降级，以及两者的区别</h2><ol>
<li>渐进增强：针对低版本浏览器也能保证基础功能，然后对高级浏览器改进追加功能（向上兼容）。</li>
<li>优雅降级：一开始就构建站点的完整功能，然后针对浏览器进行测试和修复（向下兼容）。</li>
<li>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。</li>
</ol>
<h2 id="canvas-和-svg-的区别"><a href="#canvas-和-svg-的区别" class="headerlink" title="canvas 和 svg 的区别"></a>canvas 和 svg 的区别</h2><ul>
<li>canvas是画布，适合图形密集型的游戏，不支持事件处理</li>
<li>svg是矢量图，不依赖分辨率，不适合游戏，适合大型渲染区域（地图），支持事件处理</li>
</ul>
<h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><ul>
<li>src 是引入外部资源下载到文档，会暂停其他资源的下载</li>
<li>href  是链接外部资源，不会暂停其他资源的下载</li>
</ul>
<h2 id="label-的作用"><a href="#label-的作用" class="headerlink" title="label 的作用"></a>label 的作用</h2><p><code>label</code> 标签为 input 元素定义标注。</p>
<p>作用：用于绑定一个表单元素，当点击 <code>label</code> 标签的时候，被绑定的表单元素就会获得输入焦点。</p>
<h2 id="title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别"><a href="#title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别" class="headerlink" title="title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别"></a>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别</h2><p><code>title</code> 属性没有明确意义只表示是个标题，<code>h1</code> 则表示层次明确的标题。<br><code>strong</code> 标签有语义，是起到加重语气的效果，而 <code>b</code> 标签是没有的。虽然都能加粗字体，但搜索引擎更侧重 <code>strong</code> 标签。<br><code>i</code> 内容展示为斜体，<code>em</code> 表示强调的文本</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%B1%82%E8%81%8C/">求职</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/" rel="tag">实习面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-前端必须知道的开发调试知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/22/qian-duan-bi-xu-zhi-dao-de-kai-fa-diao-shi-zhi-shi/" class="article-date">
      <time datetime="2022-01-22T14:52:40.000Z" itemprop="datePublished">2022-01-22</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/22/qian-duan-bi-xu-zhi-dao-de-kai-fa-diao-shi-zhi-shi/">前端必须知道的开发调试知识</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="浏览器控制台面板"><a href="#浏览器控制台面板" class="headerlink" title="浏览器控制台面板"></a>浏览器控制台面板</h2><p>浏览器的控制台有很多可供开发者 debug 的功能，在如下图片红色框中可以看到有多个面板各司其职，开发人员可以根据自己的实际情况在相应的板块进行调试<br><img src="https://s4.ax1x.com/2022/01/23/749WDO.png" alt="浏览器控制台面板"></p>
<h3 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h3><p>动态修改元素和样式</p>
<ul>
<li>点击 <code>.cls</code> 动态修改元素的 <code>class</code> ，输入字符串可以动态的给元素添加类名，勾选/取消类名可以动态的查看类名生效效果 <img src="https://s4.ax1x.com/2022/01/22/7hb98e.png" alt=".cls 修改样式"></li>
<li>点击具体的样式值（字号、颜色、宽度高度等）可以进行编辑，浏览器内容区域可以实时预览 <img src="https://s4.ax1x.com/2022/01/22/7hbVVP.png" alt="修改样式值"></li>
<li><code>Computed</code> 下点击样式里的箭头可以跳转到 <code>styles</code> 面板中的 css 规则 <img src="https://s4.ax1x.com/2022/01/22/7hbFKA.png" alt="定位 css 规则"></li>
<li>可以用以下 2 种方式强制激活伪类：<ul>
<li>选中具有伪类的元素，点击 <code>:hov</code> <img src="https://s4.ax1x.com/2022/01/22/7hbPvd.png" alt=":hov 进行固定"></li>
<li>DOM 树右键菜单，选择 <code>Force State</code><h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><pre class="line-numbers language-none"><code class="language-none">console.log
console.warn
console.error
console.debug
console.info
console.table：更加直观的展示 JSON 和数组数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
可以看到共有 6 种打印方式<img src="https://s4.ax1x.com/2022/01/22/7hHXHx.png" alt="6 种打印方式">，并且在 <code>Console</code> 面板的左侧可以选择等级，对日志进行分类查看（如果找不到左侧的分类，则是因为被隐藏了，点击按钮打开即可<img src="https://s4.ax1x.com/2022/01/22/7hbe58.png" alt="打印 Console 左侧面板">）</li>
</ul>
</li>
</ul>
<p>值得一提的是 <code>console.table</code> ，该打印可以直观的展示 JSON 和数组数据，如图：<img src="https://s4.ax1x.com/2022/01/22/7hba24.png" alt="console.table"></p>
<p>由于打印字体在未经样式设置时是统一的，如果想醒目的查看的打印信息，可以通过占位符的方式修改打印信息以达到目的，先看看都有什么占位符：</p>
<pre class="line-numbers language-none"><code class="language-none">%s：字符串占位符；
%o：对象占位符；
%c：样式占位符；
%d：数字占位符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么通过一个例子来看看怎么使用这些占位符，帮助我们在开始过程中更加快速的查看打印信息：<br><img src="https://s4.ax1x.com/2022/01/22/7hbGV0.png" alt="占位符例子"></p>
<h3 id="Sorce"><a href="#Sorce" class="headerlink" title="Sorce"></a>Sorce</h3><p><img src="https://s4.ax1x.com/2022/01/22/7hbvss.png" alt="Sorce 面板概览"></p>
<ul>
<li>区域①：页面资源文件目录树</li>
<li>区域②：代码预览区域</li>
<li>区域③：Debug 工具栏，从左到右依次为<ul>
<li>暂停（继续）</li>
<li>单步跳过</li>
<li>进入函数</li>
<li>跳出函数</li>
<li>单步执行</li>
<li>激活（关闭）所有断点</li>
<li>代码执行异常处自动断点</li>
</ul>
</li>
<li>区域④：断点调试器</li>
</ul>
<h4 id="Break-Points-与-Watch"><a href="#Break-Points-与-Watch" class="headerlink" title="Break Points 与 Watch"></a>Break Points 与 Watch</h4><p><img src="https://s4.ax1x.com/2022/01/23/74SFKO.png" alt="Break Points 与 Watch"></p>
<ul>
<li>在本地代码中使用关键字 <code>debugger</code> 或在代码预览区域的行号设置断点</li>
<li>执行到断点处时代码暂停执行</li>
<li>展开 <code>Breakpoints</code> 列表可以查看断点列表，勾选/取消可以激活/禁用对应断点</li>
<li>暂停状态下，鼠标 hover 变量可以查看变量的值</li>
<li>在调试器 <code>Watch</code> 右侧点击 + 可以添加对变量的监控，查看该变量的值<h4 id="Scope-与-Call-Stack"><a href="#Scope-与-Call-Stack" class="headerlink" title="Scope 与 Call Stack"></a>Scope 与 Call Stack</h4><img src="https://s4.ax1x.com/2022/01/23/74SlM8.png" alt="Scope 与 Call Stack"></li>
<li>展开 <code>Scope</code> 可以查看作用域列表（包含闭包）</li>
<li>展开 <code>Call Stack</code> 可以查看当前 JavaScript 代码的调用栈<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><img src="https://s4.ax1x.com/2022/01/23/74SjQf.png" alt="Performance 面板概览"></li>
<li>区域①：控制面板</li>
<li>区域②：概览面板<ul>
<li>FPS：每秒帧数</li>
<li>CPU：处理各个任务花费的时间</li>
<li>NET：各个请求花费的时间</li>
</ul>
</li>
<li>区域③：线程面板<ul>
<li>Frames：帧线程</li>
<li>Main：主线程，负责执行 JavaScript ，解析 HTML/CSS ，完成绘制</li>
<li>Raster：Raster 线程，负责完成某个 layer 或者某些块（tile）的绘制</li>
</ul>
</li>
<li>区域④：统计面板<h3 id="NetWork"><a href="#NetWork" class="headerlink" title="NetWork"></a>NetWork</h3><img src="https://s4.ax1x.com/2022/01/23/74pyX8.png" alt="NetWork 面板概览"></li>
<li>区域①：控制面板</li>
<li>区域②：过滤面板</li>
<li>区域③：概览区域</li>
<li>区域④：Request Table 面板</li>
<li>区域⑤：总结面板</li>
<li>区域⑥：请求详情面板<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><img src="https://s4.ax1x.com/2022/01/23/74pz1x.png" alt="Application 面板概览"><br>Application 面板展示与本地存储相关的信息</li>
<li>Local Storage</li>
<li>Session Storage</li>
<li>IndexedDB</li>
<li>Web SQL</li>
<li>Cookie</li>
</ul>
<p>点击左侧 <code>Application</code> 下的 <code>Stroage</code> 面板中的 <code>Clear Site Data</code> 可以清除网页的本地存储数据</p>
<h2 id="常用开发调试技巧"><a href="#常用开发调试技巧" class="headerlink" title="常用开发调试技巧"></a>常用开发调试技巧</h2><h3 id="线上即时修改-Overrides"><a href="#线上即时修改-Overrides" class="headerlink" title="线上即时修改 Overrides"></a>线上即时修改 Overrides</h3><ol>
<li>打开 <code>Sources</code> 面板下的 <code>Overrides</code></li>
<li>点击 <code>Select folders for Overrides</code> 。选择一个本地的空文件夹目录<br><img src="https://s4.ax1x.com/2022/01/23/74PU7F.png" alt="选择保存修改的文件夹"></li>
<li>允许授权</li>
<li>在 <code>page</code> 中修改代码，修改完成后 <code>command + s</code> 保存</li>
<li>打开 DevTools ，点击右上角的三个小点 -&gt; More tools -&gt; Changes ，就能看到所有修改了（红色代表修改前，绿色代表修改后）<br><img src="https://s4.ax1x.com/2022/01/23/74PXNQ.png" alt="对比更改后的代码"><h3 id="利用代理解决开发阶段的跨域问题"><a href="#利用代理解决开发阶段的跨域问题" class="headerlink" title="利用代理解决开发阶段的跨域问题"></a>利用代理解决开发阶段的跨域问题</h3>常见的有通过 <code>nginx</code> 来进行代理<h3 id="启动本地-source-map"><a href="#启动本地-source-map" class="headerlink" title="启动本地 source map"></a>启动本地 source map</h3>线上不存在 <code>Source Map</code> 时可以使用 <code>Map Local</code> 网络映射功能来访问本地的 <code>Source Map</code> 文件<h3 id="小黄鸭调试大法"><a href="#小黄鸭调试大法" class="headerlink" title="小黄鸭调试大法"></a>小黄鸭调试大法</h3>传说中程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向小黄鸭解释每行代码，然后很快就将问题定位修复了 –《程序员修炼之道》</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E8%B0%83%E8%AF%95/">调试</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/" rel="tag">开发调试技巧</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A7%E5%88%B6%E5%8F%B0/" rel="tag">浏览器控制台</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-CSS3-新特性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/22/css3-xin-te-xing/" class="article-date">
      <time datetime="2022-01-22T11:23:21.000Z" itemprop="datePublished">2022-01-22</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/22/css3-xin-te-xing/">CSS3 新特性</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h2><ol>
<li>过渡<br>transition： <code>transition-property</code>【CSS属性】，<code>transition-duration</code>【花费时间】，<code>transition-timing-function</code>【效果曲线（默认ease）】，<code>transition-delay</code>【延迟时间（默认0）】。</li>
</ol>
<pre class="line-numbers language-css" data-language="css"><code class="language-css">// 连写（可以省略后面的两个参数）：
transition：width<span class="token punctuation">,</span> 5s<span class="token punctuation">,</span> ease<span class="token punctuation">,</span> 2s

<span class="token property">transition-property</span><span class="token punctuation">:</span> width<span class="token punctuation">;</span>
<span class="token property">transition-duration</span><span class="token punctuation">:</span> 1s<span class="token punctuation">;</span>
<span class="token property">transition-timing-function</span><span class="token punctuation">:</span> linear<span class="token punctuation">;</span>
<span class="token property">transition-delay</span><span class="token punctuation">:</span> 2s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>transition-timing-function 的参数：<br>|值|描述|<br>|:–|:–|<br>|linear|匀速（等于 cubic-bezier(0,0,1,1)）|<br>|ease|逐渐变慢（cubic-bezier(0.25,0.1,0.25,1)）|<br>|ease-in|加速（等于 cubic-bezier(0.42,0,1,1)）|<br>|ease-out|减速（等于 cubic-bezier(0,0,0.58,1)）|<br>|ease-in-out|先加速后减速（等于 cubic-bezier(0.42,0,0.58,1)）|<br>|cubic-bezier(n,n,n,n)|在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值|<br>2. 动画<br>①animation：<code>animation-name</code>【动画名称】，<code>animation-duration</code>【一个周期花费时间】，<code>animation-timing-function</code>【运动曲线（默认ease）】，<code>animation-delay</code>【动画延迟（默认0）】，<br><code>animation-fill-mode</code>，<code>animation-direction</code>【是否反向播放动画（默认normal）】，<code>animation-iteration-count</code>【播放次数（默认1）】，<code>animation-play-state</code>【是否暂停动画（默认 running ）】<br>②告诉系统外面需要自己创建一个名称叫做xxx的动画</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@keyframes</span> 动画名称</span> <span class="token punctuation">&#123;</span>
    <span class="token selector">from</span> <span class="token punctuation">&#123;</span>

    <span class="token punctuation">&#125;</span>
    <span class="token selector">to</span> <span class="token punctuation">&#123;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>animation-name</code>    规定动画的名称。由大小写敏感的字母a-z、数字0-9、下划线（_）和 <code>/</code> 或横线（-）组成。<em>第一个非横线字符必须是字母，数字不能在字母前面，不允许两个横线出现在开始位置</em>  </li>
<li><code>animation-duration</code>    规定动画完成一个周期所花费的秒或毫秒。默认是 0 ，表示无动画。  </li>
<li><code>animation-timing-function</code>    规定动画的速度曲线。默认是 “ease”。可选参数如下： </li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linear</td>
<td align="left">动画从头到尾的速度是相同的。</td>
</tr>
<tr>
<td align="left">ease</td>
<td align="left">默认。动画以低速开始，然后加快，在结束前变慢。</td>
</tr>
<tr>
<td align="left">ease-in</td>
<td align="left">动画以低速开始。</td>
</tr>
<tr>
<td align="left">ease-out</td>
<td align="left">动画以低速结束。</td>
</tr>
<tr>
<td align="left">ease-in-out</td>
<td align="left">动画以低速开始和结束。</td>
</tr>
<tr>
<td align="left">cubic-bezier(n,n,n,n)</td>
<td align="left">在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li><code>animation-delay</code>    规定动画何时开始。默认是 0。  </li>
<li><code>animation-fill-mode</code>    规定对象动画在执行之前和之后如何将样式应用于其目标。可选参数如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">默认状态，回到动画没开始时的状态。</td>
</tr>
<tr>
<td align="left">forwards</td>
<td align="left">让动画停留在结束状态。</td>
</tr>
<tr>
<td align="left">backwards</td>
<td align="left">让动画回到第一帧的状态。</td>
</tr>
<tr>
<td align="left">both</td>
<td align="left">向前和向后填充模式都被应用。</td>
</tr>
</tbody></table>
<ul>
<li><p><code>animation-direction</code>    规定动画是否在下一周期逆向地播放。默认是 “normal”。可选参数如下：</p>
</li>
<li><p>normal    默认值。动画正常播放。    </p>
</li>
<li><p>alternate    动画轮流反向播放。</p>
</li>
<li><p>reverse 动画反向播放。</p>
</li>
<li><p>alternate-reverse 动画反向轮流播放。<br>效果如图：<img src="https://s4.ax1x.com/2022/01/23/74ynDH.png" alt="animation-direction 参数效果"></p>
</li>
<li><p><code>animation-iteration-count</code> 规定动画被播放的次数。默认是 1。无限播放则是 infinite  </p>
</li>
<li><p><code>animation-play-state</code>    规定动画是否正在运行或暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。默认是 “running”。可选参数如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">paused</td>
<td align="left">规定动画已暂停。</td>
</tr>
<tr>
<td align="left">running</td>
<td align="left">规定动画正在播放。</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">initial</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">unset</td>
<td align="left">/</td>
</tr>
</tbody></table>
<ol start="3">
<li>形状转换  </li>
</ol>
<ul>
<li>transform-origin    定义形变点的位置。</li>
<li>2D transform 方法<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token function">translate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>	定义 2D 转换，沿着 X 和 Y 轴移动元素。
    <span class="token function">translateX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>	定义 2D 转换，沿着 X 轴移动元素。
    <span class="token function">translateY</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>	定义 2D 转换，沿着 Y 轴移动元素。

<span class="token function">rotate</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>	定义 2D 旋转，在参数中规定角度，参数为数值、单位 deg。

<span class="token function">scale</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>	定义 2D 缩放转换，改变元素的宽度和高度，参数为数值、无单位。
    <span class="token function">scaleX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>	定义 2D 缩放转换，改变元素的宽度。
    <span class="token function">scaleY</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>	定义 2D 缩放转换，改变元素的高度。

<span class="token function">matrix</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span>	定义 2D 转换，使用六个值的矩阵。

<span class="token function">skew</span><span class="token punctuation">(</span>x-angle<span class="token punctuation">,</span>y-angle<span class="token punctuation">)</span>	定义 2D 倾斜转换，沿着 X 和 Y 轴，参数为数值、单位 deg。
    <span class="token function">skewX</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>	定义 2D 倾斜转换，沿着 X 轴。
    <span class="token function">skewY</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>	定义 2D 倾斜转换，沿着 Y 轴。

x-axis	定义视图被置于 X 轴的何处。可能的值：left，center，right，length，%
y-axis	定义视图被置于 Y 轴的何处。可能的值：top，center，bottom，length，%
z-axis	定义视图被置于 Z 轴的何处。可能的值：length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>3D Transform 方法<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token function">matrix3d</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span>	定义 3D 转换，使用 16 个值的 4x4 矩阵。
<span class="token function">translate3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>	定义 3D 转化。
    <span class="token function">translateX</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>	定义 3D 转化，仅使用用于 X 轴的值。
    <span class="token function">translateY</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>	定义 3D 转化，仅使用用于 Y 轴的值。
    <span class="token function">translateZ</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>	定义 3D 转化，仅使用用于 Z 轴的值。

<span class="token function">scale3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>	定义 3D 缩放转换。
    <span class="token function">scaleX</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>	定义 3D 缩放转换，通过给定一个 X 轴的值。
    <span class="token function">scaleY</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>	定义 3D 缩放转换，通过给定一个 Y 轴的值。
    <span class="token function">scaleZ</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>	定义 3D 缩放转换，通过给定一个 Z 轴的值。

<span class="token function">rotate3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">,</span>angle<span class="token punctuation">)</span>	定义 3D 旋转。
    <span class="token function">rotateX</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>	定义沿 X 轴的 3D 旋转。
    <span class="token function">rotateY</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>	定义沿 Y 轴的 3D 旋转。
    <span class="token function">rotateZ</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>	定义沿 Z 轴的 3D 旋转。

<span class="token function">perspective</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>	定义 3D 转换元素的透视视图。

x-axis	定义视图被置于 X 轴的何处。可能的值：left，center，right，length，%
y-axis	定义视图被置于 Y 轴的何处。可能的值：top，center，bottom，length，%
z-axis	定义视图被置于 Z 轴的何处。可能的值：length

transform-style	规定被嵌套元素如何在 3D 空间中显示。
    flat	子元素将不保留其 3D 位置。
    preserve-3d	子元素将保留其 3D 位置。

perspective	规定 3D 元素的透视效果（近大远小）。
    number	元素距离视图的距离，以像素计。
    none	默认值。与 0 相同。不设置透视。

perspective-origin	规定 3D 元素的底部位置。
    x-axis	定义该视图在 x 轴上的位置。默认值：50%。可能的值：left，center，right，length，%
    y-axis	定义该视图在 y 轴上的位置。默认值：50%。可能的值：top，center，bottom，length，%

backface-visibility	定义元素在不面对屏幕时是否可见。
    visible	背面是可见的。
    hidden	背面是不可见的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="4">
<li><p>阴影<br><code>box-shadow</code>：水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里）;</p>
</li>
<li><p>边框图片<br><code>border-image</code>：图片url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认0） 铺满方式–重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch））;</p>
</li>
<li><p>边框圆角<br><code>border-radius</code>：左上角，右上角，右下角，左下角;</p>
</li>
<li><p>背景  </p>
</li>
</ol>
<ul>
<li><code>background-clip</code> 规定背景的绘制区域         <ul>
<li>border-box    背景被裁剪到边框盒。</li>
<li>padding-box    背景被裁剪到内边距框。</li>
<li>content-box    背景被裁剪到内容框。</li>
</ul>
</li>
<li><code>background-origin</code>    <ul>
<li>padding-box    背景图像相对于内边距框来定位。    </li>
<li>border-box    背景图像相对于边框盒来定位。</li>
<li>content-box    背景图像相对于内容框来定位。</li>
</ul>
</li>
<li><code>background-size</code><ul>
<li>length    设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。</li>
<li>percentage    以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。</li>
<li>cover    把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</li>
<li>contain    把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</li>
</ul>
</li>
</ul>
<ol start="8">
<li><p>反射<br><code>-webkit-box-reflect</code>：方向【above-上 | below-下 | right-右 | left-左】，偏移量，遮罩图片</p>
</li>
<li><p>文字阴影<br><code>text-shadow</code>：水平阴影，垂直阴影，模糊的距离，以及阴影的颜色</p>
</li>
<li><p>颜色<br><code>rgba</code>（rgb为颜色值，a为透明度）<br><code>hsla</code>（h：色相”，“s：饱和度”，“l：亮度”，“a：透明度”）</p>
</li>
<li><p>渐变</p>
</li>
<li><p>Filter（滤镜）</p>
</li>
</ol>
<ul>
<li>黑白色 filter: grayscale(100%)</li>
<li>褐色 filter:sepia(1)</li>
<li>饱和度 saturate(2)</li>
<li>色相旋转 hue-rotate(90deg)</li>
<li>反色 filter:invert(1)</li>
<li>透明度 opacity(.5)</li>
<li>亮度 brightness(.5)</li>
<li>对比度 contrast(2)</li>
<li>模糊 blur(3px)</li>
<li>阴影 drop-shadow(5px 5px 5px #000)</li>
</ul>
<ol start="13">
<li><p>混合模式  </p>
<ul>
<li>background-blend-mode（用于同一个元素的背景图片和背景颜色）<ul>
<li>multiply 正片叠底</li>
<li>screen 滤色</li>
<li>overlay 叠加</li>
<li>darken 变暗</li>
<li>lighten 变亮</li>
<li>color-dodge 颜色减淡模式</li>
<li>color-burn 颜色加深</li>
<li>hard-light 强光</li>
<li>soft-light 柔光</li>
<li>difference 差值</li>
<li>exclusion 排除</li>
<li>hue 色相</li>
<li>saturation 饱和度</li>
<li>color 颜色</li>
<li>luminosity 亮度</li>
</ul>
</li>
<li>mix-blend-mode（用于一个元素的背景图片或者颜色和子元素）<ul>
<li>数值同 background-blend-mode</li>
</ul>
</li>
</ul>
</li>
<li><p>多列布局  </p>
<ul>
<li><p>加上私有前缀，兼容</p>
<ul>
<li>-webkit- （谷歌，Safari，新版Opera浏览器，以及几乎所有iOS系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于WebKit 内核的浏览器）</li>
<li>-moz- （火狐浏览器）</li>
<li>-o- （旧版Opera浏览器）</li>
<li>-ms- （IE浏览器 和 Edge浏览器）</li>
</ul>
</li>
<li><p>column-count    规定元素应该被分隔的列数。</p>
</li>
<li><p>column-fill    规定如何填充列。</p>
</li>
<li><p>column-gap    规定列之间的间隔。</p>
</li>
<li><p>column-rule    设置所有 column-rule-* 属性的简写属性。</p>
</li>
<li><p>column-rule-color    规定列之间规则的颜色。</p>
</li>
<li><p>column-rule-style    规定列之间规则的样式</p>
</li>
<li><p>column-rule-width    规定列之间规则的宽度。</p>
</li>
<li><p>column-span    规定元素应该横跨的列数。</p>
</li>
<li><p>column-width    规定列的宽度。</p>
</li>
<li><p>columns    规定设置 column-width 和 column-count 的简写属性</p>
</li>
</ul>
</li>
<li><p>媒体查询<br>语法：@media 媒体类型 and （媒体特性）{你的样式}</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>600px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span>900px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token selector">body</span> <span class="token punctuation">&#123;</span><span class="token property">background-color</span><span class="token punctuation">:</span>#f5f5f5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>not关键词<ul>
<li>使用关键词“not”是用来排除某种制定的媒体类型，也就是用来排除符合表达式的设备。换句话说，not关键词表示对后面的表达式执行取反操作，如：  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token keyword">not</span> print <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>1200px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    样式代码
<span class="token punctuation">&#125;</span>

// 上面代码表示的是：样式代码将被使用在除打印设备和设备宽度小于1200px下的所有设备中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li>only关键词<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/927790abdd80">媒体查询使用方法@media</a></li>
</ul>
</li>
<li>媒体类型<ul>
<li>all    用于所有媒体类型设备。</li>
<li>print    用于打印机。</li>
<li>screen    用于计算机屏幕、平板电脑、智能手机等等。</li>
<li>speech    用于大声“读出”页面的屏幕阅读器。</li>
</ul>
</li>
<li>媒体特性<ul>
<li>如果是横屏landscape、竖屏portrait，则语法：orientation：portrait | landscape  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token keyword">only</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">orientation</span><span class="token punctuation">:</span>landscape<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token selector">body</span> <span class="token punctuation">&#123;</span>
        <span class="token property">background-color</span><span class="token punctuation">:</span>lightblue<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
但与CSS属性不同的是，媒体特性是通过min/max来表示大于等于或小于做为逻辑判断，而不是使用小于（&lt;）和大于（&gt;）这样的符号来判断<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span>480px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token selector">.ads</span><span class="token punctuation">&#123;</span>
        <span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

上面代码表示的是：当屏幕小于或等于480px时，页面中的广告区块（.ads）都讲被隐藏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
更复杂的媒体查询</li>
</ul>
</li>
<li>媒体查询中的“与”逻辑  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>400px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">orientation</span><span class="token punctuation">:</span>landscape<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token selector">body</span><span class="token punctuation">&#123;</span>
        <span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>媒体查询中的“或”逻辑  <pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span>400px<span class="token punctuation">)</span><span class="token punctuation">,</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">orientation</span><span class="token punctuation">:</span>landscape<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token selector">body</span><span class="token punctuation">&#123;</span>
        <span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>媒体查询中的“非”逻辑可以用not操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。<pre><code class="css">@media not all and (orientation:landscape) &#123;
    body&#123;
        color:blue;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-CSS-盒模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/11/css-he-mo-xing/" class="article-date">
      <time datetime="2022-01-11T09:44:10.000Z" itemprop="datePublished">2022-01-11</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/11/css-he-mo-xing/">CSS 盒模型</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>盒模型又称框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。它有两种分类，分别是<strong>标准模型</strong>和 <strong>IE 模型</strong>。</p>
<h2 id="标准模型和-IE-模型的区别"><a href="#标准模型和-IE-模型的区别" class="headerlink" title="标准模型和 IE 模型的区别"></a>标准模型和 IE 模型的区别</h2><p>IE模型和标准模型唯一的区别是内容计算方式的不同：</p>
<ul>
<li>IE 模型元素宽度 <code>width = content + padding + border</code> ，高度计算相同</li>
<li>标准模型元素宽度 <code>width = content</code> ，高度计算相同</li>
</ul>
<p>通过两幅图可以直观了解到区别所在：<br><img src="https://s4.ax1x.com/2022/01/11/7mF13T.png" alt="IE 模型"><br><img src="https://s4.ax1x.com/2022/01/11/7mFlCV.png" alt="标准模型"></p>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>盒模型分为两种，那么问题来了，是什么因素让浏览器决定使用哪一种盒模型来渲染页面呢？<br>有两种解决方案：</p>
<ul>
<li>编写 html 文件时，我们可以在其头部第一行看见这样的代码 <code>&lt;!DOCTYPE html &gt;</code> ，这个是文档类型声明，只要浏览器看到这行代码就会用标准盒模型来渲染页面；如果没有这行代码，各个浏览器就会按照自己的标准去使用不同的盒模型来渲染。</li>
<li>通过文档声明的方式来渲染可以实现我们的目的，但是很被动。CSS3 给出了一种解决方法：<code>box-sizing</code> ，通过设置这个属性，就可以指定某种盒模型来渲染页面。<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2>通过 css3 新增的属性 <code>box-sizing: content-box | border-box |  inherit</code> 分别设置盒模型为<strong>标准模型（content-box）</strong> 和 <strong>IE 模型（border-box）</strong>。</li>
<li>content-box：盒子宽高是 <code>content(内容)</code> 的宽高  </li>
<li>border-box：盒子宽高是 <code>border + padding + content</code> 的宽高。</li>
<li>inherit：规定应从父元素继承 <code>box-sizing</code> 属性的值。<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2></li>
</ul>
<ol>
<li>在解释什么是BFC之前，我们需要先知道Box、Formatting Context的概念：</li>
</ol>
<ul>
<li>Formatting Context<br>它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</li>
<li>Box：css布局的基本单位<br>直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。有三种盒子：<ul>
<li>block-level box：display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li>
<li>inline-level box：display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li>
<li>run-in box: css3 中才有</li>
</ul>
</li>
</ul>
<ol start="2">
<li>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</li>
<li>BFC的布局规则</li>
</ol>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ul>
<ol start="4">
<li>如何创建BFC<ul>
<li>根元素或包含根元素的元素，如<code>&lt;html&gt;</code></li>
<li> 浮动元素（元素的 float 不是 none）</li>
<li> 绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li> 行内块元素（元素的 display 为 inline-block）</li>
<li> 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>
<li> 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>
<li> 匿名表格单元格元素【元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table】</li>
<li>  overflow 值不为 visible 的块元素</li>
<li>  display 值为 <a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-display/#valdef-display-flow-root">flow-root</a> 的元素</li>
<li>  contain 值为 layout、content或 strict 的元素</li>
<li> 弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>
<li> 网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>
<li> 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>  column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
</li>
<li>BFC的作用<ul>
<li>利用BFC避免margin重叠。</li>
<li>阻止元素被浮动元素覆盖 -&gt; 可应用于自适应两栏布局（避免右侧与左侧发生重叠)</li>
<li>清除浮动<br>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。这个时候我们根据最后一条规则：计算BFC的高度时，浮动元素也参与计算。于是给父节点激活BFC</li>
</ul>
</li>
<li>举个栗子</li>
</ol>
<p>页面布局如下：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>页面样式如下：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.left</span> <span class="token punctuation">&#123;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token selector">.right</span> <span class="token punctuation">&#123;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>页面效果如图：<img src="https://s4.ax1x.com/2022/01/11/7ms2ef.png" alt="未设置 BFC 之前"><br>我们看到图片中蓝色块因为浮动叠在了绿色块上面，如果我们的需求是不让这两者发生重叠，解决方法可以是对绿色块启动 BFC ，即在 .right 元素中添加 <code>overflow:hidden</code> （其他启动 BFC 的样式也可），这时就可以看到效果如图：<img src="https://s4.ax1x.com/2022/01/11/7myT4e.png" alt="设置 BFC 之后"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-CSS-选择器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/11/css-xuan-ze-qi/" class="article-date">
      <time datetime="2022-01-11T05:15:46.000Z" itemprop="datePublished">2022-01-11</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/11/css-xuan-ze-qi/">CSS 选择器</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><ol>
<li>关于css属性选择器常用的有以下这些：<pre class="line-numbers language-css" data-language="css"><code class="language-css">id选择器（#box） -->选择id为box的元素
类选择器（.one） -->选择类名为one的所有元素
标签选择器（div） -->选择标签为div的所有元素
后代选择器（#box div） -->选择id为box元素内部所有的div元素
子选择器（.one>one_1） -->选择父元素为.one的所有.one_1的元素
相邻兄弟选择器（.one+.two） -->选择紧接在.one之后的所有.two元素
交集选择器（div.one） -->选择类名为one的所有div元素
并集选择器（div<span class="token punctuation">,</span>p） -->选择所有div和p元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>还有一些使用频率相对没那么多的选择器：</li>
</ol>
<ul>
<li>伪类选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span>link ：选择未被访问的链接
<span class="token punctuation">:</span><span class="token property">visited：选取已被访问的链接</span>
<span class="token punctuation">:</span><span class="token property">active：选择活动链接</span>
<span class="token punctuation">:</span>hover ：鼠标指针浮动在上面的元素
<span class="token punctuation">:</span>focus ：选择具有焦点的
<span class="token punctuation">:</span>first-child：同级别中的第一个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>伪元素选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span><span class="token punctuation">:</span>first-letter ：用于选取指定选择器的首字母
<span class="token punctuation">:</span><span class="token punctuation">:</span>first-line ：选取指定选择器的首行
<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">before</span> <span class="token punctuation">:</span> 选择器在被选元素的内容前面插入内容
<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token property">after</span> <span class="token punctuation">:</span> 选择器在被选元素的内容后面插入内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>属性选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css">[attribute] 选择带有attribute属性的元素
[attribute=value] 选择所有使用attribute=value的元素
[attribute~=value] 选择attribute属性包含value的元素
[attribute|=value]：选择attribute属性以value开头的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="3">
<li>在CSS3中新增的选择器还有：</li>
</ol>
<ul>
<li>通用兄弟选择器（p~ul），选择p元素下的所有ul元素</li>
<li>结构化伪类选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span>last-child 同级别中的最后一个标签
<span class="token punctuation">:</span><span class="token function">nth-child</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 同级别中的第n个元素
<span class="token punctuation">:</span><span class="token function">nth-child</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span> <span class="token property">同级别中的所有奇数</span>
<span class="token punctuation">:</span><span class="token function">nth-child</span><span class="token punctuation">(</span>even<span class="token punctuation">)</span> <span class="token property">同级别中的所有偶数</span>
<span class="token punctuation">:</span>only-child <span class="token property">父元素中唯一的标签</span>

<span class="token punctuation">:</span>first-of-type 同级别中同类型的第一个元素
<span class="token punctuation">:</span>last-of-type 同级别中同类型的最后一个元素
<span class="token punctuation">:</span><span class="token function">nth-of-type</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 同级别中同类型的第n个元素
<span class="token punctuation">:</span><span class="token function">nth-last-of-type</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 同级别中同类型的倒数第n个元素
<span class="token punctuation">:</span>only-of-type  <span class="token property">父元素中唯一的同类型的标签</span>

<span class="token punctuation">:</span>root 设置HTML文档
<span class="token punctuation">:</span>empty 指定空的元素
<span class="token punctuation">:</span>enabled 选择被禁用元素
<span class="token punctuation">:</span>disabled 选择被禁用元素
<span class="token punctuation">:</span>checked 选择选中的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>属性选择器<pre class="line-numbers language-css" data-language="css"><code class="language-css">[attribute|=value]：选择attribute属性开头为value，且value是被-或其他内容隔开的所有元素
[attribute^=value]：选择attribute属性开头为value的所有元素，无论value会不会被-隔开
[attribute$=value]：选择attribute属性结尾为value的所有元素
[attribute~=value]：选择attribute属性值包含value，且value被空格隔开的所有元素
[attribute*=value]：选择attribute属性值包含value的所有元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="CSS-三大特性"><a href="#CSS-三大特性" class="headerlink" title="CSS 三大特性"></a>CSS 三大特性</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性。在 CSS 的继承中，不仅仅是儿子可以继承，只要是后代都可以继承。</p>
<ol>
<li>可继承的属性</li>
</ol>
<ul>
<li>所有元素可以继承的属性：<ul>
<li>元素可见性：<code>visibility</code></li>
<li>光标属性：<code>cursor：箭头可以变成需要的形状</code></li>
</ul>
</li>
<li>内联元素可以继承的属性：<ul>
<li>字体系列属性  <pre class="line-numbers language-css" data-language="css"><code class="language-css">font：组合字体
font-family：字体系列
font-weight：字体的粗细
font-size：字体的大小
font-style：字体的风格
font-variant：偏大或偏小的字体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>文本系列属性  <pre class="line-numbers language-css" data-language="css"><code class="language-css">text-indent：文本缩进
text-align：文本水平
line-height：行高
word-spacing：单词之间的间距
letter-spacing：中文或者字母之间的间距
text-transform：控制文本大小写
direction：规定文本的书写方向
color：文本颜色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>表格布局属性  <pre class="line-numbers language-css" data-language="css"><code class="language-css">caption-side：定位表格标题位置
border-collapse：合并表格边框
border-spacing：设置相邻单元格的边框间的距离
empty-cells：单元格的边框的出现与消失
table-layout：表格的宽度由什么决定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>列表属性<pre class="line-numbers language-css" data-language="css"><code class="language-css">list-style-type：文字前面的小点点样式
list-style-position：小点点位置
list-style：以上的属性可通过这属性集合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>引用：<code>quotes：设置嵌套引用的引号类型</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li>不可继承的属性</li>
</ol>
<ul>
<li>a 标签的字体颜色</li>
<li>h 标签字体的大小</li>
<li>display：规定元素应该生成的框的类型</li>
<li>文本属性：<ul>
<li>vertical-align：垂直文本对齐</li>
<li>text-decoration：规定添加到文本的装饰</li>
<li>text-shadow：文本阴影效果</li>
<li>white-space：空白符的处理</li>
<li>unicode-bidi：设置文本的方向</li>
</ul>
</li>
<li>盒子模型的属性：width、height、margin、border、padding</li>
<li>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li>生成内容属性：content、counter-reset、counter-increment</li>
<li>轮廓样式属性：outline-style、outline-width、outline-color、outline</li>
<li>页面样式属性：size、page-break-before、page-break-after</li>
<li>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ul>
<h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>层叠性就是 CSS 处理冲突的一种能力。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>什么是优先级：当多个选择器选中同一个标签，并且给同一个标签设置相同的属性时，如何层叠就由优先级来确定。</p>
<p>优先级判断的3种方式：</p>
<ol>
<li>是否是直接选中（间接选中就是值继承）</li>
</ol>
<ul>
<li>如果是间接选中，那么就是谁离目标标签比较近就听谁的</li>
</ul>
<ol start="2">
<li>相同选择器（直接选中）</li>
</ol>
<ul>
<li>如果都是直接选中，并且都是同类型的选择器，那么就是谁写在后面就听谁的</li>
</ul>
<ol start="3">
<li>不同选择器（直接选中）</li>
</ol>
<ul>
<li>如果都是直接选中，并且不是相同类型的选择器，那么就会按照选择器的优先级来层叠：【!important &gt;】内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器【&gt; 通配符 &gt; 继承 &gt; 浏览器默认属性】</li>
</ul>
<p>如果是多个选择器混合在一起使用，就需要计算权重。<br>权重的计算规则：</p>
<ol>
<li>首先计算选择器中有多少个 id ，id 多的选择器优先级最高</li>
<li>如果 id 的个数一样，那么再看类名的个数，类名个数多的优先级最高</li>
<li>如果这两者的个数都一样，同时标签名称个数也一样，那么就不会继续往下计算了，此时谁写在后面就听谁的。也就是说优先级如果一样，那么谁写在后面就听谁的<blockquote>
<p>注意：只有选择器是直接选中标签的才需要计算权重，否则一定会听直接选中的选择器的 </p>
</blockquote>
</li>
</ol>
<p>如果再到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>
<ul>
<li>如果存在内联样式，那么 A = 1, 否则 A = 0</li>
<li>B的值等于 ID选择器出现的次数</li>
<li>C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数</li>
<li>D 的值等于 标签选择器 和 伪元素 出现的总次数</li>
</ul>
<p>这里举个例子：#nav-global &gt; ul &gt; li &gt; a.nav-link ，套用上面的算法，依次求出 A B C D 的值：</p>
<ul>
<li>因为没有内联样式 ，所以 A = 0</li>
<li>ID选择器总共出现了1次， B = 1</li>
<li>类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C = (1 + 0 + 0) = 1</li>
<li>标签选择器出现了3次， 伪元素出现了0次，所以 D = (3 + 0) = 3</li>
<li>上面算出的A 、 B、C、D 可以简记作：(0, 1, 1, 3)</li>
</ul>
<p>知道了优先级是如何计算之后，就来看看比较规则：</p>
<ul>
<li>从左往右依次进行比较 ，较大者优先级更高</li>
<li>如果相等，则继续往右移动一位进行比较</li>
<li>如果4位全部相等，则后面的会覆盖前面的</li>
<li>经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用 <code>!important</code></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-JS-之内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/10/js-zhi-nei-cun-guan-li/" class="article-date">
      <time datetime="2022-01-10T02:49:42.000Z" itemprop="datePublished">2022-01-10</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/10/js-zhi-nei-cun-guan-li/">JS 之内存管理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h2><p>JS有两种数据类型，分别是原始数据类型（<code>String、Number、Boolean、Null、Undefined、Symbol</code>）和引用数据类型（<code>Object</code>）。<br>而存放这两种数据类型的内存又可以分为两部分，分别是栈内存（Stack）和堆内存（Heap）。</p>
<p>这里说下栈内存和堆内存的区别：<br>|栈内存|堆内存|<br>|:–:|:–:|<br>|先进后出，后进先出|无序存储，根据引用直接获取|<br>|存储原始数据类型|存储引用数据类型|<br>|存储的值大小固定|存储的值大小不固定，可动态调整|<br>|按值访问|按引用访问|<br>|可以直接操作|不允许直接操作|<br>|空间小，但运行效率高|空间大，但运行效率相对低|</p>
<p>不知道大家有没有过这样一个疑问：Js 声明变量时，底层是怎么实现这个声明过程的，或者说是怎么存储这个变量的，感兴趣的话可以看看下面这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.dennisgo.cn/Articles/JavaScript/MemoryManagement.html#%E6%A0%88%E5%86%85%E5%AD%98">原始数据类型是如何存进栈内存的</a>  </li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015118062">基本类型和引用类型发生复制行为后的不同影响</a></li>
</ul>
<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：   </p>
<ol>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放/归还</li>
</ol>
<p>JS的内存分配</p>
<ol>
<li>值的初始化<br>在定义变量时就完成了内存分配</li>
<li>使用值<br>使用值的过程实际上是对分配内存进行读取与写入的操作。这个操作可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</li>
<li>释放不再需要的内存</li>
</ol>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak），会导致内存溢出。</p>
<blockquote>
<p>内存溢出：指程序申请内存时，没有足够的内存供申请者使用。例如，给一块存储int类型数据的存储空间，但却存储long类型的数据，那么结果就是内存不够用，此时就会报错，即所谓的内存溢出。</p>
</blockquote>
<h3 id="常见-JavaScript-内存泄露"><a href="#常见-JavaScript-内存泄露" class="headerlink" title="常见 JavaScript 内存泄露"></a>常见 JavaScript 内存泄露</h3><ol>
<li>意外的全局变量 </li>
</ol>
<p>①未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window 。<br>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  bar <span class="token operator">=</span> <span class="token string">"this is a hidden global variable"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 实际上是：</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  window<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"this is an explicit global variable"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  如果 bar 是一个应该指向 foo 函数作用域内变量的引用，但是你忘记使用 var 来声明这个变量，这时就会创建一个全局变量。</p>
<p>  ②另一种意外的全局变量可能由 this 创建：<br>  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>variable <span class="token operator">=</span> <span class="token string">"potential accidental global"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  函数自身发生了调用，this 指向全局对象（window）</p>
<p>  为了防止这种错误的发生，可以在你的 JavaScript 文件开头添加 <code>&#39;use strict&#39;;</code> 语句。这个语句实际上开启了解释 JavaScript 代码的严格模式，可以避免创建意外的全局变量。</p>
<p>总结：</p>
<ul>
<li>全局变量的注意事项：如果你必须使用全局变量来存储很多的数据，请确保在使用过后将它设置为 <code>null</code> 或者将它<strong>重新赋值</strong>。常见的和全局变量相关的引发内存消耗增长的原因就是缓存。（缓存存储着可复用的数据）</li>
<li>解决方法：①避免创建全局变量；②使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 use strict。</li>
</ul>
<ol start="2">
<li>闭包引起的内存泄漏</li>
</ol>
<p>原理：闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。 </p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> leaks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  
  <span class="token keyword">var</span> leak <span class="token operator">=</span> <span class="token string">'xxxxxx'</span><span class="token punctuation">;</span> <span class="token comment">// 被闭包所引用，不会被回收</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>leak<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 比如：在循环中的函数表达式，能复用最好放到循环外面。</span>
<span class="token comment">// 不要这样：</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> <span class="token function-variable function">t</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 创建了10次函数对象</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">t</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 这样比较好：</span>
<span class="token keyword">function</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">t</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
t <span class="token operator">=</span> <span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="3">
<li>没有清理的 DOM 元素引用</li>
</ol>
<p>原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 在对象中引用DOM</span>
<span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  btn<span class="token operator">:</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  elements<span class="token punctuation">.</span>btn<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">removeBtn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 将body中的btn移除，也就是移除DOM树中的btn</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 但是此时全局变量 elements 还是保留了对 btn 的引用，btn 还是存在于内存中，不能被 GC 回收</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法：手动删除，elements.btn = null。</p>
<ol start="4">
<li><p>没有移除计时器或回调函数</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。</span>

<span class="token comment">// 定时器</span>
<span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'renderer'</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    renderer<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span>

<span class="token comment">// 观察者模式</span>
<span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"I'm innerHTML"</span>
<span class="token punctuation">&#125;</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法：①手动删除定时器和 dom；②removeEventListener 移除事件监听</p>
</li>
<li><p>循环引用 </p>
</li>
</ol>
<p>当出现了一个含有DOM对象的循环引用时，就会发生内存泄露。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="内存泄露的解决方案"><a href="#内存泄露的解决方案" class="headerlink" title="内存泄露的解决方案"></a>内存泄露的解决方案</h3><p>下面的方案是从网上搜索到的资料，本人并没有实践过（主要是还不懂），仅供大家参考：</p>
<ul>
<li> 显式类型转换</li>
<li> 避免事件导致的循环引用</li>
<li> 不影响返回值地打破循环引用</li>
<li> 延迟appendChild</li>
<li> 代理DOM对象<blockquote>
<p>更加具体的解决方法可点击这里：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67843006?from=from_parent_mindnote">传送门</a></p>
</blockquote>
<h2 id="V8-垃圾回收机制"><a href="#V8-垃圾回收机制" class="headerlink" title="V8 垃圾回收机制"></a>V8 垃圾回收机制</h2>上文有提到：内存会发生泄露是因为没有及时释放多余的内存。那么问题来了，应该由谁去释放多余的内存，又是怎么释放内存的？答案是 V8 垃圾回收机制。在了解这个机制之前，我们先来认识下什么是 V8 。<h3 id="认识V8"><a href="#认识V8" class="headerlink" title="认识V8"></a>认识V8</h3>V8 是 Google 采用 C++ 编写的开源 JavaScript 引擎。采用即时编译，直接翻译成机器语言，并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。</li>
</ul>
<p>V8内存设限：64bit操作系统上不超过1.5G，32bit操作系统上不超过800M 这么设限为了浏览器使用内存足够，内部还有垃圾运行机制，时间也在用户感知的合理范围</p>
<p>目前V8垃圾回收采用增量标记算法需要50ms，采用非增量标记算法需要1s</p>
<p>这里先停一下，康康这篇文章再往下会更好：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018605776">前端面试：谈谈 JS 垃圾回收机制</a></p>
<hr>
<p>ddd，如果已经看完了上面这篇文章，就让我们继续往下吧~</p>
<h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><p>一般来说没有被引用的对象就是垃圾，就是要被清除。 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p>
<h3 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h3><p>基本思路：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。值得注意的是，垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用–属于“不可判定的”问题，这意味着靠算法是解决不了的。</p>
<p>我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在，此时，栈（或堆）内存会分配空间以保存相应的值。当函数在内部使用了变量，然后退出，此时，就不再需要那个局部变量了，它占用的内存可以释放了。但垃圾回收程序并不知道哪个局部变量是要被释放的，因此，程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用。</p>
<p>原始数据都是由程序语言自身控制的，这里的回收还是指主要存活在堆区的对象数据，这个过程是离不开内存操作的，那在这种情况下是如何对垃圾进行回收的?答案是：</p>
<ol>
<li>采用分代回收的思想</li>
<li>内存分为新生代存储区、老生代存储区</li>
<li>针对不同代采用不同的 GC 算法</li>
</ol>
<p>下面针对 GC 算法展开讨论。</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>相关概念：</p>
<ul>
<li><p>GC：垃圾回收机制的简写，垃圾回收期完成具体的工作，可以找到内存中的垃圾、并释放和回收空间</p>
</li>
<li><p>GC 算法：是 GC 工作时查找和回收所遵循的规则</p>
<h3 id="常见-GC-算法："><a href="#常见-GC-算法：" class="headerlink" title="常见 GC 算法："></a>常见 GC 算法：</h3></li>
<li><p>引用计数（不太常用）</p>
<ul>
<li>核心思想：跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成 0 了，就可以将其内存空间回收。</li>
<li>实现原理：<ul>
<li>引用计数器</li>
<li>当引用关系改变时修改引用数字</li>
<li>当引用数字为0时立即回收</li>
</ul>
</li>
<li>实例：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>age<span class="token operator">:</span><span class="token number">11</span><span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> user2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>age<span class="token operator">:</span><span class="token number">12</span><span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> user3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>age<span class="token operator">:</span><span class="token number">13</span><span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> nameList <span class="token operator">=</span> <span class="token punctuation">[</span>user1<span class="token punctuation">.</span>age<span class="token punctuation">,</span> user2<span class="token punctuation">.</span>age<span class="token punctuation">,</span> user<span class="token punctuation">.</span>age<span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> num2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    num3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当函数调用过后，<code>num1</code> 和 <code>num2</code> 在外部不能使用，引用数为 0，会被回收;</li>
<li><code>num3</code> 是挂载在window上的，所以不会被回收;</li>
<li><code>user1</code>、<code>user2</code>、<code>user3</code> 被 <code>nameList</code> 引用，所以引用数不为 0，故不会被回收 ;</li>
</ul>
</li>
<li>优缺点：<table>
<thead>
<tr>
<th align="center">引用计数算法</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="left">1.发现垃圾时立即回收<br>2.最大限度减少程序暂停，让空间不会有被占满的时候</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="left">1.无法回收循环引用的对象<br>2.资源消耗开销大（对所有对象进行数值的监控和修改，本身就会占用时间和资源）</td>
</tr>
</tbody></table>
<ul>
<li>举一栗子说明上面缺点中无法回收循环应用对象的情况：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> 
  <span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  obj1<span class="token punctuation">.</span>name <span class="token operator">=</span> obj2 
  obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> obj1
  <span class="token keyword">return</span> <span class="token string">'hello world'</span> 
<span class="token punctuation">&#125;</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
  obj1 和 obj2 因为互相有引用，所以计数器并不为 0 ，fn 调用结束之后依旧无法回收这两个对象</li>
</ul>
</li>
</ul>
</li>
<li><p>标记清除（最常用）</p>
<ul>
<li>核心思想：<strong>当变量进入执行上下文时</strong>（比如在函数内部声明一个变量时），这个变量会被加上存在于上下文中的标记；<strong>而在上下文中的变量</strong>，从逻辑上来说，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们；<strong>当变量离开上下文时</strong>，也会被加上离开上下文的标记【也有的说法是标记被清除，不过《JavaScript 高级程序设计》中写的是前者，就以该书为主吧】。于是当垃圾回收时就会销毁那些带标记的值并回收他们的内存空间。</li>
<li>实现原理：分 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段完成<ul>
<li>第一阶段：遍历所有对象找活动对象（可达对象）进行标记（层次用递归进行操作）<ol>
<li>有一组基本的固有可达值，由于显而易见的原因无法删除。例如:<ul>
<li>本地函数的局部变量和参数</li>
<li>当前嵌套调用链上的其他函数的- 变量和参数</li>
<li>全局变量</li>
<li>还有一些其他的，内部的这些值称为根。</li>
</ul>
</li>
<li>如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的<ul>
<li>例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为可达性， 它引用的那些也是可以访问的。</li>
</ul>
</li>
</ol>
</li>
<li>第二阶段：遍历所有对象，清除没有标记的对象，并抹掉第一个阶段标的标记<ul>
<li>注意：js中的标记是标记所有的变量，清除掉被标记为离开状态的变量；而老生代中的标记使标记存活的变量，清除没有被标记的变量。（什么是老生代？后面会讲到的）</li>
</ul>
</li>
<li>收尾：回收相应空间，将回收的空间加到空闲链表中，方便后面的程序申请空间使用</li>
</ul>
</li>
<li>优缺点：<table>
<thead>
<tr>
<th align="center">标记清除算法</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="left">1.相对于引用计数算法来说，解决了对象循环引用的问题。因为局部作用域里面的内容无法被标记，所以即使有引用还是会被清除掉<br>2.回收速度较快</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="left">1.空间链表地址不连续（空间碎片化），不能进行空间最大化使用<br>2.不会立即回收垃圾对象，清除的时候程序是停止工作的</td>
</tr>
</tbody></table>
<ul>
<li>下面是空间链表地址不连续的图示，可以更好的帮我们理解这个缺点是怎么肥事：<img src="https://s4.ax1x.com/2022/01/10/7EKZIs.jpg" alt="不连续空间链表"></li>
</ul>
</li>
</ul>
</li>
<li><p>标记整理</p>
<ul>
<li><p>核心思想：在 标记 和 清除 中间，添加了内存空间的 整理</p>
</li>
<li><p>实现原理：（标记整理可以看做是标记清除的 增强）</p>
<ul>
<li>标记阶段：与标记清除一致</li>
<li>整理阶段：清除垃圾前先执行整理操作，移动对象位置，在地址上产生连续</li>
<li>最后留出了整个的空闲空间</li>
</ul>
</li>
<li><p>流程图示：<br><img src="https://s4.ax1x.com/2022/01/10/7EK1LF.png" alt="未整理前"><br><img src="https://s4.ax1x.com/2022/01/10/7EK8Z4.png" alt="整理后"><br><img src="https://s4.ax1x.com/2022/01/10/7EKlsU.png" alt="回收后"></p>
</li>
<li><p>优缺点：</p>
<table>
<thead>
<tr>
<th align="center">标记整理算法</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="left">相较标记清除算法减少了碎片化空间</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="left">不会立即回收垃圾对象，清除的时候程序是停止工作的</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>空间复制</p>
<ul>
<li>新生代区域垃圾回收使用空间换时间</li>
<li>主要采用复制算法，要有空闲空间存在，当然新生代本身空间小，分出来的复制的空间更小，所以浪费这点空间换取时间的效率是微不足道的</li>
<li>老生代区域垃圾回收不适合复制算法，老生代空间大一分为二，会造成一半的空间浪费，存放数据多复制时间长。</li>
</ul>
</li>
<li><p>分代回收 (一定会用)</p>
<ul>
<li>新生代对象回收<blockquote>
<p>新生代 —— 就是指存活时间较短的对象，例如：一个局部作用域中，只要函数执行完毕之后变量就会回收。</p>
</blockquote>
<ul>
<li>主要使用算法：采用赋值算法 + 标记整理算法</li>
<li>回收过程：<ul>
<li>新生代内存区分为<strong>两个等大小空间</strong>，使用空间为From，空闲空间为To</li>
<li>如果需要申请空间使用，回收步骤如下：<ol>
<li>首先会将所有活动对象存储于From空间，这个过程中To是空闲状态。   </li>
<li>当From空间使用到一定程度之后就会触发GC操作，这个时候会进行标记整理——对活动对象进行标记并移动位置将使用空间变得连续。<br><img src="https://s4.ax1x.com/2022/01/10/7EKQMT.png" alt="步骤 1、2 图示"></li>
<li>将活动对象拷贝至To空间，拷贝完成之后活动空间就有了备份，这个时候就可以考虑回收操作了。</li>
<li>把From空间完成释放，回收完成。<br><img src="https://s4.ax1x.com/2022/01/10/7EKnGq.png" alt="步骤 3、4 图示"> </li>
<li>对From和To名称进行调换，继续重复之前的操作。<br><img src="https://s4.ax1x.com/2022/01/10/7EKmin.png" alt="步骤 5 图示"></li>
</ol>
</li>
</ul>
</li>
<li>这种算法的缺点是：只能使用堆内存的一半。</li>
<li>总结：使用From -&gt; 触发GC标记整理 -&gt; 拷贝到To -&gt; 回收From -&gt; 名称互换 -&gt; 重复之前</li>
</ul>
</li>
<li>晋升<ul>
<li>定义：拷贝的过程中某个对象的指代在老生代空间，就可能出现晋升。 晋升就是将新生代对象移动至老生代。</li>
<li>什么时候触发晋升操作?<ul>
<li>1.<strong>一轮GC之后还存活的新生代对象</strong>就需要晋升</li>
<li>2.在拷贝过程中，To空间的使用率超过25%，将这次的活动对象都移动至老生代空间<ul>
<li>Q：为什么设置25%这个阈值</li>
<li>A：当这次回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>老生代对象回收<blockquote>
<p>老生代 —— 就是指存活时间较长的对象，例如：全局对象，闭包变量数据。</p>
</blockquote>
<ul>
<li>主要使用算法：主要采用标记清除 （首要） 、标记整理、增量标记算法</li>
</ul>
</li>
<li>V8内存空间一分为二，分为新生代存储区和老生代存储区<ul>
<li>左边小空间用于存储新生代对象<ul>
<li>64bit操作系统上不超过32M</li>
<li>32bit操作系统上不超过16M</li>
</ul>
</li>
<li>右边较大空间用于存储老生代对象<ul>
<li>64bit操作系统上不超过1.6G</li>
<li>32bit操作系统上不超过700M</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>标记增量 (提高效率用)</p>
<ul>
<li>将一整段的垃圾回收操作标记拆分成多个小段完成回收，主要是为了实现程序和垃圾回收的交替完成，这样进行 效率优化 带来的时间消耗更加的合理。</li>
<li>优化垃圾回收：看图可以将垃圾回收分成两个部分，一个是程序的执行，一个是垃圾的回收。当垃圾回收的时候其实会阻塞程序的执行，所以中间会有空档期。<br>  <img src="../img/12.png"><blockquote>
<p>这篇文章也挺好，小伙伴们可以看看：<a target="_blank" rel="noopener" href="http://newhtml.net/v8-garbage-collection/">传送门</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-什么是闭包" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/09/shi-me-shi-bi-bao/" class="article-date">
      <time datetime="2022-01-09T13:02:10.000Z" itemprop="datePublished">2022-01-09</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/09/shi-me-shi-bi-bao/">什么是闭包</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>指有权访问外层函数作用域中的变量的函数。</p>
<p>什么意思呢？举个栗子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>a</code> 对于 foo 函数来说，属于外层函数作用域中的变量，由于作用域链，使得 foo 函数可以访问到变量 <code>a</code> ，因此就构成了一个闭包。</p>
<h3 id="创建闭包的方式"><a href="#创建闭包的方式" class="headerlink" title="创建闭包的方式"></a>创建闭包的方式</h3><p>那么该如何创建一个闭包呢？<br>常见方式：就是<strong>在一个函数内部创建另一个函数。</strong></p>
<h3 id="执行上下文的角度看闭包"><a href="#执行上下文的角度看闭包" class="headerlink" title="执行上下文的角度看闭包"></a>执行上下文的角度看闭包</h3><p>下面从执行上下文的角度看下闭包是怎么一回事：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> scope<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>
<li>全局执行上下文初始化</li>
<li>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
</ol>
<blockquote>
<p>思考一个问题：当 f 函数执行的时候，checkscope 函数上下文已经被销毁了(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p>
</blockquote>
<ul>
<li>这是因为 f 执行上下文维护了一个作用域链：<pre class="line-numbers language-js" data-language="js"><code class="language-js">fContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> checkscopeContext<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>就是因为这个作用域链，<code>f</code> 函数依然可以读取到 <code>checkscopeContext.AO</code> 的值，说明当 <code>f</code> 函数引用了 <code>checkscopeContext.AO</code> 中的值的时候，即使 <code>checkscopeContext</code> 被销毁了，但是 JavaScript 依然会让 <code>checkscopeContext.AO</code> 活在内存中，<code>f</code> 函数依然可以通过 <code>f</code> 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</li>
</ul>
<h3 id="一道刷题必刷，面试必考的闭包题"><a href="#一道刷题必刷，面试必考的闭包题" class="headerlink" title="一道刷题必刷，面试必考的闭包题"></a>一道刷题必刷，面试必考的闭包题</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来分析一下为什么答案全为 3 ？</p>
<ul>
<li>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：<pre class="line-numbers language-js" data-language="js"><code class="language-js">globalContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token constant">VO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>
    data<span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    i<span class="token operator">:</span><span class="token number">3</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：<pre class="line-numbers language-js" data-language="js"><code class="language-js">data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Context <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>data[0]Context 的 AO 并没有 i 值，所以会从 <code>globalContext.VO</code> 中查找，i 为 3，所以打印的结果就是 3。</li>
<li>data[1] 和 data[2] 是一样的道理。</li>
</ul>
<p><strong>将上面的题改成闭包看看：</strong></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：（跟没改之前一模一样）  <pre class="line-numbers language-js" data-language="js"><code class="language-js">globalContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token constant">VO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>
        data<span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        i<span class="token operator">:</span><span class="token number">3</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：  <pre class="line-numbers language-js" data-language="js"><code class="language-js">data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>Context <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> 匿名函数Context<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>匿名函数执行上下文的AO为：  <pre class="line-numbers language-js" data-language="js"><code class="language-js">匿名函数Context <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token constant">AO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>
        arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>
            <span class="token number">0</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>
            length<span class="token operator">:</span><span class="token number">1</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        i<span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><code>data[0]Context</code> 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数<code> Context.AO</code> 中查找，这时候就会找 i 为 0，找到了就不会往 <code>globalContext.VO</code> 中查找了（即使 <code>globalContext.VO</code> 也有 i 的值–为3），所以打印的结果就是0。</li>
<li>data[1] 和 data[2] 是一样的道理。</li>
</ul>
<p>以下代码块中，c 会报错，并不会读取到bar 执行上下文中变量对象c</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">innerFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    fn <span class="token operator">=</span> innerFoo<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>虽然 fn() ，即 innerFoo() 是在 bar 里面执行的，但是 innerFoo 函数执行的时候它的作用域 scope 里面分别是 <code>[AO,fooContext.AO, globalContext.AO]</code> ，并没有包括 barContext.AO 在里面，所以根本就没有声明 c 这个变量，所以报错</li>
</ul>
<h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><blockquote>
<p>推荐阅读文章：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003985390">[译] JavaScript：立即执行函数表达式（IIFE）</a></p>
</blockquote>
<p>当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"Barry"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 无法从外部访问变量 name</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出错误："Uncaught ReferenceError:name is not defined"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"Barry"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// IIFE 执行后返回的结果：</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Barry"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-TCP-的流量控制机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/08/tcp-de-liu-liang-kong-zhi-ji-zhi/" class="article-date">
      <time datetime="2022-01-08T02:17:55.000Z" itemprop="datePublished">2022-01-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/08/tcp-de-liu-liang-kong-zhi-ji-zhi/">TCP 的流量控制机制</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E8%BE%93%E5%B1%82/" rel="tag">运输层</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-TCP-的运输连接管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/06/tcp-de-yun-shu-lian-jie-guan-li/" class="article-date">
      <time datetime="2022-01-05T16:31:19.000Z" itemprop="datePublished">2022-01-06</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/06/tcp-de-yun-shu-lian-jie-guan-li/">TCP 的运输连接管理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="TCP-运输连接的三个阶段"><a href="#TCP-运输连接的三个阶段" class="headerlink" title="TCP 运输连接的三个阶段"></a>TCP 运输连接的三个阶段</h2><p>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的，共有三个阶段，即：</p>
<ul>
<li>连接建立（“三报文握手”）</li>
<li>数据传送</li>
<li>连接释放（“四报文挥手”）</li>
</ul>
<p>TCP 连接的建立采用客户–服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>，被动等待连接建立的应用进程叫做<strong>服务器</strong>。</p>
<blockquote>
<p>下文将<strong>客户</strong>简写为 A ，将<strong>服务器</strong>简写为 B 。</p>
</blockquote>
<h2 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>TCP 建立连接的过程叫做<strong>握手</strong>，握手需要在 A 和 B 之间交换三个 TCP 报文段。</p>
<p>首先，来认识一下握手挥手中用到的一些标识位和缩写的含义：</p>
<ul>
<li>SYN（Synchronize Sequence Numbers)：同步序列编号，表示建立链接</li>
<li>FIN：标识位，表示关闭链接</li>
<li>ACK（Acknowledgement）：标识位，表示响应</li>
<li>ack（Acknowledgement Number）：确认号码，是期望收到对方下一个报文的第一个数据字节的序号</li>
<li>seq（Sequence Number）：顺序号码（TCP连接中传送的字节流中的每个字节都按顺序编号）</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>接下来先看下 TCP 三次握手的流程图：<br><img src="https://s4.ax1x.com/2022/01/05/TXqBZ9.png" alt="TCP 三次握手流程图"></p>
<ul>
<li>最初两端的 TCP 进程都处于 <code>CLOSED</code> （关闭）状态。</li>
<li>一开始，B 的 TCP 服务器进程先创建 <strong>传输控制块 TCB</strong> 【用于存储 TCP 连接中的一些重要信息，如 TCP 连接表、指向发送和接收缓存的指针、当前的发送和接收序号】，准备接受 A 的连接请求。然后服务器进程就处于 <code>LISTEN</code>（收听）状态，等待客户的链接请求。</li>
<li>A 的 TCP 客户进程也是首先创建 <strong>传输控制块 TCB</strong>。然后，在打算建立 TCP 连接时，向 B 发送 TCP 连接请求报文段，并进入 <code>SYN-SENT</code> （同步已发送）状态。<br>TCP 连接请求报文段首部中的同步位 <code>SYN = 1</code>（表明这是一个 TCP 连接请求报文段）；序号字段 <code>seq = x</code> （作为 TCP 客户进程所选择的初始序号）。【注意：TCP 规定 <code>SYN = 1</code> 的报文段不能携带数据，但要<strong>消耗掉一个序号</strong>。】</li>
<li>B 收到 TCP 连接请求报文段后，如果同意建立连接，则向 A 发送 TCP 连接请求确认报文段，并进入 <code>SYN-RCVD</code> （同步已接受）状态。<br>该报文段首部中的同步位 <code>SYN</code> 和确认位 <code>ACK</code> 都设置为 1 （表明这是一个 TCP 连接请求确认报文段）；序号字段 <code>seq = y</code>（作为 TCP 服务器进程所选择的初始序号），确认号字段 <code>ack = x + 1</code> （这是对 TCP 客户进程所选择的初始序号的确认）。【注意：这个报文段也不能携带数据，因为它是 <code>SYN</code> 被设置为 1 的报文段，但同样要消耗掉一个序号】。</li>
<li>A 收到 B 的确认后，还要向 B 发送一个普通的 TCP 确认报文段，并进入 <code>ESTABLISHED</code> （连接已建立）状态。<br>该报文段首部中的确认位 <code>ACK = 1</code> (表明这是一个普通的 TCP 确认报文段）；序号字段 <code>seq = x + 1</code> （这是因为 TCP 客户进程发送的第一个 TCP 报文段的序号为 x ，并且不携带数据，因此第二个报文段的序号为 x + 1）。【注意： TCP 规定普通的 TCP 确认报文段可以携带数据，但如果不携带数据，则不消耗序号】。在这种情况下，所发送的下一个数据报文段的序号仍是 <code>seq = x + 1</code>；确认号字段 <code>ack</code> 被设置为 y + 1 （这是对 TCP 服务器进程所选择的初始序号的确认）。</li>
<li>TCP 服务器进程收到该确认报文段后也进入 <code>ESTABLISHED</code> （连接已建立）状态。现在，TCP 双方都进入了连接已建立状态，他们可以基于已建立好的 TCP 连接进行可靠的数据传输了。</li>
</ul>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li>Q：为什么 A 最后还要发送一次确认呢，只有两次握手不行吗？  </li>
</ol>
<p>A：防止已经失效的连接请求报文突然又传送到服务器，从而导致不必要的错误和资源的浪费。  </p>
<p>所谓“已失效的连接请求报文段”是这样产生的：  </p>
<ul>
<li>先考虑一种正常情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 重新发送一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。这时 A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B ，没有“已失效的连接请求报文段”。  </li>
<li>现假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B 。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误以为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 B 发出确认新的连接就建立了。<br>而由于现在 A 不并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。这样的话， B 的许多资源就这样白白浪费了。</li>
</ul>
<ol start="2">
<li>Q：那为什么不是四次握手？五次六次不可以吗？  </li>
</ol>
<p>A：三次握手的目的是确认双方发送和接收的能力，当然，如果要 100 次都可以，但为了解决问题，三次就足够了，再多用处就不大了。</p>
<ol start="3">
<li>Q：三次握手过程中可以携带数据么？  </li>
</ol>
<p>A1：第三次握手的时候，可以携带。前两次握手不能携带数据。<br>A2：如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。<br>A3：第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。</p>
<h2 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h2><p>先看下四次挥手的流程图，心里有数好一点：<br><img src="https://s4.ax1x.com/2022/01/06/TvT11O.png" alt="TCP 四次挥手流程图"></p>
<ul>
<li>当TCP 的运输连接管理的第二个阶段-数据传输结束后，通信的双方都可释放连接。</li>
<li>现在 A 和 B 都处于 <code>ESTABLISHED</code> （连接已建立）状态。假设 A 的应用进程通知其主动关闭 TCP 连接，就发送 TCP 连接释放报文段，停止发送数据，并进入 <code>FIN-WAIT-1</code> （终止等待1）状态。<br>TCP 连接释放报文段首部中的终止位 <code>FIN</code> 和确认为 <code>ACK</code> 的值都被设置为 1 （表明这是一个 TCP 连接释放报文段，同时也对之前收到的报文段进行确认）；序号 <code>seq = u</code> （它等于 TCP 客户进程之前已传送过的数据的最后一个字节的序号加 1 ）【注意：TCP 规定终止位 FIN 等于 1 的报文段即使不携带数据，也要消耗掉一个序号。】；确认号 <code>ack = v</code> （它等于 TCP 客户进程之前已收到的数据的最后一个字节的序号加 1 ）。</li>
<li>B 收到 TCP 连接释放报文段后，会发送一个普通的 TCP 确认报文段并进入 <code>CLOSE-WAIT</code>（关闭等待） 状态。<br>TCP 确认报文段首部中的确认位 <code>ACK = 1</code> （表明这是一个普通的 TCP 确认报文段）；序号 <code>seq = v</code> （它等于 TCP 服务器进程之前已传送过的数据的最后一个字节的序号加 1 ，这也与之前收到的 TCP 连接释放报文段中的确认号匹配）；确认号 <code>ack = u + 1</code> （这是对 TCP 连接释放报文段的确认）。<br>收到 A 发来的连接释放报文段后，B 应用进程这时应通知高层应用进程：TCP 客户进程要断开与自己的 TCP 连接。于是，从 A –&gt; B 这个方向的连接就释放了。这时的 TCP 连接属于 <code>half-close</code> （半关闭）状态，也就是 A 已经没有数据要发送了。但如果 B 还有数据要发送，A 仍要接收。也就是说，从 B –&gt; A 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li>
<li>A 收到来自 B 的确认后，就进入 <code>FIN-WAIT-2</code> （终止等待2）状态，等待 B 发出的连接释放报文段。</li>
<li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 <code>FIN = 1</code> 。现假定 B 的序号为 w （在半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 <code>ack = u + 1</code> 。这时 B 就进入 <code>LAST-ACK</code> （最后确认）状态，等待 A 的确认。</li>
<li>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 <code>ACK = 1</code> ，确认号 <code>ack = w + 1</code> ，而自己的序号是 <code>seq = u + 1</code> （根据 TCP 标准，前面发送过的 FIN 报文段要消耗掉一个序号），然后进入到 <code>TIME-WAIT</code> （时间等待）状态。【<strong>注意：现在 TCP 连接还没有释放掉，必须经过时间等待计时器设置的时间 <code>2 MSL</code>（最长报文段寿命，RFC 793 建议设为 2 分钟，现如今 2 分钟可能已经太长了，可以自己修改合适的时间） 后，A 才能进入到 <code>CLOSED</code> 状态</strong>，然后才能开始建立下一个新的连接】。当 A 撤销相应的传输控制块 TCB 后，就算结束了这次的 TCP 连接。</li>
<li>B 只要收到了 A 发出的确认，立即进入 <code>CLOSED</code> 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。</li>
<li>可以看到，B 结束 TCP 连接的时间要比 B 早一些。</li>
</ul>
<h3 id="QAQ"><a href="#QAQ" class="headerlink" title="QAQ"></a>QAQ</h3><ol>
<li>Q：为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？</li>
</ol>
<p>A：答案是：①保证客户端发送的最后一个 ACK 报文段能够达到服务器；②防止已经失效的关闭连接报文段出现在本连接中。为什么这么说呢，可以来看看：  </p>
<ul>
<li>①由于这个 ACK 报文段有可能丢失，因而使处在 <code>LAST-ACK</code> 状态的 B 收不到对己发送的 FIN + ACK 报文段的确认。<br>B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。<br>接着 A 重传一次确认，重新启动 <code>2MSL</code> 计时器。最后，A 和 B 都正常进入到 <code>CLOSED</code> 状态。<br>如果 A 在 TIME-WAIT 状态不等待一段时间，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 <code>CLOSED</code> 状态。</li>
<li>② A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL ，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ul>
<ol start="2">
<li>Q：为什么是四次挥手而不是三次？</li>
</ol>
<p>A：因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p>
<ol start="3">
<li>Q：如果是三次挥手会有什么问题？</li>
</ol>
<p>A：等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E8%BE%93%E5%B1%82/" rel="tag">运输层</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-执行上下文" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/05/zhi-xing-shang-xia-wen/" class="article-date">
      <time datetime="2022-01-05T10:12:08.000Z" itemprop="datePublished">2022-01-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/05/zhi-xing-shang-xia-wen/">执行上下文</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们首先来看一个例子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照代码书写顺序，应该先输出 111，再输出 666 才对，但是很遗憾，两次输出均为 666。<br>如果我们将上述代码中的函数声明改为函数表达式，结果又不太一样：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//111</span>

<span class="token keyword">var</span> <span class="token function-variable function">f1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>是不是很意外，这其中的奥秘其实就在于JS的执行上下文里，看完下面的内容，你就会理解为什么了。</p>
<h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p><strong>JS 代码在执行之前，JS 引擎会先做一下“准备工作”，也就是创建对应的执行上下文。</strong><br>执行上下文有且只有三类：<strong>全局执行上下文</strong>，<strong>函数上下文</strong>，与eval上下文。由于eval一般不会使用，就不深入探究了。  </p>
<blockquote>
<p>插一句，在 JavaScript 中，运行环境主要包含了全局环境和函数环境。<br>而 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。<br>全局环境和函数环境所对应的执行上下文我们分别称为全局（执行）上下文和函数（执行）上下文。<br>下面进入正题：</p>
</blockquote>
<ol>
<li>全局执行上下文  </li>
</ol>
<ul>
<li>全局执行上下文只有一个，在客户端中一般由浏览器创建，也就是我们熟知的 window 对象，我们能通过 this 直接访问到它。<br><code>console.log(this);</code></li>
<li>全局对象 window 上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，如：<br><code>console.log(this.Math.random())</code>等</li>
<li>window 对象是 var 声明的全局变量的载体。我们通过 var 创建的全局对象，都可以通过 window 直接访问。  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
window<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<ol start="2">
<li>函数执行上下文<br>每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。（即使是调用同一个函数）<br>每次调用函数时，都会为该函数创建一个新的执行上下文。<br>于是我们很容易得知函数执行上下文可存在无数个。</li>
</ol>
<p>综上，执行上下文可以理解为代码在被解析以前或者在执行时候所处的环境。之所以这么理解，是因为全局上下文是在代码被解析前就已经由浏览器创建好了的，函数上下文是在函数调用时创建的。</p>
<blockquote>
<p>Q：接下来问题来了，我们写的函数多了去了，如何管理创建的那么多函数上下文呢？<br>A1：所以 JavaScript 引擎创建了执行上下文栈<code>（Execution context stack，ECStack）</code>【是一种拥有 LIFO（后进先出）数据结构的栈】来管理执行上下文。<br>A2：当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出  </p>
</blockquote>
<blockquote>
<p>既如此，当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 <code>globalContext</code> 表示它，并且只有当整个应用程序结束的时候（比如关闭网页或退出浏览器），ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 <code>globalContext</code> 。</p>
</blockquote>
<h2 id="执行上下文的三个重要属性"><a href="#执行上下文的三个重要属性" class="headerlink" title="执行上下文的三个重要属性"></a>执行上下文的三个重要属性</h2><h3 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h3><p>是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。   </p>
<blockquote>
<p>因为不同执行上下文下的变量对象稍有不同，所以来理一下全局上下文中的变量对象和函数上下文中的变量对象。</p>
<ul>
<li><strong>全局上下文中的变量对象就是全局对象！</strong><ul>
<li>全局对象是由 Object 构造函数实例化的一个对象。<br><code>console.log(this instanceof Object);</code></li>
</ul>
</li>
<li><strong>在函数上下文中，用活动对象来表示变量对象。</strong>      <ul>
<li>活动对象(activation object, AO)和变量对象其实是同一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</li>
<li>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>再看下执行过程：<strong>执行上下文的代码会分成两个阶段进行处理：创建（代码预编译）阶段 和 执行（代码执行）阶段</strong></p>
</blockquote>
<ul>
<li>1.预编译阶段（进入执行上下文，这时候还没有执行代码）<br>先进行语法分析，没有问题以后，在预编译阶段对JavaScript代码中<strong>变量的内存空间</strong>进行分配（变量提升就是在这个阶段完成的）。<ul>
<li>变量对象会包括：<ul>
<li>1）函数的所有形参 (如果是函数上下文)<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 <code>undefined</code></li>
</ul>
</li>
<li>2）函数声明【由名称和对应值（函数对象）组成一个变量对象的属性被创建】</li>
<li>3）变量声明【由名称和对应值（<code>undefined</code>）组成一个变量对象的属性被创建】</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>举个栗子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
   <span class="token keyword">var</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

   b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在进入执行上下文后，这时候的AO是：</span>
<span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
   arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>
       <span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
       length<span class="token operator">:</span><span class="token number">1</span>
   <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
   a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 函数调用时创建的函数上下文，所以为 1</span>
   b<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>
   c<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
   d<span class="token operator">:</span><span class="token keyword">undefined</span>
<span class="token punctuation">&#125;</span>
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">        

> [执行上下文创建阶段的另一种参考解释1](https://www.cnblogs.com/echolun/p/11438363.html)  
[执行上下文创建阶段的另一种参考解释2](https://blog.csdn.net/qq_33718648/article/details/90754331)  
[执行上下文创建阶段的另一种参考解释3](https://juejin.cn/post/6844903682283143181#heading-4)

- 2.代码执行阶段（执行代码逻辑，修改变量对象的值）
  </span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>js                
  <span class="token comment">// 还是上面的栗子，当代码执行完之后，这时候的AO是：</span>
  <span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
      arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>
          <span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
          length<span class="token operator">:</span><span class="token number">1</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
      a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
      b<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>
      c<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
      d<span class="token operator">:</span>reference to FunctionExpression <span class="token string">"d"</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总结上述所说：</p>
<ul>
<li>全局上下文的变量对象初始化是全局对象</li>
<li>函数上下文的变量对象初始化只包括 Arguments 对象</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li>
<li>在代码执行阶段，会再次修改变量对象的属性值，同时执行上下文在这个阶段会全部创建完成<h3 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h3>作用域链是指由当前上下文和上层上下文的一系列变量对象组成的层级链。</li>
</ul>
<p>我们已经知道，<strong>执行上下文分为创建和执行两个阶段</strong>，在执行上下文的执行阶段，当需要查找某个变量或函数时，会先在当前上下文的变量对象（活动对象）中进行查找，<strong>若是没有找到，则会依靠当前上下文中的作用域链，沿着上层上下文的变量对象进行查找，直到全局上下文中的变量对象（全局对象）</strong>。</p>
<blockquote>
<p>Q：既然如此，那作用域链又是怎么创建的？<br>A：我们都知道，JavaScript 中主要包含了全局作用域和函数作用域，而<strong>函数作用域是在函数被声明的时候确定的</strong>。<br>每一个函数都会包含一个 [[scope]] 内部属性，<strong>在函数被声明的时候，该函数的 [[scope]] 属性会保存其上层上下文的变量对象</strong>，形成包含上层上下文变量对象的层级链。**[[scope]] 属性的值是在函数被声明的时候确定的**。<br>当函数被调用的时候，其执行上下文会被创建并入栈。在创建阶段生成其变量对象后，会将该变量对象添加到作用域链的顶端并将 [[scope]] 添加进该作用域链中。而在执行阶段，变量对象会变为活动对象，其相应属性会被赋值。<br>所以，作用域链是由当前上下文变量对象及上层上下文变量对象组成的：<br><code>SC = AO + [[scope]]</code></p>
</blockquote>
<p>看个栗子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 分析如下：</span>
<span class="token comment">// 在 fn1 函数上下文中，fn2 函数被声明，所以</span>
fn2<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>fn1_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> globalObj<span class="token punctuation">]</span>

<span class="token comment">// 当 fn2 被调用的时候，其执行上下文被创建并入栈，此时会将生成的变量对象添加进作用域链的顶端，并且将 [[scope]] 添加进作用域链</span>
fn2_EC<span class="token punctuation">.</span><span class="token constant">SC</span><span class="token operator">=</span><span class="token punctuation">[</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token parameter">fn2<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span>
<span class="token operator">=></span>
fn2_EC<span class="token punctuation">.</span><span class="token constant">SC</span><span class="token operator">=</span><span class="token punctuation">[</span>fn2_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> fn1_EC<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span> globalObj<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面用个例子总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> scope2 <span class="token operator">=</span> <span class="token string">'local scope'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> scope2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>①由于先处理函数声明。于是checkscope 函数被创建，保存作用域链到内部属性[[scope]]（[[scope]] 属性会保存其上层上下文的变量对象（也就是全局对象））</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>②执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>
  checkscopeContext<span class="token punctuation">,</span>
  globalContext
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>③checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  Scope<span class="token operator">:</span>checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>读到这里可能会有以下疑问：</p>
<blockquote>
<p>Q1：checkscope函数被创建时保存到[[scope]]的作用域链，和 checkscope执行前的准备工作中复制函数[[scope]]属性创建的作用域链有什么不同？<br>A1：checkscope函数创建的时候，保存的是根据词法所生成的作用域链。checkscope执行的时候，会复制这个作用域链，作为自己作用域链的初始化，然后根据环境生成变量对象，然后将这个变量对象，添加到这个复制的作用域链，这才完整的构建了自己的作用域链。  </p>
</blockquote>
<blockquote>
<p>Q2：为什么会有两个作用域链？<br>A2：因为在函数创建的时候并不能确定最终的作用域的样子。而为什么会采用复制的方式而不是直接修改呢？应该是因为函数会被调用很多次吧。</p>
</blockquote>
<ul>
<li>④第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
  arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>
    length<span class="token operator">:</span><span class="token number">0</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  scope2<span class="token operator">:</span><span class="token keyword">undefined</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>⑤第三步：将活动对象压入checkscope 作用域顶端<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>
      length<span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    scope2<span class="token operator">:</span><span class="token keyword">undefined</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>⑥准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>
      length<span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    scope2<span class="token operator">:</span><span class="token string">'local scope'</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>⑦查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
至此，作用域链的知识点over :）<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3>首先需要清楚，<code>this</code> 是执行上下文的一个属性，而不是某个变量对象的属性。<code>this</code> 的指向也不是如常识一般指向某某，而是依据调用栈和执行位置决定的（即取决于函数在哪里被调用）。【 <code>this</code> <strong>是在运行时绑定的，并不是在编写时绑定</strong>】<blockquote>
<p>this 绑定有五种场景：默认绑定、隐式绑定、显式绑定、new绑定、箭头函数绑定</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>默认绑定<br>即函数调用时无任何调用前缀。默认绑定时，不管函数在何处调用， <code>this</code> 指向全局对象 <code>window</code>（非严格模式）；在严格模式下，默认绑定的 <code>this</code> 指向 <code>undefined</code>。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 666</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token string">"use strict"</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// --> 默认绑定</span>
<span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught TypeError: Cannot read property 'num' of undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>温馨提示：在严格模式下调用不在严格模式中的函数，并不会影响this指向，如下：</p>
  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'yfz'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// yfz</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token string">"use strict"</span><span class="token punctuation">;</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>
</li>
<li><p>隐式绑定<br>如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">,</span>
  func<span class="token operator">:</span> fn
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 666</span>

<span class="token comment">// 上面代码中，this 指向 obj，obj 有 num 属性，所以输出 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果函数调用前存在多个对象，this 指向距离调用自己最近的对象</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  num<span class="token operator">:</span> <span class="token number">666</span><span class="token punctuation">,</span>
  func<span class="token operator">:</span> fn<span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  num<span class="token operator">:</span> <span class="token number">111</span><span class="token punctuation">,</span>
  o<span class="token operator">:</span> obj
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这里稍微拓展一下，如果将 obj 对象的 name 属性注释掉，却会输出 undefined</p>
  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  func<span class="token operator">:</span> fn<span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span> <span class="token string">'yfz'</span><span class="token punctuation">,</span>
  o<span class="token operator">:</span> obj
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  obj 对象虽然是 obj1 的属性，但它们两个的原型链并不相同，并不是父子关系，由于 obj 未提供 name 属性，所以是 undefined 。注意不要将作用域链和原型链弄混淆了，如果有小伙伴不能弄清楚，也可以看看我的另一篇博客：<a href="https://hcyety.github.io/2022/01/07/yuan-xing-lian/">原型链</a>。</p>
</blockquote>
<blockquote>
<p>既然说到这里了，索性再理清一下作用域链与原型链的区别：<br>  –&gt; 当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象 window ，如果 window 都没有这个变量则报错。<br>  –&gt; 当在对象上访问某属性时，首先会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是 null ，如果全程都没找到则返一个 undefined ，而不是报错。</p>
</blockquote>
</li>
<li><p>显式绑定<br>指通过call、apply、bind以及js API中的部分方法改变this指向</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// call、apply、bind</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  num<span class="token operator">:</span> <span class="token number">111</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  num<span class="token operator">:</span> <span class="token number">666</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  num<span class="token operator">:</span> <span class="token number">999</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 111</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 666</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 999</span>

<span class="token comment">// API</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  num<span class="token operator">:</span> <span class="token number">666</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 3 次 666</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意，如果在使用 call 之类的方法改变this指向时，指向参数提供的是 null 或者 undefined ，那么 this 将指向全局对象。</p>
</blockquote>
</li>
<li><p>new绑定</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> echo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>echo<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token comment">// 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上方代码中，构造调用创建了一个新对象 echo ，而在函数体内，this 将指向新对象 echo 上</p>
</li>
</ul>
<blockquote>
<p>如果一个函数调用存在多种绑定方法，this最终指向谁呢？<br>这里给出前面四种绑定方法的优先级：<br>显式绑定 &gt; 隐式绑定 &gt; 默认绑定<br>new绑定 &gt; 隐式绑定 &gt; 默认绑定  </p>
<p>为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错。</p>
</blockquote>
<ul>
<li>箭头函数this指向:<br>箭头函数中没有自己的 this ，箭头函数的 this 指向取决于外层作用域中的 this ：外层作用域或函数的 this 指向谁，箭头函数中的 this 便指向谁；最终保障是指向 window 。</li>
</ul>
<blockquote>
<p>参考学习资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/echolun/p/11962610.html">this的指向问题</a><br>另外可学习冴羽大神之不同的角度看this：<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a></p>
</blockquote>
<p>说到这里，执行上下文的三个属性终于说完了，以上。</p>
<h2 id="执行上下文栈和执行上下文的具体变化过程"><a href="#执行上下文栈和执行上下文的具体变化过程" class="headerlink" title="执行上下文栈和执行上下文的具体变化过程"></a>执行上下文栈和执行上下文的具体变化过程</h2><p>还是那个例子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> scope<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>全局上下文初始化<pre class="line-numbers language-js" data-language="js"><code class="language-js">globalContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token constant">VO</span><span class="token operator">:</span><span class="token punctuation">[</span>global<span class="token punctuation">]</span><span class="token punctuation">,</span>
  Scope<span class="token operator">:</span><span class="token punctuation">[</span>globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token keyword">this</span><span class="token operator">:</span>globalContext<span class="token punctuation">.</span><span class="token constant">VO</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<ul>
<li>初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscope<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="3">
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>
  checkscopeContext<span class="token punctuation">,</span>
  globalContext
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>checkscope 函数执行上下文初始化：</li>
</ol>
<ul>
<li>1）复制函数 [[scope]] 属性创建作用域链，</li>
<li>2）用 arguments 创建活动对象，</li>
<li>3）初始化活动对象，即加入形参、函数声明、变量声明，</li>
<li>4）将活动对象压入 checkscope 作用域链顶端。</li>
<li>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]<pre class="line-numbers language-js" data-language="js"><code class="language-js">checkscopeContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token constant">AO</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>
    arguments<span class="token operator">:</span><span class="token punctuation">&#123;</span>
      length<span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    scope<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token punctuation">,</span>
    f<span class="token operator">:</span>reference to <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  Scope<span class="token operator">:</span><span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token keyword">this</span><span class="token operator">:</span><span class="token keyword">undefined</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="5">
<li>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>
  fContext<span class="token punctuation">,</span>
  checkscopeContext<span class="token punctuation">,</span>
  globalContext
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>f 函数执行上下文初始化, 以下跟第 4 步相同：</li>
</ol>
<ul>
<li>1）复制函数 [[scope]] 属性创建作用域链</li>
<li>2）用 arguments 创建活动对象</li>
<li>3）初始化活动对象，即加入形参、函数声明、变量声明</li>
<li>4）将活动对象压入 f 作用域链顶端<pre class="line-numbers language-js" data-language="js"><code class="language-js">fContext <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token constant">AO</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
  arguments<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      length<span class="token operator">:</span><span class="token number">0</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  Scope<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">AO</span><span class="token punctuation">,</span> checkscopeContext<span class="token punctuation">.</span><span class="token constant">AO</span><span class="token punctuation">,</span> globalContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token keyword">this</span><span class="token operator">:</span> <span class="token keyword">undefined</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol start="7">
<li>f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>
  checkscopeContext<span class="token punctuation">,</span>
  globalContext
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出<pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  globalContext
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<blockquote>
<p>以上就是执行上下文的全部知识点，以及其底层实现过程，希望对大家有所帮助。</p>
</blockquote>
<h2 id="最后注明"><a href="#最后注明" class="headerlink" title="最后注明"></a>最后注明</h2><p>学习资料参考冴羽大神的博客：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript深入之执行上下文栈</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript深入之变量对象</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript深入之作用域链</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/8">JavaScript深入之执行上下文</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E6%96%87/" rel="tag">技术文</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-原型链的继承" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/04/yuan-xing-lian-de-ji-cheng/" class="article-date">
      <time datetime="2022-01-04T04:50:10.000Z" itemprop="datePublished">2022-01-04</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/04/yuan-xing-lian-de-ji-cheng/">原型链的继承</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Q：什么是原型继承？<br>A：一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。</p>
<p>下面看看原型链的六种继承方式。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ul>
<li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'siyang'</span><span class="token punctuation">,</span> <span class="token string">'hcy'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
son<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy"]</span>
son<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy", "hg"]</span>

<span class="token keyword">var</span> sis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sis<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy", "hg"]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sis<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["siyang", "hcy", "hg"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h2></li>
<li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'kevin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span>
<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'daisy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// daisy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>优点：<ul>
<li>避免了引用类型的属性被所有实例共享：关键在于this指向（call 实现）；</li>
<li>可以在子构造函数中向父构造函数传参。</li>
</ul>
</li>
<li>缺点：由于必须在构造函数中定义方法，因此函数不能重用。<h2 id="组合继承（伪经典继承）（原型链继承-经典继承）"><a href="#组合继承（伪经典继承）（原型链继承-经典继承）" class="headerlink" title="组合继承（伪经典继承）（原型链继承+经典继承）"></a>组合继承（伪经典继承）（原型链继承+经典继承）</h2>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</li>
<li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token string">'hcy'</span><span class="token punctuation">,</span><span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
son<span class="token punctuation">.</span>color<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hcy</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["blue", "red"]</span>

<span class="token keyword">var</span> sister <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sister<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["blue"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。而且 <code>instanceof</code> 和 <code>isPrototypeof()</code> 也能够用于识别基于组合继承创建的对象。</li>
<li>缺点：<strong>会调用两次父构造函数</strong>。一次是设置子类型实例的原型的时候：<code>child.prototype = new Parent()</code> ；另一次在创建子类型实例的时候：<code>var son = new child(&#39;hcy&#39;,&#39;20&#39;)</code>。<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2>借助原型可以基于已有的对象创建新的对象，同时还不必因此创建自定义的类型。于是有了下面这个函数。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
在 <code>createObj()</code> 函数内部，先创建了一个临时性构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例</li>
</ul>
<p>看个栗子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span><span class="token string">'kevin'</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'daisy'</span><span class="token punctuation">,</span> <span class="token string">'kelly'</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'person1'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span>

person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'taylor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['daisy', 'kelly', 'taylor']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 <code>name</code> 值，而是因为<code>person1.name = &#39;person1&#39;</code>是给<code>person1</code>添加了 <code>name</code> 值，并非修改了原型上的 <code>name</code> 值。</p>
<ul>
<li>下面看看原型式的模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 创建一个临时性的构造函数</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// 将传入的对象作为这个构造函数的原型</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token comment">// 返回这个临时类型的一个新实例</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">"hcy"</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"et"</span><span class="token punctuation">,</span> <span class="token string">"siyang"</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> another <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hcy</span>
another<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["et", "siyang", "hg"]</span>
son<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'zbc'</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> sister <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sister<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hcy</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样</li>
<li>使用场景：不需要单独创建构造函数，但仍然需要在对象间共享信息</li>
</ul>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<p>举个栗子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span><span class="token string">'siyang'</span><span class="token punctuation">;</span>
  friends<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'hg'</span><span class="token punctuation">,</span><span class="token string">'hcy'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "hi"</span>

<span class="token comment">// 将 `createObj` 函数返回的结果赋值给 `clone` ，然后给 `clone` 添加了 sayName 方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  name<span class="token operator">:</span><span class="token string">'siyang'</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'hcy'</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> another <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
another<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello World!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法，函数不能复用使效率低下，与借用构造函数继承类似。</li>
<li>使用场景：主要关注对象，而不在乎类型和构造函数</li>
</ul>
<h2 id="寄生组合式继承（引用类型最理想的继承范式）"><a href="#寄生组合式继承（引用类型最理想的继承范式）" class="headerlink" title="寄生组合式继承（引用类型最理想的继承范式）"></a>寄生组合式继承（引用类型最理想的继承范式）</h2><p>即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。<br>基本思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。<br>本质上：使用寄生式继承来继承父类原型，然后再将返回的新对象赋值给子类原型。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> person</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>
  child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>栗子：<br>先放一个组合继承的代码</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>改造目标：不使用 <code>Child.prototype = new Parent()</code> ，而是间接的让 <code>Child.prototype</code> 访问到 <code>Parent.prototype</code>。</p>
<p>明白需求之后，开始动手：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 关键的三步</span>
<span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>于是封装：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">prototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>prototye<span class="token punctuation">)</span><span class="token punctuation">;</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>
  child<span class="token punctuation">.</span>prototpe <span class="token operator">=</span> prototype<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 当我们使用的时候：</span>
<span class="token function">prototype</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>优点：只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。同时，原型链还能保持不变；因此，还能够正常使用 <code>instanceof</code> 和 <code>isPrototypeOf。</code></p>
<ul>
<li>完整模拟实现：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">obj</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">child<span class="token punctuation">,</span> Parent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 创建父类原型的一个副本</span>
  <span class="token keyword">var</span> _prototype <span class="token operator">=</span> <span class="token function">obj</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 为创建的副本添加 constructor 属性，弥补因重写原型而失去的默认的 constructor 属性</span>
  <span class="token class-name">_prototype</span><span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>
  <span class="token comment">// 将新创建的对象（即副本）赋值给子类原型</span>
  child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> _prototype<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> sister <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token string">'siyang'</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sister<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
sister<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// siyang</span>
sister<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sister<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  ["blue", "red", "yellow"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E6%96%87/" rel="tag">技术文</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-原型链" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/01/03/yuan-xing-lian/" class="article-date">
      <time datetime="2022-01-03T02:46:10.000Z" itemprop="datePublished">2022-01-03</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/01/03/yuan-xing-lian/">原型链</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="原型链的基本构想"><a href="#原型链的基本构想" class="headerlink" title="原型链的基本构想"></a>原型链的基本构想</h2><p>Q：什么是原型链？<br>A：当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 <code>Object.prototype</code> 的原型时，此时原型为 <code>null</code> ，查找停止。这种通过 通过原型链接的逐级向上的查找链被称为原型链。</p>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。下面 step by step 来探究原型链的奥妙。<br><img src="https://s4.ax1x.com/2022/01/07/7pek60.png" alt="原型链中的各种关系"><br>从上图我们可以了解到构造函数（<code>Person</code>）、原型（<code>Person.prototype</code>）和实例（<code>person</code>）之间的关系：<br>每个构造函数都有一个原型对象（用<code>Person.prototype</code>），原型对象都包含一个指向构造函数的指针（用<code>Person.prototype.constructor</code>获取），而实例都包含一个指向原型对象的内部指针（用<code>person._proto_</code>）。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p>
<p>下面来认识 <code>constructor</code> 和 <code>_proto_</code>：</p>
<ol>
<li>constructor<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在解释为什么之前，我们需要了解到原型链的搜索机制：在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。<strong>对属性和方法的搜索会一直持续到原型链的末端</strong>。</p>
</blockquote>
</li>
</ol>
<p>那么现在可以来看看为什么代码块中的打印会为 true 了：当获取 person.constructor 时，其实 person 中并没有 <code>constructor</code> 属性，当不能读取到 <code>constructor</code> 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性。</p>
<ol start="2">
<li><strong>proto</strong><br>是实例对象指向原型对象的指针，隐式原型，是每个对象都会有的一个属性。</li>
</ol>
<p>来看个例子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 继承了 SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

SubType<span class="token punctuation">.</span>prototpye<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码我们可以看到，<code>SubType</code> 通过创建 <code>SuperType</code> 的实例继承了 <code>SuperType</code>，于是 <code>SubType</code> 从构造函数变成了实例，<code>SuperType</code> 的实例变成了 <code>SubType</code> 的原型。这样一来，原本存在于 <code>SuperType</code> 的实例中的所有属性和方法，现在也存在于 <code>SubType.prototype</code>中了。<br>后面的代码还在继承的基础上，给 <code>SubType</code> 添加了一个新方法。于是：<img src="../img/36.png"><br>提醒：<code>getSuperValue()</code>方法仍然还在 <code>SuperType.prototype</code>中，但<code>property</code>则位于<code>SubType.prototype</code>中。这是因为<code>property</code>是一个实例属性，而<code>getSuperValue()</code>则是一个原型方法。既然<code>SubType.prototype</code>现在是<code>SuperType</code>的实例，那么<code>property</code>当然就位于该实例中了。<br>于是我们懂了，当原型对象等于另一个类型的实例后，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么如此递进，就会构成实例与原型的链条，也就是原型链。</p>
<h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>实际上，原型链中还有一环。我们知道所有引用类型默认都继承自 <code>Object</code> ，所有函数的默认原型也都是 <code>Object</code> 的实例，因此默认原型都会包含一个内部指针，指向 <code>Object.prototype</code> 。这也正是所有自定义类型都会继承 <code>toString()</code>、<code>valueOf()</code> 等默认方法的根本原因。</p>
<h3 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h3><p>原型与实例的关系可以通过两种方式来确定。<br>①是使用 <code>instanceof</code> 操作符，如果一个实例的原型链中出现过相应的构造函数，则 <code>instanceof</code> 返回 <code>true</code>。如下所示：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 继承了 SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SubType</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从技术上讲，<code>instance</code> 是 <code>Object</code>、<code>SubType</code>、<code>SuperType</code> 的实例，因为 <code>instance</code> 的原型链中包含这些构造函数的原型。</p>
<p>②是使用 <code>isPrototypeOf()</code> 方法。原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回 <code>true</code> 。如下所示：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="原型链的问题："><a href="#原型链的问题：" class="headerlink" title="原型链的问题："></a>原型链的问题：</h3><ol>
<li>原型中如果存在引用类型的值，会被所有实例共享，如下所示：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'greeb'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span> <span class="token comment">// "red, blue, green, black"</span>

<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "red, blue, green, black"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
如果原型的属性被所有的实例共享，就会存在一个实例修改了这个属性后，也会影响到其他实例，这往往会造成一些不必要的麻烦。因此，通常的做法是在构造函数中，而不是在原型中定义属性，如：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["black"]</span>

<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance2<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li>
</ol>
<p>实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。<br>为了解决这些问题，可以使用一种叫做 借用构造函数的技术（有时候也叫做伪造对象或经典继承），即在子类型构造函数的内部调用超类型构造函数。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 继承了 SuperType ，同时还传递了参数</span>
    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 实例属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'siyang'</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "siyang"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 29</span>

<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'hg'</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "hg"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 28</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上代码在 SubType 内部使用 call 实现了对 SuperType 的”继承”，同时每个实例都有自己的实例属性，互不影响；而且创建实例时还可以向超类型 SuperType 传递参数。</p>
<blockquote>
<p>说到原型链的继承，也是一个 JS 必须学习的一个重点，在我另一篇博客中也有详细介绍：<a href="https://hcyety.github.io/2022/01/07/yuan-xing-lian-de-ji-cheng/">原型链的继承</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E6%96%87/" rel="tag">技术文</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-var-let-const-的区别使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/12/27/var-let-const-de-qu-bie-shi-yong/" class="article-date">
      <time datetime="2021-12-27T07:29:11.000Z" itemprop="datePublished">2021-12-27</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/12/27/var-let-const-de-qu-bie-shi-yong/">var let const 的区别使用</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><strong>用于声明变量，变量声明的同时，可以赋值也可不赋值（不赋值的情况下，变量会保存一个特殊值 <code>undefined</code> ），后续可以更改变量的值。</strong></p>
<ul>
<li>注意1：<ul>
<li>变量名可以包含字母，数字，下划线和美元符号，但要以字母开头【也可以以$和_开头（但一般不这么用）】。</li>
<li>变量名是大小写敏感的（y和Y是不同的变量）</li>
<li>保留字（如JavaScript关键字）不能作为变量名使用</li>
</ul>
</li>
<li>注意2：var会发生“变量提升”现象。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> age<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这就是所谓的“变量提升”，也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用 var 声明同一个变量也没有问题：<pre class="line-numbers language-js" data-language="js"><code class="language-js">  <span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>
### <span class="token keyword">var</span> 声明作用域
使用 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">var</span><span class="token template-punctuation string">`</span></span> 操作符定义的变量会成为 包含它的函数的局部变量。比如，使用 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">var</span><span class="token template-punctuation string">`</span></span> 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>`js
<span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">'hi'</span><span class="token punctuation">;</span>  <span class="token comment">// 局部变量</span>
<span class="token punctuation">&#125;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 出错！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
这里，<code>message</code> 变量是在函数内部使用 <code>var</code> 定义的。函数为 <code>test()</code> ，调用它就会创建这个变量并给该变量赋值；调用之后变量随即被销毁，因此实例中的最后一行会导致错误。<br>不过，在函数内定义变量时省略 var 操作符，可以创建一个全部变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  message <span class="token operator">=</span> <span class="token string">'hi'</span><span class="token punctuation">;</span>  <span class="token comment">// 全局变量</span>
<span class="token punctuation">&#125;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "hi"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
去掉之前的 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test() ，就会定义这个变量，并且可以在函数外部访问到。<blockquote>
<p>注意：虽然可以省略 var 操作符定义全局变量，但不推荐这么做。因为在局部作用域中定义的全局变量很难维护，也会造成困扰。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 <code>ReferenceError</code> 。</p>
</blockquote>
</li>
</ul>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><strong>它的用法类似于var，但是所声明的变量，只在 let 命令所在的代码块内有效。</strong> 看下面例子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'hg'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hg</span>
<span class="token punctuation">&#125;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hg</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
<span class="token punctuation">&#125;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError：age 没有定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，age 变量之所以不能再 if 块外部被引用，是因为它的作用域仅限于该块内部。<br>由于块作用域是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let 。</p>
<ul>
<li>注意1：let不允许在相同作用域内，重复声明同一个变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js">  <span class="token comment">// 报错</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 报错</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 报错</span>
  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> arg<span class="token punctuation">;</span> 
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// 不报错</span>
  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span>
      <span class="token keyword">let</span> arg<span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">     
- 注意2：let不像var那样会发生“变量提升”现象。

## const
**声明一个只读的常量。一旦声明，常量的值就不能改变；且声明变量时，就必须立即初始化，不能留到以后赋值。**
- 注意1：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 的作用域与 </span><span class="token template-punctuation string">`</span></span><span class="token keyword">let</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 命令相同：只在声明所在的块级作用域内有效。
- 注意2：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 命令声明的常量也是不提升，只能在声明的位置后面使用。
- 注意3：</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 声明的常量，也与 </span><span class="token template-punctuation string">`</span></span><span class="token keyword">let</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 一样不可重复声明。
- 注意4：对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。</span><span class="token template-punctuation string">`</span></span><span class="token keyword">const</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> 声明的限制只适用于它指向的变量的引用。**const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，也就是说，如果 const 变量引用的是一个对象，那么修改整个对象内部的属性并不违反 const 限制。**   
    栗子1：
    </span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>js
    <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>
    foo <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// TypeError："foo" is read-only</span>

    <span class="token comment">// 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
  栗子2：  <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可执行</span>
a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 可执行</span>
a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Dave'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 报错</span>

<span class="token comment">// 上面代码中，常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a ，就会报错。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>关于变量提升，还有一些东西可以探讨一下。首先，变量提升是指把变量声明提升到当前执行环境的最顶端。</p>
<p>看一个例子：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错ReferenceError</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">// 以上代码可看作：</span>
<span class="token keyword">var</span> foo<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错ReferenceError</span>
foo <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码中，由于 <code>var</code> 发生了“变量提升”现象，将 <code>foo</code> 的声明提升到了 <code>console.log(foo)</code> 前面，即脚本开始运行时，变量 <code>foo</code> 已经存在了，但是没有值，所以会输出 <code>undefined</code>。<br>变量 <code>bar</code> 用 let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol>
<li><code>var</code> 和 <code>function</code> 的变量提升是有优先级的，且 <code>function</code> 的高于 <code>var</code> 的。（另外，如果函数名字相同，后面函数会覆盖前面的函数。）<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// ƒ a() &#123;&#125;</span>

<span class="token comment">// 可以隐式地理解为：</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ƒ a() &#123;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>当遇到函数和变量同名且都会被提升的情况，由于函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：function a()&#123; alert('我是函数') &#125;</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出：'我是变量'</span>

<span class="token comment">// 上面代码可以隐式的理解为：</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是函数'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> 
<span class="token keyword">var</span> a<span class="token punctuation">;</span>    <span class="token comment">// undefined</span>
<span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//输出：function a()&#123; alert('我是函数') &#125;</span>
a <span class="token operator">=</span> <span class="token string">'我是变量'</span><span class="token punctuation">;</span><span class="token comment">//赋值</span>
<span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出：'我是变量'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>var 和 function 的变量提升优先级显而易见，但如果是函数声明 <code>function foo()&#123;&#125;</code> 和函数表达式 <code>var foo = function()&#123;&#125;</code> 呢？<pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token comment">// function f1()&#123;&#125;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 函数表达式</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 函数声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
上面的代码并不是说函数声明的提升优先级高于函数表达式，而是因为当遇到函数表达式的时候，首先会将<strong>关键字+变量名</strong>提升到当前执行环境的最顶端，也就是<code>var f2</code> 先被提升，然而此时 <code>f2</code> 的值为 <code>undefined</code>，所以 <code>f2</code> 打印值为 <code>undefined</code>。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-JS-之作用域" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2021/12/23/js-zhi-zuo-yong-yu/" class="article-date">
      <time datetime="2021-12-23T14:12:20.000Z" itemprop="datePublished">2021-12-23</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2021/12/23/js-zhi-zuo-yong-yu/">JS 之作用域</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>是指作用域是指程序源代码中定义变量的区域。</p>
<ul>
<li>块级作用域<br>指在代码块 {} 里面定义的变量，只会在当前代码块有效，如果外层作用域下想访问该变量，会报引用错误异常。<br>使用关键字 <code>let</code> 或 <code>const</code> 定义块级作用域的变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// ReferenceError: i is not defined</span>

<span class="token comment">// 因为 i 是用 let 生命的，只能在 let 的作用域里使用，即 for 循环内部有效，外部作用域是访问不到的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>函数作用域<br>是指包裹在函数里的作用域，其中的变量或者内部函数，对外都是封闭的，即外界无法访问。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token comment">// ReferenceError: a, b, c is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>全局作用域<br>是最外层的全局作用域，任何地方都可以访问得到。<br>在最外层作用域下使用 var 关键字会定义全局变量，也就是说会挂载在 window 对象上，或者不使用关键字 var、let、const 直接对变量名字进行赋值，JS也会自动为其创建为全局变量。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    b <span class="token operator">=</span> <span class="token number">20</span>

    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        c <span class="token operator">=</span> <span class="token number">30</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// b 和 c 变量被隐式声明到全局变量了，所以能访问到，这也叫变量提升机制</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// 30</span>

<span class="token comment">// 但 a，b，c 也被挂载在 window 对象（全局作用域）上面了</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token comment">// 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token comment">// 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<ul>
<li>词法作用域<br>在变量定义时决定（也叫静态作用域）。例如函数的作用域是在函数<strong>定义</strong>时决定的。  </li>
<li>动态作用域<br>在变量调用时才决定。例如函数的作用域是在函数<strong>调用</strong>的时候才决定的。<br>基于这两种作用域的不同，于是作用域的嵌套情况也不相同。 </li>
</ul>
<p>下面来看一个案例：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 结果是？？？</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>假设JavaScript采用静态作用域，让我们分析下执行过程：<ul>
<li>嵌套情况：全局作用域–&gt;foo函数作用域–&gt;bar函数作用域</li>
<li>于是：执行 <code>foo</code> 函数，先从 <code>foo</code> 函数作用域里查找是否有局部变量 <code>value</code>。如果没有，就根据函数定义的位置，往外一层的作用域里查找变量，发现在全局作用域里找到变量 <code>value</code> ，所以结果会打印 1。</li>
</ul>
</li>
<li>假设JavaScript采用动态作用域，让我们分析下执行过程：<ul>
<li>嵌套情况：全局作用域–&gt;bar函数作用域–&gt;foo函数作用域</li>
<li>于是：执行 <code>foo</code> 函数，依然是从 <code>foo</code> 函数作用域里查找是否有局部变量 <code>value</code>。如果没有，就从调用函数的作用域，再往外一层也就是 <code>bar</code> 函数作用域里查找 <code>value</code> 变量，所以结果会打印 2。</li>
</ul>
</li>
<li>由于<strong>JavaScript采用的是静态作用域</strong>，所以这个例子的结果是 1。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E6%96%87/" rel="tag">技术文</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 hcyety
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>